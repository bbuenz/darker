\documentclass{article}
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics,advantage]{cryptocode}
\usepackage{notations}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsmath,amsthm,amssymb}
\usepackage[utf8x]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{xspace}
\usepackage[normalem]{ulem}
\usepackage{comment}
\usepackage{hyperref}

%Theorems
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{fact}{Fact}
\newtheorem{corollary}{Corollary}

\newif\ifcomments
\commentstrue


\ifcomments
	\newcommand{\benedikt}[1]{{\textcolor{red}{[Benedikt: #1]}}}
	\newcommand{\ben}[1]{{\textcolor{green}{[Ben: #1]}}}
	\newcommand{\alan}[1]{{\todo[color=blue!40!white]{Alan: #1}}}
	\newcommand{\alaninline}[1]{{\todo[color=blue!20!white, inline]{Alan: #1}}}
		\newcommand{\ignore}[1]{}

	\else
	\newcommand{\benedikt}[1]{}
	\newcommand{\ben}[1]{}
	\newcommand{\alan}[1]{}
	\newcommand{\alaninline}[1]{}
	\fi

\date{}

\begin{document}
\title{Transparent SNARKs from DARK Arguments}
\maketitle

\begin{abstract} 
We construct a new polynomial commitment scheme for multivariate polynomials over finite fields, with public-coin evaluation proofs that have logarithmic communication in the degree of the polynomial. The techniques are reminiscent of \emph{Diophantine Arguments of Knowledge} (Lipmaa, Asiacrypt'03), leveraging integer representations of polynomials and groups of unknown order. Security is shown from falsifiable assumptions that hold in generic groups. Moreover, the scheme does not require a trusted setup if instantiated with class groups. We apply this new cryptographic compiler to algebraic linear IOPs in order to obtain doubly-efficient public-coin IPs with succinct communication and witness-extended emulation for any NP relation. Allowing for linear preprocessing, the online verifier's work is logarithmic in the circuit complexity of the relation.

Concretely, compiling a QAP-based IOP results in quadratic prover time, but we obtain quasi-linear prover time when compiling instead the IOP employed in Sonic (Maller \emph{et. al.}, CCS 2019) based on bivariate Laurent polynomials. Applying the Fiat-Shamir transform in the random oracle model results in a transparent preprocessing zk-SNARK system with quasi-linear prover time, logarithmic proof size, and logarithmic verification time for arbitrary circuits, which we call \textsf{\textbf{Supersonic}}. This is the first zk-SNARK without trusted setup with only logarithmic proof sizes and verification time.\alan{The STARK proof system also qualifies for that description, as do the CS proofs of Micali and Lai-Malavolta.} 

\end{abstract} 

\section*{Notes for Writing}
\begin{table}
    \caption{Notation}
    \label{tab:notation}
    \centering
    \begin{tabular}{l|l}
        Symbol & Meaning   \\ \hline \hline
        {\bf Sets} & \\ \hline
        $\ZZ_{< q}$ & Integers less than $q$ in absolute value\\
        \hline
        {\bf polynomials} & \\ \hline
        $f \in \mathbb{F}_p[X]$ or $f \in \mathbb{Z}[X]$ & polynomial modulo $p$ or without modulo, depending on context \\
        $f_L, f_R \in \mathbb{F}_p[X]$ & first and second half of $f(X)$ \\
        $f_0, f_1, f_i \in \mathbb{F}_p$ & coefficients \emph{s.t.} $f(X) = \sum_{i=0}^d f_ix^i$ \benedikt{$f(X)=f_L(X)+X^{d'} f_R$} \\ \hline
        {\bf group elements} &  \\ \hline
        $\mathsf{g} \in \mathbb{G}$ & designated base element (the term ``generator'' is misleading) \\ 
        $\mathsf{C}, \mathsf{C}_0, \mathsf{C}_1 \in \mathbb{G}$ & commitments \\
        $\mathsf{e}_0^a \times \mathsf{e}_1^b, \mathsf{e}_0^a\mathsf{e}_1^b \, \textnormal{for} \, a, b \in \mathbb{Z}$ & multiplicative notation \\ 
    \end{tabular}
\end{table}

\section{Introduction}

A polynomial commitment scheme enables a prover to bind himself to a polynomial in much less bandwidth than transmitting all coefficients would require. A skeptical verifier can subsequently test the commitment for certain algebraic relations as though he were in possession of the polynomial's full description, except at a much smaller work cost. Indeed, polynomial commitments lie at the heart of a host of efficiently verifiable interactive proof systems.

Of particular interest to this paper are proof systems whereby the prover establishes the correct performance of an arbitrary computation (that may or may not involve secret information) in such a way that the communication or verification complexity scales asymptotically better than performing the computation naÃ¯vely. Without exception, these proof systems rely on a technique called \emph{arithmetization}: characterizing the computation in question as a collection of arithmetic operations over a finite field. The utility of polynomial commitments stems from their capacity to succinctly capture a canonical representation of such collections while retaining the algebraic properties that make arithmetization work in the first place.

The literature on proof systems for arbitrary computations focuses on two techniques to achieve polynomial commitments. First: Merkle trees --- here every leaf represents the polynomial's evaluation in a given point, and the Merkle root represents the commitment to the polynomial. The verifier needs to verify the authentication paths of selected points, which can be done in logarithmic space and time (as a function of the number of points). Second: groups equipped with bilinear maps --- in this case a structured reference string (SRS)\footnote{Previously known as \emph{common reference string}, CRS.} provides the values of all monomials up to a given degree when evaluated in an unknown point. By computing a weighted sum of these monomial values, the prover obtains the evaluation of his polynomial in the unknown point. The verifier performs the pairing operation to verify that multiplicative relations hold between committed polynomials.

This paper provides a third option for generating polynomial commitment schemes, namely by relying on groups of unknown order --- such as the group of integers with multiplication modulo an RSA modulus of unknown factorization, or the ideal class group of an order of an imaginary quadratic number field. These groups have seen relatively little adoption or even attention from the cryptographic community because the only known constructions thereof have subexponential attack algorithms. As a result, for a practical security level, elements of groups of unknown order typically require several hundreds of bytes to represent, in contrast to the tens of bytes needed for elements of elliptic curves for which no subexponential algorithms exist. 

Nevertheless, groups of unknown order provide a property that groups of known order, such as elliptic curve groups, cannot match: they enable homomorphic  commitments to an \emph{infinite} domain, namely the integers. Indeed, if the prover were capable of reducing a large integer to a smaller one without sacrificing the homomorphic properties, then he must know the group's order. The power of integer commitments was already noted by Lipmaa~\cite{AC:Lipmaa03b} who characterizes proof systems arising therefrom as \emph{Diophantine} --- a reference to the family of languages for which such proof systems establish. Specifically, a set $S \subset \mathbb{Z}^n$ is called \emph{Diophantine} if it is the projection onto the first $n \leq m$ coordinates of the set of roots to a polynomial $P(X_1, \ldots, X_m) \in \mathbb{Z}[X_1, \ldots, X_m]$. Much more recently, Wesolowski produced a conceptually simple verifiable delay function (VDF) which builds on a proof of correct exponentiation in groups of unknown order. Building on this result, Boneh \emph{et al.} developed accumulators and vector commitments (with batch openings) from groups of unknown order~\cite{}. Both results have been received with great enthusiasm in the cryptocurrency community for their capacity to improve sustainability and scalability of blockchains.

\alaninline{Todo: \\
 - applications (trustless snarks etc) \\
 - implications (no unfalsifiable assumptions) \\
 - overview of techniques \\
 - related work}

\vspace{0.25cm}
\textsc{Contributions.} The contributions of this paper are divisible into three rubrics:
\begin{itemize}
    \item[] \textbf{Tools.} We start with an encoding scheme that represents polynomials over a prime field $\mathbb{F}_p$ as integers, by encoding the polynomial's coefficients into the integer's base-$q$ expansion. Adjoined with a group of unknown order and a designated base element $g \in \mathbb{G}$, this encoding scheme naturally gives rise to a polynomial commitment scheme that inherits its somewhat homomorphic properties. Next, we provide protocols for proving the correct evaluation of a committed polynomial, and showing that two polynomials have the same coefficients but flipped or rotated. We also present a protocol for extracting the $i$th coefficient, thereby promoting the commitment scheme to one that also provides vector commitment functionality. Building on this observation, we provide another protocol for showing that a commitment represents the inner product between two vectors of which at least one is represented by its vector commitment. Another protocol establishes that two vector commitments represent the same vector up to an arbitrary but known permutation of the coefficients.
    \item[] All the proof systems mentioned so far have logarithmic communication complexity and logarithmic verification time. Moreover, with the exception of the inner product proof and the permutation proof, the prover's complexity is quasi-linear. If one is willing to sacrifice this scalability for the prover, we also provide counterparts to all the above proofs with constant communication and verification complexity.
    \item[] \textbf{Applications.} To illustrate the usefulness and the versatility of the enumerated tools, we join them straightforwardly to construct a simple succinct non-interactive argument of knowledge (SNARK) based on quadratic arithmetic programs (QAPs). To the best of our knowledge, this is the first SNARK for circuits without trusted setup (when instantiated with the class group) or with an SRS whose size is independent of the circuit (when instantiated with the RSA group).\footnote{This classification takes note of the STARK proof system of Ben Sasson \emph{et al.}~\cite{C:BBHR19} whose verification time is polylogarithmic but as a function of the \emph{running time} of some program and not of any circuit; as well as of Hyrax~\cite{SP:WTTW17} and Spartan~\cite{eprint:Setty19}, which do apply to circuits but whose verification times are not polylogarithmic and thus fail to satisfy the definition of SNARKs as set forth in the paper that coined the term~\cite{JC:BCCGLRT17}.}
    \item[] \alan{deprecated} We follow up this conceptually simple QAP-based proof system with a survey of popular communication-efficient proof systems for arbitrary computations, in which we replace their constituent components with tools developed earlier in this paper. In this light we analyze Sonic, Spartan, Hyrax, Bulletproofs, and STARK. In all cases we find that using our techniques leads to different trade-offs; improving on some metrics while degrading others.
\end{itemize}

\subsection{Related Work}

Homomorphic integer commitment schemes based on the RSA group were first proposed by Fujisaki and Okamoto~\cite{C:FujOka97}, who also provide a protocol to prove that a list of committed integers satisfy a polynomial equation modulo an arbitrary positive integer as well as one for opening a commitment bit by bit. DamgÃ¥rd and Fujisaki~\cite{AC:DamFuj02} fix an issue with the soundness proof of that protocol and are the first to suggest using class groups of an imaginary quadratic order as a candidate group of unknown order. Around the same time, Lipmaa draws the link between zero-knowledge proofs constructed from integer commitment schemes and Diophantine complexity~\cite{AC:Lipmaa03b}. Much later, Couteau~\emph{et al.} study protocols derived from integer commitments specifically in the RSA group in order to lift their security proofs so as to require weaker assumptions; in the process they develop proofs for polynomial evaluation modulo a prime $\pi$ that is not initially known to the verifier, in addition to a proof showing that an integer $X$ lies in the range $\{a, \ldots, b\}$ by showing that $1+4(X-a)(b-X)$ decomposes as the sum of 3 squares~\cite{EC:CouPetPoi17}.

Spurred by the recent demand for cryptographic tools from the blockchain industry, Pietrzak~\cite{Pietrzak18} adds efficient verifiability to the RSA-based time lock puzzle due to Rivest, Shamir, and Wagner~\cite{RivShaWag96}, thereby obtaining a conceptually simple verifiable delay function (VDF). Wesolowski~\cite{EC:Wesolowski19} improves on this result by proposing a single-round protocol to prove correct exponentiation in groups of unknown order, down from a logarithmic (in the size of the exponent) number for Pietrzak's protocol. Boneh~\emph{et al.} generalize this protocol to arbitrary exponents (not just powers of 2), and adapt it for zero-knowledge and batching, providing the base tools for constructing efficient accumulators and vector commitment schemes~\cite{C:BonBunFis19}.

\section{Preliminaries}
\benedikt{Merge with table}
\paragraph{Notation}
\begin{itemize}
\item Let $f(X) \in \mathbb{F}_p[X]$ be a polynomial of degree at most $N-1$ where $N$ is a power of two. The coefficients of $f(X)$ are denoted by $f_i$ such that $f(X) \stackrel{\triangle}{=} \sum_{i=0}^{N-1} f_i X^i$.
\item Throughout, $p$ is a prime of at least $\lambda$ bits, and $q \in \mathbb{N}$ be an integer with $q \gg p$.  $\primes$ denotes the set of primes less than $2^{2\cdot \lambda \log(\lambda)}$. There are at least $2^\lambda$ primes in that set.
\item We work in a group $\mathbb{G}$ of unknown order together with one or many designated base elements $\gr{g}, \gr{h} \in \mathbb{G}$ with unknown order. 
%(It might be tempting refer to these elements as \emph{generators} but that terminology would imply that $\mathbb{G}$ is cyclic, which is not necessarily true. \ben{Every element is a generator of a cyclic subgroup; why make this comment at all?}\textcolor{blue}{Alan: true; moot point.})
We use multiplicative notation and use \textsf{sans-serif} font to indicate group elements, as opposed to integers, polynomials, or field elements.
\item Some protocols in this paper are between two parties, the prover and the verifier. We write $\boldsymbol{\it Protocol}(X;w) \rightarrow (y;z)$ to describe such a protocol with common input $X$, private input for the prover $w$, public output $y$, and private output for the prover $z$. We write $(y;z) \gets \boldsymbol{\it Protocol}(X;w)$ to denote the protocol's execution. Any of $X,w,y,z$ can consist of tuples of objects. This notation facilitates protocol composition and modular analysis.

\item We use the notation $\negl$ to denote negligible function $\textsf{negl}: \mathbb{N} \rightarrow [0,1]$ applied to the security parameter $\lambda$. 

\end{itemize}

\subsection{Assumptions}

The cryptographic compilers make extensive use of groups of unknown order, \emph{i.e.}, groups for which the order cannot be computed efficiently.
Concretely, we require groups for which two specific hardness assumptions hold.
First the strong RSA assumption\cite{CCS:CraSho99} which roughly states that it is hard to take \emph{arbitrary} roots of \emph{random} elements. Secondly, the much newer adaptive root assumption\cite{EC:Wesolowski19} which is the dual of the strong RSA assumption and states that it is hard to take \emph{random} roots of \emph{arbitrary} group elements. 
Both of these assumption hold in generic groups of unknown order\cite{genericunknown,C:BonBunFis19}, i.e. there are no efficient algorithms that only have black-box access to the group but are able to break these assumptions. 
It is an open research problem to show whether one of these assumption implies the other.


\begin{assumption}[Dyadic Strong RSA Assumption]
\label{assum:strongRSA}
The \defn{Dyadic Strong RSA Assumption} sates that no efficient adversary can compute any root of a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
\[
    \Pr\left[\gr{u}^\ell = \gr{g} \, \wedge \, \ell\neq 2^k, k \in \NN:
    \begin{array}{l}
         \GG \leftarrow \ggen(\lambda)  \\
         \gr{g} \sample \GG \\
         (\gr{u}, \ell) \in \mathbb{G} \times \mathbb{N} \leftarrow \adv(\mathbb{G}, \gr{g}) \\
    \end{array}\right] \leq \negl \enspace .
\]
\end{assumption} 
We note that some definitions of the strong RSA assumption additionally require that $\ell$ be a prime~\cite{EC:BarPfi97}. Our definition does not require $\ell$ to be a prime but we explicitly exclude $\ell$ from being a power of $2$. This is because in class groups taking square roots and power of $2$ roots can be done in polynomial time\cite{bosma1996computation}.
\begin{assumption}[Adaptive Root Assumption]
\label{assum:adaptiveroot}
We say that the \defn{Adaptive Root Assumption} holds for $\ggen$ if 
there is no efficient adversary $(\adv_0,\adv_1)$ that succeeds 
in the following task.
First, $\adv_0$ outputs an element $\gr{w} \in \GG$ and some $\state$.
Then, a random prime $\ell$ in $\primes$ is chosen
and $\adv_1(\ell,\state)$ outputs $\gr{w}^{1/\ell} \in \GG$.
More precisely, for all efficient $(\adv_0,\adv_1)$:
\[           \advantage{AR}{(\adv_0,\adv_1)}\deq 
                \Pr\left[\gr{u}^\ell = \gr{w} \neq 1 \ : \ 
                \begin{array}{l}
                      \GG \sample \ggen(\lambda) \\ 
                      (\gr{w},\state) \sample \adv_0(\GG) \\
                      \ell \sample \primes \\ 
                      \gr{u} \gets \adv_1(\ell, \state)
                \end{array} 
        \right] \leq \negl.
\]
\end{assumption}

We additionally use two more assumptions, however both of them reduce to the Strong RSA and the Adaptive Root assumptions.

The first assumption states that computing the order for \emph{any} element is hard. It reduces to the adaptive root assumption. Interestingly, it doesn't necessarily hold for all candidate groups of unknown order. In $\ZZ_n$ for composite $n$, the element $-1\in \ZZ_n$ has known order $2$. For other candidate groups such as class groups with fundamental discriminants or $\ZZ_n/\{-1,1\}$ we have no efficient algorithms for computing elements of known order. We note that if $n=p\cdot q$ for strong primes $p$ and $q$ and we operate in the group of quadratic residues of $\ZZ_n$ then the order assumption reduces to the strong RSA assumption.\benedikt{Suitable citation}
\begin{assumption}[Order assumption]
\label{assum:order}
	The order assumption holds for $\ggen$ if for any efficient adversary $\adv$:
\[        
                \Pr\left[\gr{w}\neq 1 \wedge \gr{w}^{\alpha}= 1: 
                \begin{array}{l} 
                      \GG \sample \ggen(\lambda) \\ 
                      (\gr{w},\alpha) \sample \adv(\GG) \\
                      \text{where } |\alpha|<2^{\poly{}}\in \ZZ\\
                      \text{and } \gr{w}\in \GG
                \end{array} 
        \right] \leq \negl \enspace .
\]
\end{assumption}
\begin{lemma}
\label{lem:ordertoadaptive}
	The adaptive root assumption implies the order assumption.
\end{lemma}
\begin{proof}
	We show that given an adversary $\adv_{\textsf{Order}}$ that breaks the order assumption we can construct with overwhelming probability $\adv_{\textsf{Adaptive Root}}$ that breaks the adaptive root assumption. We run $\adv_{\textsf{Order}}$ to get a $\gr{w}\neq 1\in \GG$ and $\alpha \in \ZZ$ such that $\gr{w}^{\alpha}=1$. To construct $\adv_{\textsf{Adaptive Root}}$, $\adv_{\textsf{Adaptive Root},0}$ outputs $(\gr{w},\alpha)$. The challenger generates a random challenge $\ell$. If $\gcd(\ell,\alpha)=1$ then $\adv_{\textsf{Adaptive Root},1}$ can compute $\beta\gets \ell^{-1} \bmod \alpha$ and output $\gr{u}\gets\gr{w}^{\beta}$. By construction $\gr{u}^{\ell}=\gr{w}$. The probability that $\gcd(\ell,\alpha)=1$ is overwhelming because $\gcd(\ell,\alpha)\neq 1 \implies \ell \not\vert \alpha$. This happens with negligible probability as $\ell$ is picked from a set of $2^\lambda$ primes and at most $\poly$ distinct primes can divide $\alpha$.
	\end{proof}
	
	
We additionally define the fractional root assumption which is a generalization of the Strong RSA Assumption. It states that for random group elements $\gr{g}$ it is hard to find a tuple $(\gr{u}\in \GG,\alpha\in \ZZ,\beta\in \ZZ)$ such that $\gr{u}^{\beta}=\gr{g}^{\alpha}$, unless $\frac{\alpha}{\beta}$ is an dyadic rational, \emph{i.e.}, a rational whose denominator is a power of $2$. In RSA groups the assumption is also conjectured to hold if $\frac{\alpha}{\beta}$ is restricted to be an integer. We say that $(\gr{u},\alpha,\beta)$ is a \emph{fractional root} of $\gr{g}$.

 The fractional root assumption reduces to the order assumption (and therefore to the adaptive root assumption) and the strong RSA assumption. Shoup\benedikt{Cite shoup strong rsa paper} showed that for the unknown order group of quadratic residues in $\ZZ_n$, where $n$ is the composite of two strong primes, that the fractional root assumption reduces to just the strong RSA assumption.
\begin{assumption}[Dyadic Rational Root Assumption]
\label{assum:fracroot}
The fractional root assumption holds for $\ggen$ if for any efficient adversary $\adv$:
\[        
                \Pr\left[\gr{u}^\beta = \gr{g}^{\alpha} \wedge \frac{\beta}{\gcd(\alpha,\beta)}\neq 2^k,  k \in \NN   : 
                \begin{array}{l} 
                      \GG \sample \ggen(\lambda) \\ 
                      \gr{g} \sample \GG \\
                      (\alpha, \beta, \gr{u}) \sample \adv(\GG, \gr{g}) \\
                      \quad \textnormal{where} \, |\alpha|<2^{\poly}, |\beta|<2^{\poly} \in \ZZ \\
                      \quad \textnormal{and} \, \gr{u} \in \GG 
                \end{array} 
        \right] \leq \negl \enspace .
\]
\end{assumption}
\begin{lemma}
	The adaptive root assumption and the strong RSA assumption imply the fractional root assumption.
\end{lemma}
\begin{proof}
	Given an adversary $\adv_{\textsf{PseudoRoot}}$ that succeeds for $\ggen$ we can construct either an adversary $\adv_{RSA}$ for the strong RSA assumption or an adversary $\adv_{\textsf{Order}}$ that breaks the order assumption for $\ggen$. As shown in Lemma \ref{lem:ordertoadaptive} the order assumption reduces to the adaptive root assumption with overwhelming probability. 
	We first generate a group of unknown order $\GG \sample \ggen(\lambda)$.
	Then we generate $\gr{g}\sample \GG$ as done in the \textsf{RSA} security definition.
	
	We now run the $\adv_{\textsf{PseudoRoot}}$ on input $\GG$ and $\gr{g}$ to generate a tuple $(\alpha,\beta,\gr{u})$ such that $\gr{u}^{\beta}=\gr{g}^{\alpha}$. Let $\gamma=\gcd(\alpha,\beta)$ and $\alpha'=\frac{\alpha}{\gamma}\in \ZZ$ and  $\beta'=\frac{\beta}{\gamma}$. Now either $\gr{g}^{\alpha'}=\gr{u}^{\beta'}$ or $\gr{g}^{\alpha'}/\gr{u}^{\beta'}$ is a non trivial element of order $\gamma$ which would directly break the order assumption. In that case we constructed $\adv_{\textsf{Order}}$ that outputs $(\gr{g}^{\alpha'}/\gr{u}^{\beta'},\gamma)$.
	
	Now assume otherwise, i.e. $\gr{g}^{\alpha'}=\gr{u}^{\beta'}$. By construction $\gcd(\alpha',\beta')=1$ and we can efficiently compute integers $a,b$ such that $a \alpha'+b \beta'=1$. By assumption on $\adv_{\textsf{PseudoRoot}}$ $\beta'$ is not $1$. Now let $\gr{w}\gets \gr{u}^{a}\gr{g}^{b}$. Note that $\gr{w}^{\alpha'\beta'}=\gr{g}^{\alpha'}$. So either $\gr{w}^{\beta'}=\gr{g}$ or $\gr{w}^{\beta'}/\gr{g}$ is a non-trivial element of order $\alpha'$. The first case breaks the strong RSA assumption, as we can construct $\adv_{\textsf{RSA}}$ that outputs $(\gr{w},\beta)$, and the second breaks the order assumption.
\end{proof}


\benedikt{Talk about specific groups of unknown order}

\subsection{Interactive Arguments of Knowledge}
Interactive arguments are \emph{interactive proofs}~\cite{GolMicRac89} in which security holds only against a computationally bounded prover. In an interactive argument for a relation $\mathcal{R}$, the prover convinces the verifier that it ``knows" a witness $w$ for a statement $x$ such that $(x, w) \in \mathcal{R}$. The standard definition of \emph{proofs of knowledge} (PoK) by Bellare and Goldreich~\cite{C:BelGol92} is based on the existence of an extractor machine $E$ that has oracle access to a malicious prover $P^*$, and if $P^*$ would cause the verifier to accept on input $X$ with high probability then $E$ outputs $w$ such that $(X, w) \in \mathcal{R}$ (with overwhelming probability). $E$ runs in expected polynomial time. This definition quantifies the success of $E$ over all inputs $x$, which unfortunately is problematic in the case of interactive  \emph{arguments},.

To illustrate one issue, if the interactive argument relies on a \emph{common reference string} (CRS) setup with secret trapdoor information (e.g. the factorization of an RSA modulus) then one of the inputs $x^*$ could leak the trapdoor to the prover. Any extractor should clearly fail on input $x^*$ while $P^*$ may succeed, hence the definition cannot be satisfied. This particular problem is fixed by requiring the adversary $P^*$ to generate the input $x$. If the trapdoor is exponentially hard to compute the polynomial time adversary will not be able to embed the trapdoor in $x$ except with negligible probability. (See Damg\r{a}rd and Fujisaki~\cite{AC:DamFuj02} for a broader discussion of the issues that arise when applying the standard PoK definition to interactive arguments).

\emph{Witness-extended emulation}~\cite{EC:Lindell03} strengthens the PoK notion so that the extractor outputs not only a witness but also a simulated transcript of the messages between the prover and verifier. This property is helpful for security analysis when a PoK is used as a subprotocol within a larger protocol (e.g. a PoK of a commitment opening within a NIZK for arbitrary circuits), in particularly in order to construct a simulator that needs to both obtain the adverssary's witness as well as simulate its view in the sub-protocol. Groth and Ishai~\cite{EC:GroIsh08} adapt Lindell's definition for interactive arguments of knowledge (AoK) in the CRS model. This is the AoK definition we will use in the present work.

\begin{definition} [Interactive Argument]
Let $(P, V)$ denote a pair of PPT interactive algorithms and $\textsf{Setup}$ denote a non-interactive setup algorithm that outputs public parameters $\params$ given a security parameter. Both $P$ and $V$ have access to $\params$. Let $\langle P(pp, x, w), V(pp, x) \rangle$ denote the output of $V$ on input $x$ after its interaction with $P$, who has witness $w$. The triple $(\textsf{Setup}, P, V)$ is called an argument for relation $\mathcal{R}$ if for all non-uniform PPT adversaries $\mathcal{A}$ the following properties hold: 

\begin{itemize}
\item \underline{Perfect Completeness}. 
\[
\Pr \left[
\begin{array}{c}
        (x, w) \not \in  \mathcal{R} \ \text{or} \\
         \ \langle P(\params, x, w), V(\params, x) \rangle = 1 \\
\end{array}
:
\begin{array}{c}
             \params \leftarrow \textsf{Setup}(1^\lambda) \\
             (x, w) \leftarrow \mathcal{A}(\params) \\
\end{array} 
\right]  = 1 
 \]

\item \underline{Computational soundness}. 
\[
\Pr \left[
\begin{array}{c}
        \forall w \ (x, w) \not\in  \mathcal{R} \ \text{and} \\ 
         \langle \mathcal{A}(\params, x, \st), V(\params, x) \rangle = 1 
\end{array}
:
\begin{array}{c}
             \params \leftarrow \textsf{Setup}(1^\lambda) \\
             (x, \st) \leftarrow \mathcal{A}(\params) \\
\end{array}
        \right] \leq \negl
\]
\end{itemize} 
\end{definition} 

The interactive argument is called \textbf{public-coin} if all the verifier's messages are uniformly random values, independent of all prior messages and the setup parameters $\params$. 
We next recall the definition of witness-extended emulation for interactive arguments, which is a form of knowledge extraction.  

\begin{definition}[Witness-extended emulation~\cite{EC:GroIsh08}]\label{def:wee}
Given a public-coin interactive argument tuple $(\textsf{Setup}, P, V)$ and arbitrary prover algorithm $P^*$, let $\textsf{Record}(P^*, \params, x, \st)$ denote the message transcript between $P^*$ and $V$ on shared input $x$, initial prover state $\st$, and $\params$ generated by $\textsf{Setup}$. Furthermore, let $E^{\textsf{Record}(P^*, \params, x, \st)}$ denote an machine $E$ with a transcript oracle for this interaction that can be rewound to any round and run again on fresh verifier randomness. The tuple $(\textsf{Setup}, P, V)$ has witness-extended emulation if for every deterministic polynomial time $P^*$ there exists an expected polynomial time emulator $E$ such that for all non-uniform polynomial time adversaries $\mathcal{A}$ the following condition holds: 
\[
\Pr \left[
\mathcal{A}(\textsf{tr}) = 1
:
\begin{array}{c}
             \params \leftarrow \textsf{Setup}(1^\lambda) \\
             (x, \st) \leftarrow \mathcal{A}(\params) \\
             \tr \leftarrow \textsf{Record}(P^*, \params, x, \st)
\end{array} 
\right] \approx
\]
\[
\Pr \left[
\begin{array}{c} 
\mathcal{A}(\textsf{tr}) = 1 \ \text{and} \\ 
\text{\tr accepting} \Rightarrow \ (x, w) \in \mathcal{R}
\end{array} 
:
\begin{array}{c}
             \params \leftarrow \textsf{Setup}(1^\lambda) \\
             (x, \st) \leftarrow \mathcal{A}(\params) \\
(\textsf{tr}, w) \leftarrow E^{\textsf{Record}(P^*, \params, x, \st)}(\params, x)
\end{array}
\right]
\]

\end{definition}

%\alaninline{About the above definition: after reading [GI08] I think the adversary outputs a claim $X$ and a \emph{state} $\st$ (which may or may not be a witness). Otherwise you aren't considering adversaries that try to prove a claim without knowing a witness. I marked my proposed changes in blue because I'm not sure.}

\paragraph{Generalized special soundness} The following lemma was proven by Bootle et. al.~\cite{EC:BCCGP16} as a helpful tool for showing that an interactive argument has witness-extended emulation. It reduces the analysis to a generalized version of special soundness. 

Consider a public-coin interactive argument with $r$ rounds and verifier challenges sampled from an exponentially large message space. An \textbf{$\mathbf{(n_1,...,n_r)}$-tree of accepting transcripts} for the interactive argument on input $x$ is defined as follows. The root of the tree is labelled with the statement $x$. The tree has $r$ depth. Each node at depth $i < r$ has $n_i$ children, and each child is labelled with a distinct value for the $i$th challenge. An edge from a parent node to a child node is labelled with a message from prover to verifier. Every path from the root to a leaf corresponds to an accepting transcript, hence there are $\prod_{i=1}^r n_i$ distinct accepting transcripts overall. 

\begin{lemma}[Forking lemma~\cite{EC:BCCGP16}] 
\label{lem:forking}
Let $(\textsf{Setup}, P, V)$ be an $r$-round public-coin interactive protocol for $\mathcal{R}$. Let $\mathcal{X}$ be a PPT algorithm that given any $(n_1,...,n_r)$-tree of accepting transcripts for the statement $x$, with $n_i \geq 1$ for all $i$, outputs $w$ such that $(x, w) \in \mathcal{R}$ in expected polynomial time. Assuming $\prod_{i=1}^r n_i \leq \poly$, the interactive argument $(\textsf{Setup}, P, V)$ has witness-extended emulation. 
\end{lemma}

\subsection{Commitment Schemes}

In defining the syntax of the various types of commitment schemes, we use the following convention with respect to public values (known to both the prover and the verifier) and secret ones (known only to the prover). In any list of arguments or returned tuple $(a, b, c; d, e)$ those variables listed before the semicolon are public, and those variables listed after it are secret. When there is no secret information, the semicolon is omitted.

\begin{definition}[Commitment scheme]
A commitment scheme $\Gamma$ is a tuple $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open})$ of PPT algorithms where:
\begin{itemize}
    \item $\pro{Setup}(1^\lambda) \rightarrow \params$ generates public parameters $\params$;
    \item $\pro{Commit}(\params; x) \rightarrow (c; r)$ takes a secret message $x$ and outputs a public commitment $c$ and (optionally) a secret opening hint $r$ (which might or might not be the randomness used in the computation).
    \item $\pro{Open}(\params, c, x, r) \rightarrow b \in \{0, 1\}$ verifies the opening of commitment $c$ to the message $x$ provided with the opening hint $r$. 
\end{itemize}

A commitment scheme $\Gamma$ is \defn{binding} if for all PPT adversaries $\adv$:
\[
    \Pr\left[
        b_0 = b_1 \neq 0 \, \wedge \, x_0 \neq x_1 \ : \
        \begin{array}{l}
             \params \gets \pro{Setup}(1^\lambda) \\
             (c, x_0, x_1, r_0, r_1) \gets \adv(\params) \\
             b_0 \gets \pro{Open}(\params, c, x_0, r_0) \\
             b_1 \gets \pro{Open}(\params, c, x_1, r_1) \\
        \end{array}
    \right] \leq \negl \enspace 
\]

%\ben{We don't use the hiding property so why present?} \alan{For the ZK Eval protocol, maybe. Not sure yet.}
\begin{comment}
A commitment scheme $\Gamma$ is \defn{hiding} if for all probabilistic polynomial time adversaries $\adv=(\adv_0,\adv_1)$,
\[
    \left|
        1 - 2\Pr\left[
            \hat{b} = b \ : \
        \begin{array}{l}
             \params \gets \pro{Setup}(1^\lambda) \\
             (\state, x_0, x_1) \gets \adv_0(\params) \\
             b \sample \{0,1\} \\
             (\gr{C}; *) \gets \pro{Commit}(\params; x_b) \\
             \hat{b} \gets \adv_1(\state, \gr{C})
        \end{array}
        \right]
    \right| \leq \negl \enspace .
\]
\end{comment}
\end{definition}

We now extend the syntax to polynomial commitment schemes. The following definition generalizes that of Kate~\emph{et al.}~\cite{AC:KatZavGol10} to allow interactive evaluation proofs. It also stipulates that the polynomial's degree be an argument to the protocol, contrary to Kate~\emph{et al.} where the degree is known and fixed.

\begin{definition} (Polynomial commitment) 
A polynomial commitment scheme is a tuple of protocols $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open}, \pro{Eval})$ where $(\pro{Setup},$ $\pro{Commit}, \pro{Open})$ is a binding commitment scheme for a message space $R[X]$ of polynomials over some ring $R$: 

\begin{itemize}
    \item $\pro{Eval}(\params, c, z, y, d, [\mu]; f(X)) \rightarrow b \in \{0, 1\}$ is an interactive public-coin protocol between a PPT prover $\prover$ and verifier $\verifier$. Both $\prover$ and $\verifier$ have as input a commitment $c$, points $z, y \in R$ for the claimed input/output, and an integer $d$ for the degree. The prover additionally knows the opening of $c$ to a secret polynomial $f(X) \in R[X]$ with $\deg(f(X)) \leq d$. The protocol convinces the verifier that $f(z) = y$. \emph{In a multivariate extension of polynomial commitments, the input $\mu$ indicates the number of variables in the committed polynomial}.
   
\end{itemize}

A polynomial commitment scheme is \defn{correct} if an honest committer can successfully convince the verifier of any evaluation. Specifically, if the prover is honest then for all polynomials $f(X) \in R[X]$ and all points $z \in R$,
\[
    \Pr\left[b = 1 \ : \ \begin{array}{l}
        \params \gets \setup(1^\lambda) \\
        (c; r) \gets \pro{Commit}(\params, f(X)) \\
        y \gets f(z) \\
        d \gets \deg(f(X)) \\
        b \gets \pro{Eval}(\params, c, z, y, d; f(X), r) \\
    \end{array} \right] = 1 \enspace .
\]

A polynomial commitment scheme is \defn{evaluation binding} if no efficient adversary can convince the verifier that the committed polynomial $f(X)$ evaluates to different values $y_0 \neq y_1 \in R$ in the same point $z \in R$. Let $b \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \verifier\rangle}(c, z, y, d, \st)$ denote the verifier's output in an execution of this protocol with adversarial prover $\adv_1$ on public inputs $c, z, y, d$ and private adversary state $\st$. (The adversary may or may not know a witness polynomial $f(X)$). Evaluation binding requires that for all probabilistic polynomial-time adversaries $\adv = (\adv_0, \adv_1)$,
\[
    \Pr\left[
         b_0 = b_1 \neq 0 \, \wedge \, y_0 \neq y_1 \ 
         : \
       \begin{array}{l}
            \params \gets \pro{Setup}(1^\lambda) \\
            (c, z, y_0, y_1, d_0, d_1, \st_0, \st_1) \gets \adv_0(\params) \\
            b_0 \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \verifier} \rangle(\params, c, z, y_0, d_0; \st_0) \\
            b_1 \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \verifier} \rangle(\params, c, z, y_1, d_1; \st_1) \\
        \end{array}
    \right] \leq \negl \enspace .
\]
\end{definition}

The syntax generalizes naturally to multivariate polynomial commitment schemes. Specifically, one obtains the syntax for an $\mu$-variate polynomial commitment scheme by replacing all occurrences of $X$ and $z$ by their $\mu$-dimensional vector counterparts, $\mathbf{X}$ and $\mathbf{z}$.

\paragraph{Knowledge of coefficients} In our application of polynomial commitments to the construction of arguments of knowledge, we also require the polynomial commitment to satisfy a \emph{knowledge} property. Informally, we require that any successful prover in the $\eval$ protocol must \emph{know} a polynomial $f(X)$ such that $f(z) = y$ and $c$ is a commitment to $f(X)$. More formally, since $\eval$ is a public-coin interactive argument we define this knowledge property as a special case of witness-extended emulation (Definition~\ref{def:wee}). 

Define the following NP relation given $\params \leftarrow \pro{Setup}(1^\lambda)$: 

\[ 
\mathcal{R_\textsf{Eval}}(\params) = \left\{
\langle (c, z, y, d), (f(X), r) \rangle
: 
\begin{array}{l} 
f \in R[X] \ \text{and} \ \deg(f(X)) \leq d \ \text{and} \ f(z) = y \\ 
 \text{and} \ \pro{Open}(\params, c, f(X), r) = 1 \\
\end{array}
\right\}
\] 

The correctness definition above implies that if $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open}, \pro{Eval})$ is \emph{correct} then $\eval$ is a correct interactive argument for $\mathcal{R_\textsf{Eval}}(\params)$, with overwhelming probability over the randomness of $\pro{Setup}$. We say that $\Gamma$ has \textbf{witness-extended emulation} if $\eval$ has witness-extended emulation as an interactive argument for $\mathcal{R_\textsf{Eval}}(\params)$. 

It is easy to see that witness-extended emulation implies evaluation binding when $(\pro{Setup}, \pro{Commit}, \pro{Open})$ is a binding commitment scheme. If the adversary succeeds in $\eval$ on both $(c, z, y_0, d_0)$ and $(c, z, y_1, d_1)$ for $y_0 \neq y_1$ or $d_0 \neq d_1$ then the emulator obtains two distinct witnesses $f(X) \neq f'(X)$ and such that $c$ is a valid commitment to both. This would contradict the binding property of the commitment scheme. 

\paragraph{Opening individual coefficients} The coefficients of a committed polynomial can be revealed and checked all at once using $\pro{Open}$, however, in some cases it is useful to reveal an individual coefficient more efficiently (e.g. with sublinear communication). 
There is a generic protocol for this that uses $\pro{Eval}$ as a black-box, and inherits the efficiency properties of $\pro{Eval}$. 
For a polynomial $f \in R[X]$ let $f_i$ denote the $i$th coefficient. The following is an interactive protocol for the statement that $c$ is a commitment to a degree $d$ polynomial $f$ such that $f_i = a$. \alan{todo: rewrite syntax in terms of vector commitments; send generic construction to IOP compilation section; send proof to appendix}

$\pro{OpenIndex}(\params, c, a, i, d; f(X)) \rightarrow b \in \{0,1\}$
\begin{itemize}

\item \emph{Prover}: Split $f(X)$ about the term $X^i$ into a lower part $f_L(X)$ of degree $i -1$ and an upper part $f_R(X)$ of degree $d - i - 1$ such that $f(X) - a X^i = X^{i+1} f_R(X) + f_L(X)$. Compute commitments $c_R \leftarrow \pro{Commit}(\params, f_R(X))$ and $c_L \leftarrow \pro{Commit}(\params, f_L(X))$. Send $c_R$ and $c_L$ to the verifier. 

\item \emph{Verifier}: Sample uniform random  $\beta \leftarrow_R \mathbb{F}_p$ and send $\beta$ to the prover.

\item \emph{Prover}: Evaluate $y_R \leftarrow f_R(\beta)$, $y_L \leftarrow f_L(\beta)$, and $y \leftarrow f(\beta)$. Send $y_R, y_L, y$ to the verifier. 

\item Verifier checks that $y = y_L + \beta^{i+1} y_R - a \beta^i \bmod p$ and returns $0$ (aborts) if not.

\item Prover and verifier run: 
\begin {itemize} 
\item  $\pro{Eval}(\params, c_R, \beta, y_R, d - i -1; f_R(X))$ 
\item $\pro{Eval}(\params, c_L, \beta, y_L, i -1; f_L(X))$ 
\item $\pro{Eval}(\params, c, \beta, y, d; f(X))$
\end{itemize} 
Verifier aborts and outputs $0$ if either subprotocol returns $0$. Otherwise it outputs $1$. 

\end{itemize}

We can show that if $\pro{Eval}$ has witness-extended emulation, then so does $\pro{OpenIndex}$ as an interactive argument for the relation: 

\[ 
\mathcal{R_\textsf{Index}}(\params) = \left\{
\langle (c, a, i, d), (f(X), r) \rangle
: 
\begin{array}{l} 
f \in R[X] \ \text{has degree at most} \ d \ \text{with} \ f_i = a \\ 
 \text{and} \ \pro{Open}(\params, c, f(X), r) = 1 \\
\end{array}
\right\}
\] 


\begin{lemma} 
If $\pro{Eval}$ is an interactive argument for $\mathcal{R_\textsf{Eval}}(\params)$ with witness-extended emulation then $\pro{OpenIndex}$ is an interactive argument for $\mathcal{R_\textsf{Index}}(\params)$ with witness-extended emulation. 
\end{lemma}

\begin{proof}[Proof sketch]
Let $E_{\eval}$ be an emulator for $\pro{Eval}$. We construct an emulator $E$ for $\pro{OpenIndex}$ that makes calls to $E_{\eval}$. At a high level, $E$ will invoke $E_{\eval}$ in order to extract witness polynomials $f_R(X)$, $f_L(X)$, $f(X)$ of appropriate degrees from the respective successful executions of $\pro{Eval}$ and also piece together a consistent emulation transcript. We then argue that if $f(X) - a X^i \neq X^{i+1} f_R(X) + f_L(X)$, then the evaluation binding of the polynomial commitment $\eval$ is broken. $E$ could rewind the protocol to the second step after receiving commitments $c, c_R, c_L$ and rerun on a fresh challenge $\beta' \leftarrow_R \mathbb{F}$, doing this until it gets another accepting transcript (in expected polynomial time) with succesful openings of $f(\beta') = y'$, $f_L(\beta') = y'_L$, and $f_R(\beta') = y'_R$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta^i \bmod p$. Yet, $f(\beta') - a X^i \neq X^{i+1} f_R(\beta') + f_L(\beta')$ except with probability $\poly / |\mathbb{F}|$ (union bound over the $\poly$ rewindings), which implies that one of the claimed evaluations was incorrect. The full proof is in the appendix. 

\ben{TODO move to appendix}

Given adversarial prover $P^*$ and transcript oracle $\pro{Record}(P^*, \params, (c, a, i, d), \st)$, $E$ does the following: 

\begin{itemize} 
\item Run $\pro{Record}$ from the start until the first $\pro{Eval}$. $E$ obtains a transcript containing $c, c_R, c_L, y, y_R, y_L$ and $\beta$. 

\item Invoke $E_{\eval}$ by simulating its transcript oracle $\pro{Record}(P^*, \params, c, \beta, y, d, \st)$. ($E$ simulates this transcript oracle for $E_{\eval}$ by consulting its own transcript oracle, which is running $\eval$ as a subprotocol). $E_{\eval}$ returns an output $(\tr_1, f^*)$, and w.l.o.g. interpret $f^*$ as giving a canonical encoding of an integer polynomial $f^*(X)$. Do the same for the subprotocol $\eval$ executions on $(c_R, \beta, y_R, d - i - 1)$ and $(c_L, \beta, y_L, i-1)$ respectively, which returns $(\tr_2, f_L^*)$ and $(\tr_3, f_R^*)$. 

\item Piece together the transcript obtained from running $\pro{Record}$ in the first step (i.e. up until the first $\eval$ together with the transcripts $\tr_1, \tr_2, \tr_3$ into a complete transcript $\tr^*$. This $\tr$ is an ``accepting transcript" if and only if the verifier in the last step would output $1$. 

\item Output $(\tr^*, f^*)$.  
\end{itemize}

We now argue that for any PPT $\mathcal{A}$ and $\params \leftarrow \pro{Setup}(1^\lambda)$, if the experiment sampling $(X, \st) \leftarrow \mathcal{A}(\params)$ and $\tr \leftarrow \pro{Record}(P^*, \params, x, \st)$, where $x$ is a tuple of the form $(c, a, i, d)$, produces an ``accepting transcript" $\tr$ with probability $\delta$, then the modified experiment that samples $(\tr^*, f^*) \leftarrow E^{\textsf{Record}(P^*, \params, x, \st)}(\params, x)$ returns an $f^*$ such that $((c, a, i, d), f^*) \in \mathcal{R_\textsf{Index}}(\params)$ with probability $\delta - \negl$. 

If $\delta$ is negligible the claim holds trivially. For now on assume that $\delta$ is non-negligible. 
The fact that $\tr$ is an accepting transcript with probability $\delta$ implies that each $\eval$ subprotocol generates accepting transcripts with probability at least $\delta$. Therefore, by the hypothesis that $\eval$ has witness-extended emulation, if each of the subprotocol transcripts $\tr_1$, $\tr_2$, $\tr_3$ are accepting then with probability $\delta - \negl$: subprotocol witnesses $f^*, f_L^*$ and $f_R^*$ are all valid $\mathcal{R_\textsf{Eval}}(\params)$ witnesses for $(c, \beta, y, d)$, $(c_L, \beta, y_L, i-1)$, and $(c_R, \beta, y_R, d - i - 1)$ respectively. 

We have already shown that the extracted polynomial $f^*(X)$ is valid for $c$ with probability $\delta - \negl$. As a final step, suppose towards contradiction that $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$. Since $\delta$ is non-negligible, $E$ can rewind the transcript oracle to Step 2 (i.e. after receiving the commitments $c, c_L, c_R$), restarting the protocol from this point on a fresh verifier challenge $\beta' \leftarrow_R \mathbb{F}$. It does this until (in expected polynomial time) it finds a $\beta'$ that produces an accepting transcript, which includes $y', y_L', y_R'$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta'^i \bmod p$.

The probability that $f_L^*(\beta') + \beta'^i f_R^*(\beta') = f^*(\beta') - a \beta'^i$ is less than $\poly / |\mathbb{F}|$ (the $\poly$ numerator comes from union bound over number of rewindings). In this case, either $y' \neq f^*(\beta')$ or $y_L' \neq f^*_L(\beta')$ or $y_R' \neq f^*_R(\beta')$. Yet, $\eval$ passes on all three, which contradicts the evaluation binding property of $\eval$. Hence, we conclude that except with $\negl$ probability $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$, and thus $f^*_i = a$. 

\end{proof}

%First  Extractor obtains $f_R(X)$, $f_L(X)$, $f(X)$ of appropriate degrees from the respective succesful executions of $\pro{Eval}$. Follows that $c_R$ is commitment 

 
\begin{comment}
\paragraph{Inner product argument} Another helpful feature for polynomial commitment schemes is an inner product argument that shows for commitments $(c_1, c_2)$ to degree $d$ polynomials $(f_1, f_2)$ the inner product of their coefficient vectors $a = \langle f_1, f_2 \rangle$. More formally, this is an interactive argument for the relation: 

\[ 
\mathcal{R_\textsf{Prod}}(\params) = \left\{
\langle (c_1, c_2, a, d), (f_1, f_2, r_1, r_2) \rangle
: 
\begin{array}{l} 
f_1, f_2 \in R[X] \ \text{is degree} \ d \ \\
\langle f_1, f_2 \rangle = a \\ 
 \text{and} \ \pro{Open}(\params, c_1, f_1, r_1) = 1 \\
 \text{and} \ \pro{Open}(\params, c_2, f_2, r_2) = 1
\end{array}
\right\}
\] 

Unlike the opening of individual coefficients, we do not know a generic protocol for the inner product argument based solely on $\eval$. However, we do construct a simple inner-product argument in Section~\ref{section:inner_product} for our particular construction of polynomial commitments in generic groups of unknown order.  
\end{comment}

%that evaluates to $y$ in $z$. This is already implied if the verifier can choose $z$, since opening the polynomial in $\deg(f(X))+1$ points determines it completely. However, we want an even stronger soundness notion, one that applies even when $z$ is not chosen by the verifier. This motivates the following definition of extractability.

%%OLD 
\if 0 
\begin{comment}
We additionally require a stronger extraction property that had in different variations been defined by Zhang~\emph{et al.}~\cite{SP:ZGKPP17} and Sonic~\cite{EPRINT:MBKM19}.
\begin{definition}[PolyCommit extraction]
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocol $\eval$, is extractable if there exists a rewinding \benedikt{Define more properly}extractor $\extractor$ such that for all polynomial degrees $d=\poly\in \NN$ and for any efficient adversary $\adv$:
	\[        
                \Pr\left[\begin{array}{c}\eval_{\adv,\verifier}(\crs,C,z,y)=\text{"accept"}\\
                \wedge\\
                f(X)\gets\extractor^{<\eval_{\adv,\verifier}(\crs,C,z,y)>}(\crs,C)\in \FF_p[X]\\
                \wedge\\
               \commit(f(X))\neq C\vee f(z)\neq y \vee \deg(f)\neq d
                 \end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      \tau \sample (0,1)^\lambda\\
                      (C,z,y)\sample \adv_1(\crs,\tau)]
                      
                \end{array} 
        \right] \leq \negl.
\]
\end{definition}
\end{comment}

\begin{definition}[extractability]
Let let $\Gamma$ be a polynomial commitment scheme, let $\adv = (\adv_0, \adv_1)$ be any probabilistic polynomial-time adversary attacking the scheme where in particular $\adv_0$ decides on a statement and $\adv_1$ tries to convince the verifier of it, and let $\extractor$ be a probabilistic polynomial-time black-box extractor algorithm that satisfies the following description.
\begin{itemize}
    \itemsep0em 
    \item $\extractor$ interacts with $\adv_1$ in accordance with the $\eval$ protocol syntax, where $\extractor$ assumes the role of the verifier and $\adv_1$ the role of the prover.
    \item $\extractor$ can rewind $\adv_1$ to any previous point in time, at which point the protocol will resume from that point onward. $\ext$ remembers the observed messages from previous execution branches.
    \item We write $f(X) \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \extractor\rangle}(c,z,y,d;\st)$ to denote an execution of this extraction procedure whereby $\extractor$ finally outputs $f(X)$.
\end{itemize}
We say the polynomial commitment scheme $\Gamma$ is \defn{extractable} if there is an extractor $\extractor$ for all adversaries $\adv = (\adv_0, \adv_1)$ that convince the honest verifier with noticeable probability\alan{Actually, I am not convinced that with this order of quantifiers, the text definition is equivalent as the formula definition.}, $\extractor$ outputs a polynomial $f(X) \in R[X]$ of degree at most $d$ that matches the commitment with overwhelming probability. Specifically, this means that
\[
    \Pr \left[
        b \neq 0 \, \wedge \, c' \neq c \ : \ 
        \begin{array}{l}
             \params \gets \pro{Setup}(1^\lambda) \\
             (c, z, y, d; \state) \gets \adv_0(\params) \\
             b \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \verifier\rangle}(c, z, y, d; \state) \\
             f(X) \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \extractor\rangle}(c, z, y, d; \state) \\
             (c'; *) \gets \pro{Commit}(\params; f(X))
        \end{array}
    \right] \leq \negl \enspace .
\]
\end{definition}

\alaninline{Todo: handwave why extractability as defined here implies witness-extended emulation.} 

\begin{lemma}[binding $\wedge$ extractability $\Rightarrow$ evaluation binding]
	A binding polynomial commitment scheme that satisfies extractability also satisfies evaluation binding.
\end{lemma}
\begin{proof}
Proof by contradiction. We assume that there exists an adversary $\adv_{\rm eval} = (\adv_{{\rm eval},0}, \adv_{{\rm eval},1})$ capable of breaking the evaluation-binding property with non-negligible probability. With this algorithm we construct another algorithm that breaks the binding or the extractability properties. The description of this constructed adversary follows.

Run $\adv_{{\rm eval}, 0}(\params)$ to obtain $(c, z, y_0, y_1, d_0, d_1, s_0, s_1)$. Then run the extractor to obtain the polynomials $f_0(X) \gets \eval_{\langle \adv_{{\rm eval}, 1} \leftrightarrow \extractor \rangle}(c, z, y_0, d_0; s_0)$ and $f_1(X) \gets \eval_{\langle \adv_{{\rm eval}, 1} \leftrightarrow \extractor \rangle}(c, z, y_1, d_1; s_1)$. The algorithm's final step depends on the property under consideration.

Let $(c_0; *) \gets \pro{Commit}(\params, f_0(X))$ and $(c_1; *) \gets \pro{Commit}(\params, f_1(X))$. Since $y_0 \neq y_1 \Rightarrow f_0(X) \neq f_1(X)$, the probability $\Pr[c_0 = c_1]$ is negligible due to the binding property. Specifically, the final step here consists of outputting $(c, f_0(X), f_1(X), f_0(X), f_1(X))$ and this would break the binding property.

The probability $\Pr[c_0 \neq c \, \vee \, c_1 \neq c]$ is also negligible, because either clause breaks the extractability property. Specifically, the final step would consist of outputting either $(c,z,y_0, \deg(f_0(X), \state)$ where $\state = f_0(X)$ or $(c, z, y_1, \deg(f_1(X)), \state)$ where $\state = f_1(X)$; the second half of the extractability adversary is identical to that of the evaluation binding adversary, in which case the extractor proceeds to extract $f_0(X)$ or $f_1(X)$, respectively.

The remaining option is that $\Pr[b \neq \bot]$ is non-negligible, but this would imply, contrary to our assumption, that the adversary $\adv_{\rm eval} = (\adv_{{\rm eval},0}, \adv_{{\rm eval},1})$ is not capable of breaking the evaluation binding property.
\end{proof}

\fi 

\paragraph{Inner Products.} Another helpful tool for vector commitments is the ability not to extract any single coefficient but a linear combination of all of them. We omit for the sake of simplicity the case where the multiplicand is not committed to, but instead either known to both prover and verifier or just to the prover. This syntax omits the secret decommitment information associated with every commitment.
\begin{itemize}
    \item $\pro{InnerProduct}(c_\mathbf{f}, c_\mathbf{g}, a; \mathbf{f}, \mathbf{g}) \rightarrow b \in \{0,1\}$ takes two commitments $c_\mathbf{f}$ and $c_\mathbf{g}$ to vectors $\mathbf{f}, \mathbf{g} \in R^n$ and a ring element $a \in R$, and outputs 1 if $a = \langle \mathbf{f}, \mathbf{g} \rangle$ and 0 otherwise.
\end{itemize}
The relation proved by $\pro{InnerProduct}$ is given below. The decommitment information is explicit here.
\[ 
\mathcal{R_\textsf{IP}}(\params) = \left\{
\langle (c_\mathbf{f}, c_\mathbf{g}, a), (\mathbf{f}, \mathbf{g}, r_\mathbf{f}, r_\mathbf{g}) \rangle
: 
\begin{array}{l} 
\mathbf{f}, \mathbf{g} \in R^n \ \\
\langle \mathbf{f}, \mathbf{g} \rangle = a \\ 
 \text{and} \ \pro{Open}(\params, c_\mathbf{f}, \mathbf{f}, r_\mathbf{f}) = 1 \\
 \text{and} \ \pro{Open}(\params, c_\mathbf{g}, \mathbf{g}, r_\mathbf{g}) = 1 
\end{array}
\right\}
\]

%Unlike the opening of individual coefficients, we do not know a generic protocol for the inner product argument based solely on $\eval$. However, we do construct a simple inner-product argument in Section~\ref{section:inner_product} for our particular construction of polynomial commitments in generic groups of unknown order.

\subsection{Proofs of Exponentiation}
Wesolowski \cite{EC:Wesolowski19} introduced a simple yet powerful proof of correct exponentiation (``PoE'') in groups of unknown order. A prover can efficiently convince a verifier that a large exponentiation in such a group was done correctly. For instance, the prover wishes to convince the verifier that $\gr{w} = \gr{u}^x$ for known group elements $\gr{u}, \gr{w} \in \mathbb{G}$ and exponent $x \in \mathbb{Z}$, and the verifier wants to verify this with much less work than performing the exponentiation. To do this, the verifier samples a large enough prime $\ell$ at random and the prover provides him with $\gr{Q} \gets \gr{u}^q$ where $q = \lfloor \frac{x}{\ell} \rfloor$. The verifier then simply computes the remainder $r \gets (x \mod \ell)$ and checks that $\gr{Q}^\ell\gr{u}^r = \gr{w}$. The protocol is an argument for the relation $\mathcal{R}_\mathsf{PoE} = \left\{ \langle(\gr{u}, \gr{w}, x), \varnothing\rangle \ : \ \gr{u}^x = \gr{w} \right\}$.

%Boneh~\emph{et al.}~\cite{C:BonBunFis19} add zero-knowledge to this protocol. Specifically, this extension enables the prover to prove that he knows an $x$ such that $\gr{w} = \gr{u}^x$ even while keeping $x$ secret. In the language of arguments and relations, it is an argument of knowledge for the relation $\mathcal{R}_\mathsf{PoKE} = \left\{ \langle(\gr{u}, \gr{w}), x\rangle \ : \ \gr{u}^x = \gr{w} \right\}$. We cover only the more efficient variant, PoKE2. While PoE has a security reduction to the adaptive root assumption, PoKE2 is only provably secure in the generic group model.
\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{PoE}(\gr{u}, \gr{w}, x):$
	\begin{enumerate}[nolistsep]
		    \item \verifier samples $\ell \xleftarrow{\$} \primes$ and sends $\ell$ to \prover
		    \item \prover computes quotient $q$ and remainder $r$ such that $x = q\ell + r$ and $r \in \{0, \ldots, \ell-1\}$
		    \item \prover computes $\gr{Q} \gets \gr{u}^q$ and sends it to \verifier
		    \item \verifier computes $r \gets (x \mod \ell)$ and checks that $\gr{Q}^\ell\gr{u}^r = \gr{w}$
		    \item \pcif{}check passes \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}
Wesolowski showed that an adversary that succeeds in the $\textsf{PoE}$ protocol for statements not in $\mathcal{R}_{\textsf{PoE}}$ can compute adaptive roots in the group of unknown order $\GG$.

\begin{lemma}[\textsf{PoE} soundness\cite{EC:Wesolowski19}]
\label{lem:poe}
\textsf{PoE} is an argument system for  Relation $\mathcal{R}_\textsf{PoE}$ with negligible soundness error,
assuming the adaptive root assumption (Assumption \ref{assum:adaptiveroot}) holds for~$\ggen$.
\end{lemma}


\section{Protocols for Groups of Unknown Order}
\label{sec:protocol}

\subsection{Polynomial Encoding}
At the heart of our protocol is an integer encoding of polynomials with bounded coefficients. The encoding can be viewed as the integer concatenation\alan{I'm not sure what `integer concatenation' means. I can concatenate strings and lists, but not integers except by interpreting them as lists of one integer each.} of the coefficients. This encoding has useful homomorphic properties which we can take advantage of. Additionally, we can represent polynomials in prime fields as integer polynomials with bounded coefficients.

Consider the set $B_{q}:=\{x | x \in \ZZ \wedge \vert x\vert  <q/2\} \subset \ZZ$ of integers with absolute value less than $q/2$. In a slight abuse of notation we write $B_{q}[X]\subset \mathbb{Z}[X]$ as the set of integer polynomials with bounded coefficients. The map $\mathsf{Enc} : \mathbb{Z}[X] \rightarrow \mathbb{Z}, \, p(X) \mapsto p(q)$ is a unique encoding of polynomial with bounded coefficients. Specifically, this map is injective for the domain $B_{q}[X]$, and it maps to the alphabet $\mathbb{Z}$. A decoding algorithm is presented below.
	
\begin{mdframed}
\begin{flushleft}
	%\item Domain $B_{q}[X]\subset \ZZ[X]$, Alphabet: $\ZZ$
	%\item 	$f(X):=\sum_{i=0}^{d} f_i X^i$
	%\item $\enc(f(X) \in B_{q}[X])\rightarrow  f(q) \in \ZZ$
	$\pro{Dec}(y \in \mathbb{Z}):$
	\begin{enumerate}[nolistsep]
	    \item For each $i \in [0,\lfloor \log_q(|y|)\rfloor]$ do\\
		\item \pcind[1] Define $f_{\leq k}(X):=\sum_{j=0}^k f_j X^j$
		\item \pcind[1] $y \bmod q^{i+1}=\begin{cases} f_{\leq i}(q) &\text{ if } f_{\leq i}(q)\geq 0\\ q^{i+1} - f_{\leq i}(q) &\text{ if } f_{\leq i}(q)<0   \end{cases}$
		\item \pcind[1]  Compute $f_{\leq i}(q)\gets \begin{cases}y \bmod q^{i+1} & \text{ if }y \bmod q^{i+1}<q^{i+1}/2\\
	y-q^{i+1} \bmod q^{i+1} & \text{ if }y \bmod q^{i+1}>q^{i+1}/2 \end{cases}$ 
		\item \pcind[1] Compute $f_{\leq i-1}(q)$ from $y$
		\item \pcind[1] Compute $f_i\in B_{q}$ as $f_i \gets \frac{f_{\leq i}(q)-f_{\leq i-1}(q)}{q^i}$.
	\end{enumerate} 
\end{flushleft}
\end{mdframed}

\begin{fact}
	The encoding scheme is uniquely decodable for polynomials in $B_{q}[X]$.
\end{fact}
The fact follows from $f(q)\in \ZZ$ being a unique integer representation of polynomials with coefficients bounded in absolute value by $q/2$. In particular for the degree $i$ polynomial $f_{\leq i}$ we have $|f_{\leq i}(q)|<\frac{q^{i+1}}{2}$. From this follows that $f_{\leq i}(q)-f_{\leq i-1}(q)=f_i \cdot q^i$.  

Note that the encoding has limited homomorphic properties. $\enc(g(X))+\enc(h(X))=\enc(g(X)+h(X))$ if $g(X)+h(X)\in B_{q}$, \emph{i.e.}, all its coefficients are less than $q/2$ in absolute value. This is ensured if for example the coefficients of $g$ and $h$ are less than $q/4$ in magnitude. Additionally $\enc(g(X))\cdot \enc(h(X))=\enc(g(X)\cdot h(X))$ if $g(X)\cdot h(X)\in B_{q}$.

\paragraph{Encoding of dyadic rational polynomials.}
In class groups there exists an algorithm to compute square roots of any element originally described by GauÃ (modern description by Bosma and Stevenhagen~\cite{bosma1996computation}). As a result, in class groups an adversary can also commit to numbers in the ring of \defn{dyadic rationals} $\mathbb{D}:=\{\frac{x}{2^k} |x \in \ZZ \wedge k \in \NN\}$. When using class groups we therefore need to extend the encoding scheme accordingly. 

The encoding map is identical, except lifted to the dyadic rationals: $\mathsf{Enc} : \mathcal{D}[X] \rightarrow \mathcal{D}, \, g(X) \mapsto g(q)$. The main difference with respect to the integer encoding scheme will be that decoding works for dyadic rationals where \emph{both the numerator and the denominator are bounded}. Let $b_n \in \NN$ be a bound on the absolute value of the numerator and $2^{b_d}\in \NN$ be a bound on the value of the denominator, and let $C_{b_d}^{b_n}:=\{(x,a) \in \mathbb{D} \, | \, |x|\leq b_n \wedge 2^a\leq 2^{b_d}\}$ denote the set of such bounded dyadic rationals. The encoding scheme is uniquely decodable if $b_n\cdot 2^{b_d}<q/2$.
 
To encode a polynomial $g(X)$ with coefficients in $C_{b_d}^{b_n}$ we compute $y \gets g(q)\in \mathbb{D}$. Note that $y$'s denominator is bounded by $2^{b_d}$. To decode such a dyadic rational $y\in \mathbb{D}$ we compute the integer $y'\gets y\cdot 2^{b_d}\in \ZZ$  and use the decoding algorithm described above to decode a polynomial $f(X)$ in $B_{q}[X]$. From $f(X)$ we can derive the polynomial  $g(X)\gets \frac{f(X)}{2^{(b_d)}} \in C^{\frac{q}{2^{(b_d)}},}_{b_d}[X]$ through division. If the integer polynomial encoding is uniquely decodable then so is the scheme for dyadic rational polynomials.
We also set $q$ to be odd such that $q$ is co-prime with $2$. If $q$ were a power of $2$ an adversary could encode Laurant polynomials with negative powers.

\subsection{Polynomial Commitment}

We now present our main result: 
A polynomial commitment scheme with an efficient evaluation protocol based on a group of unknown order $\GG$. For polynomials of degree $d=\poly$ the protocol uses $\log_2(d+1)$ rounds and $O(\log(d))$ communication and verifier work.

Exponentiation in groups of unknown order is a succinct and homomorphic cryptographic commitments to integers.
Using the integer encoding of polynomials presented above we can simply commit to an integer polynomial with bounded coefficients $f(X)\in B_{q}[X]$ by computing $\gr{g}^{f(q)} \in \GG$. Note that our commitment scheme supports integer polynomials with bounded coefficient. Every polynomial in $\ZZ_p[X]$ naturally maps to an integer polynomial with coefficients in $B_{2\cdot p}$. The commitment scheme, therefore, supports committing to polynomials in $\ZZ_p[X]$ for $p<q/2$. Interestingly, neither $p$ nor the degree $d$ need to be specified in the setup. As long as $q$ and ``big enough'' they can be freely chosen. In class groups there exists an efficient algorithm to compute square roots. The adversary can therefore also commit to dyadic rationals. Since every dyadic rational corresponds to a unique element in $\ZZ_p$ we can simply extend the encoding to work for polynomials with bounded dyadic rational coefficients. The only difference is that we require $q$ to be odd such that the prover cannot commit to polynomials with negative powers. We will discuss the relationship between $p$, $d$ and $q$ in more detail later but first we describe the setup, commitment and opening algorithms:


\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{Setup}(1^\secpar):$
		\begin{enumerate}[nolistsep]
			\item $ \GG \sample \ggen(\secpar)$
			\item $ \gr{g} \sample \GG$
			%\item $q \gets 2^k$ such that $q > (d+1) \cdot 2\cdot p^{\log_2(d+1)+1} $
			\item Pick a prime $p\in \NN$ such that $\lceil\log_2(p)\rceil=\lambda$.
			\item Pick a sufficiently large and odd $q\in \NN$ (See discussion above)
			\item $\pcreturn \params = (\secpar,\GG,\gr{g},p,q)$
		\end{enumerate}
	$\pro{Commit}(\crs;f(X) \in B_{2\cdot p}[X]):$ \pccomment{$f(X)\equiv \bar{f}(X) \mod p$ for  $\bar{f}(X)\in \ZZ_p[X]$}
		\begin{enumerate}[nolistsep]
			\item $\gr{C} \gets \gr{g}^{f(q)}$
			\item $\pcreturn (\gr{C};f(X))$
		\end{enumerate}
	$\pro{Open}(\crs,\gr{C},\bar{f}(X);f(X)):$ \pccomment{$f(X) \in B_{q}[X]\subset\mathbb{Z}[X]$ but $\bar{f}(X) \in \ZZ_p[X]$}
		\begin{enumerate}[nolistsep]
		    \item \prover sends $f(X)$ to \verifier.
		    				\item \verifier computes $\bar{f}(X) \gets f(X) \mod p$
		    \item \verifier checks that $f(X)\in B_{q}[X]$
			\item \verifier checks that $\gr{g}^{f(q)} = \gr{C}$ \pccomment{Can be outsourced using $\textsf{PoE}(\gr{g},\gr{C},f(q))$}
			\item \pcif all checks pass \textbf{then} \pcreturn $1$ \textbf{else} \pcreturn $0$
		\end{enumerate}
		\end{flushleft}
\end{minipage}
\end{mdframed}
%Opening the commitment can be simply done by rerunning the commitment algorithm. Additionally a proof of exponentiation (PoE) can be used to increase verifier efficiency.
The commitment inherits the homomorphic properties of the integer encoding. Assume that we are committing to representations of polynomials in $\ZZ_p[X]$, \emph{i.e.}, polynomials with coefficients bounded by $p$. Then the commitment scheme supports up to $\frac{q}{2 \cdot p}$ homomorphic additions. We use this support to build an efficient $\eval$ protocol. 

The core idea of the $\eval$ protocol is to reduce the statement from a statement about a polynomial $f(X)$ of degree $d$ to one about a polynomial of degree $d'=\frac{d+1}{2}-1$. For simplicity assume that $d+1$ is a power of $2$.
The prover splits $f(X)$ into $f_L(X)$ and $f_R(X)$ such that $f_L(X)+X^{d'+1} f_R(X)$ and such that both polynomials have degree at most $d'$. Then he proves that $f'(X)=\alpha \cdot f_L(X) + f_R(X)$ has degree $d'$ for a random challenge $\alpha\in [0,p-1]$. 

If the prover wants to show, in addition to the previous, that $f(z)=y\bmod p$, then he can simply provide $y_L=f_L(z)\bmod p$ and $y_R=f_R(z)\bmod p$ and show that $y_L + z^{d'+1} \cdot y_R \bmod p=y$. Note that the verifier can compute $y' = f'(z) = \alpha \cdot y_L + y_R \bmod p$ from $y_L$ and $y_R$.

The proof recursively repeats this reduction by using $f'(X),z,y'$ and $d'$ as the input. In the final step, the prover simply sends the constant polynomial $f_0$ and the verifier can check that $f_0 \equiv y \bmod p$. Note that $f_0< p^{\log_2(d+1)}$ so an integer encoding of $f_0$ requires at most $\lceil \log_2(d+1) \cdot \log_2(p)\rceil$ bits.

Using the integer encoding (with a sufficiently large $q>p^{\log_2(d+1)}$) and exponentiation in groups of unknown order as the cryptographic compilers, we can derive an efficient $\eval$ protocol with logarithmic communication. To achieve verifier efficiency we need to build an efficient check that $f(X) = f_L(X) + X^{d'+1} f_R(X)$ given committed $f(X), f_L(X)$ and $f_R(X)$. Concretely, the verifier checks that $\gr{C} = \gr{C}_L \gr{C}_R^{q^{d'+1}}$ for $\gr{C}=\gr{g}^{f(q)}$, $\gr{C}_L=\gr{g}^{f_L(q)}$ and $\gr{C}_R=\gr{g}^{f_R(q)}$.

The issue here is the derivation of $\gr{C}_R^{q^{d'+1}}$ from $\gr{C}_R$, because $q^{d'+1}$ is large and the verifier should not be burdened with the expense task of computing this exponentiation naÃ¯vely. Fortunately, Wesolowski~\cite{EC:Wesolowski19} and Pietrzak~\cite{EPRINT:Pietrzak18b} provide efficient proofs of exponentiations (\textsf{PoE}) to solve a similar problem in the context of verifiable delay functions~\cite{C:BBBF18}. Specifically, the prover provides the verifier with both the input and the output of the exponentiation, and after some interaction the verifier only needs to perform exponentiations with much smaller exponents to verify their correctness. Wesolowski's \textsf{PoE} has constant communication and verification time and is thus particularly well suited here.

We now present the full $\eval$ protocol below. $\eval$ uses as a subroutine \pro{EvalBounded} which additionally allows the specification of a bound on the size of the coefficients (other than $p$).  This can be particularly useful if commitments were homomorphically combined prior to the execution of $\pro{EvalBounded}$. Recall that any homomorphic operation increases the bound on the size of the coefficients.

%This intuitive description omits special care afforded to the case where the degree of the polynomial is not one less than a power of two. To take care of this, the left polynomial is guaranteed to have odd degree (unless in the last step when it is zero), and the right half polynomial $f_R(X)$ is shifted to the right by one digit whenever its degree is even. The evaluation $y_R$ and commitment $\gr{C}_R$ are adapted accordingly.


\begin{mdframed}
\begin{minipage}{\textwidth}
			$\pro{Eval}(\crs, \gr{C}\in \GG, z\in \ZZ_p, y\in \ZZ_p, d \in \NN; f(X)) :$ \pccomment{$f(X) = \sum_{i=0}^d f_i X^i \in \ZZ_p[X]$}
			\begin{enumerate}[nolistsep]
			\item \prover and \verifier run $\pro{EvalBounded}(\params,\gr{C},z,y,d,p-1;f(X))$
		    \end{enumerate}
		$\pro{EvalBounded}(\crs,\gr{C}\in \GG,z\in \ZZ_p,y\in \ZZ_p,d\in \NN,b\in \ZZ;f(X)\in B_{b}[X])$
	    \begin{enumerate}[nolistsep]
        \item \pcif $d=0$:
        \item \pcind[1] \prover sends $f(X)\in \ZZ$ to the verifier. \pccomment{$f=f(X)$ is a constant}
        \item \pcind[1] \verifier checks that $b< \mu_{p,d}$\pccomment{$\mu_{p,d}=O(p^{\log(d)})$ is a constant}
        %q/(2^{\lceil \log_2(d+1) \rceil+1} p^{2 \lceil \log_2(d+1) \rceil+1})$
        \item \pcind[1] \verifier checks that $f \in [0,b]$
          \item \pcind[1] \verifier checks that $f\equiv y \bmod p$
                \item \pcind[1] \verifier checks that $\gr{g}^{f}=\gr{C}$
\item \pcind[1] \verifier outputs $1$ \pcif all checks pass, $0$ otherwise.
          \item \pcif{$d+1$ is odd}
         \item \pcind[1]  $d'\gets d+1, \gr{C}'\gets \gr{C}^q$, $y'\gets y\cdot z \bmod p$ and $f'(X)\gets X \cdot f(X)$.
         \item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\crs,\gr{C}',z,y',d',bd;f'(X))$

        \item \pcelse: \pccomment{$d \geq 1$ and $d+1$ is even}
       
        \item \pcind[1] \prover and \verifier compute $d' \gets \frac{d+1}{2} - 1$
        \item \pcind[1] \prover computes $f_L(X) \gets \sum\limits_{i=0}^{d'} f_i \cdot X^i$ and $f_R(X)\gets\sum\limits_{i=0}^{d'} f_{d'+1+i}\cdot X^{i}$
        \item \pcind[1] \prover computes $y_L\gets f_L(z) \bmod p$ and $y_R\gets f_R(z)\bmod p$
        \item \pcind[1] \prover computes $\gr{C}_L \gets \gr{g}^{f_L(q)}$ and $\gr{C}_R \gets \gr{g}^{f_R(q)}$
        \item \pcind[1] \prover sends $y_L,y_R, \gr{C}_L, \gr{C}_R$ to \verifier. \pccomment{See Section \ref{sec:optimiztion} for an optimization}
        \item \pcind[1] \verifier checks that $y=y_L+z^{d'+1}\cdot y_R \bmod p$, outputs $0$ if check fails.
        \item \pcind[1] \label{line:PoE} \prover and \verifier run $\pro{PoE}(\gr{C}_R, \gr{C}/\gr{C}_L, q^{d'+1})$\pccomment{Showing that $\gr{C}_L\gr{C}_R^{(q^{d'+1})}=\gr{C}$}
        \item \pcind[1] \verifier samples $\alpha \sample [1,p-1]$ and sends it to \prover
        \item \pcind[1] \prover and \verifier compute $y'\gets\alpha \cdot y_L +y_R \bmod p$, $\gr{C}' \gets \gr{C}_L^\alpha  \gr{C}_R$ and $b'\gets b\cdot p$. 
        \item \pcind[1] \prover computes $f'(X) \gets \alpha \cdot f_L(X) + f_R(X) \in \ZZ[X]$ \pccomment{$\deg(f'(X))=d'$}
        \item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}', z, y', d',b' ; f'(X))$
               \end{enumerate}
      \end{minipage}
\end{mdframed}

\begin{lemma}
	The polynomial commitment scheme is correct for polynomials in $\ZZ_p$ of degree at most $d$ if $\mu_{p,d}\geq  p^{\lceil \log_2(d+1)\rceil+1}$.
\end{lemma}
\begin{proof}
    Consider the following constraints for a tuple $(\params, \gr{C}, z, y, d, b; f(X))$: a) $\deg(f(X)) \leq d$; b) $\pro{Open}(\params, \gr{C}, f(X) \bmod p, f(X)) = 1$; c) $\forall i \in [0;\deg(f(X))]$, $0 \leq f_i < b$; d) $f(z) = y$. The honest prover activates $\pro{EvalBounded}$ with a tuple where the constraints are satisfied. In recursion steps where $d+1$ is odd, the honest prover activates a recursion step on a new tuple that also satisfies the constraints because of how the variables were computed. In non-terminal recursion steps where $d+1$ is even, the verifier's check that $y = y_L + z^{d'+1} \cdot y_R$ succeeds due to the way the new variables were computed. The verifier's checks occurring in the $\mathsf{PoE}$ succeed due to how $d', \gr{C}_L$ and $\gr{C}_R$ were computed and due to the correctness of $\mathsf{PoE}$. So in these recursion steps, the honest prover will reach the final line which activates the next recursion step with input $(\params, \gr{C}', z, y', d', b'; f'(X))$. Due to the way the new variables were computed, the same constraints hold for this tuple. In every recursion step, $d$ is either increased by one when it is even, or it is decreased by more than 1. Since $d$ starts as a positive integer, the terminal recursion step $d=0$ must eventually be reached.

	What remains to be shown is that in the terminal recursion step, all the verifier's checks pass. The verifier's checks in lines 4---6 follow immediately from the constraints' satisfaction. The check in line 3 passes because in each round the bound on the coefficient size grows by a factor of $p$. For example: If $f'_0=\alpha f_0 + f_1$ for $\alpha \in [0,p-1]$ and $f_0,f_1 \in [0,b]$ then $f'_0\in [0,p\cdot b]$. The recursion has $\lceil \log_2(d+1)\rceil$ rounds which gives us a bound on $b$ of $p^{\lceil \log_2(d+1)\rceil+1}$. 
	
	Since all the verifier's checks pass, the verifier outputs 1.
\end{proof} 
 
\begin{lemma}
	The polynomial commitment scheme is binding if either the order assumption or the strong RSA assumption hold.
\end{lemma}
\begin{proof}
    Assume that there is an adversary that breaks the binding property of the scheme. Specifically, assume that some probabilistic polynomial time algorithm $\adv$ takes as input $\params$ and outputs $\gr{C} \in \GG, f(X) \in B_{q}[X], f'(X)\in B_{q}[X]$ such that with non-negligble probability $\pro{Open}(\params, \gr{C}, \bar{f}(X), f(X)) = \pro{Open}(\params, \gr{C}, \bar{f'}(X), f'(X)) = 1$ and $\bar{f}(X) \neq \bar{f'}(X)$. We proceed to show that this implies a violation of the order assumption~(Assumption \ref{assum:order}) and the strong RSA assumption~(Assumption \ref{assum:strongRSA}). The assumptions are incomparable so we show that either suffices to achieve the binding property of the commitment scheme.
    
	From $\bar{f}(X) \neq \bar{f'}(X)$ it follows that ${f}(X) \neq {f'}(X)$. Let $h(X)=f(X)-f'(X) \in \ZZ[X]$; this is a polynomial of degree at most $\max(f(X), f'(X))$. Since $\gr{g}^{f(q)}=\gr{g}^{f'(q)}=\gr{C}$ we have that $\gr{g}^{h(q)}=1$. Note that the coefficients of $f(X)$ and $f'(X)$ are all less than $q/2$ in absolute value. By triangle inequality we have that the coefficients of $h(X)$ are less than $q$.\alan{Less than $q$ in absolute value. But then unique decoding isn't guaranteed anymore.} This means that $h(q)=0 \implies h(X)=0$. However by assumption $h(X)\neq 0$ so $h(q)\neq 0$ is a multiple of the order of $\gr{g}$. This directly breaks the order assumption and we can also create an adversary $\adv_{RSA}$ that breaks the strong RSA assumption. To do so the $\adv_{RSA}$ picks an odd prime $\ell$ that is co-prime with $h(q)$ and computes $\gr{u}\gets \gr{g}^{\ell^{-1} \bmod h(q)}$ as the $\ell$th root of $\gr{g}$.
\end{proof}
	
\paragraph{Proof idea}
We now prove the main security theorem, which states that the polynomial commitment scheme is extractable. Consider the information theoretic version of the eval protocol, where the prover sends the integer polynomials $f_L(X)$ and $f_R(X)$ in each round but the verifier does not read them.
In the final round the verifier receives $f$ such that $f \in [0,b]$. The goal is to construct an extractor by recursively computing $f_L(X)$ and $f_R(X)$ from $f'(X)$.

In each round the extractor has $f'(X)=\alpha f_L(X)+ f_R(X)$. Using rewinding the extractor can also compute $f''(X)=\alpha' f_L(X)+ f_R(X)$. From $f'(X)$, $f''(X)$, $\alpha$ and $\alpha'$ it is easy to compute $f_L(X)$ and $f_R(X)$. The extractor then computes $f(X)=f_L(X)+x^{d'+1} f_R(X)$.

A careful analysis shows that if the coefficients of $f'(X)$ are bounded by $b$ then $f_L(X)$ and $f_R(X)$ must have coefficients bounded by $b \cdot p$ in absolute value. Using a similar analysis we can show that $f(z)\bmod p=y$ for the extracted polynomial $f(X)$.

Our full proof takes into account the cryptographic compilation of the protocol using the integer encoding and the commitment scheme based on groups of unknown order. Additionally the full proof will need to work with dyadic rationals because taking square roots is easy in class groups.

\paragraph{$\textsf{PoE}$ security}
We first begin by showing that we can safely replace all of the $\textsf{PoE}$ evaluations with direct verification checks. Concretely the $\eval$ protocol, under the adaptive root assumption, is as secure as the protocol $\eval'$ in which all $\textsf{PoE}$s are replaced by direct checks. We show that the extraction for $\eval'$ implies extraction for $\eval$. This is useful because we will later show that we can build an extractor for $\eval'$, i.e. it has witness extended emulation.
\begin{lemma}
Let $\eval'$ be the protocol that is identical to $\eval$ but in line \ref{line:PoE} of $\pro{EvalBounded}$ $\verifier$ directly checks $C_LC_R^{q^{d'+1}}=\gr{C}$ instead of using a $\textsf{PoE}$. If the adaptive root assumption holds for $\ggen$ and $\eval'$ has witness extended emulation for polynomials of degree $d=\poly$ then so does $\eval$.
\end{lemma}
\begin{proof}
We show that if an extractor $E'$ exists for the protocol $\eval'$ then either can construct $E$ or. 
For each PPT adversary $(\adv,P^*)$, $E$ will receive a polynomial number of transcripts. Any transcript that $\verifier$ accepts contains $\lceil \log(d+1)\rceil$ $\textsf{PoE}s$ executions. If for any $\textsf{PoE}$ the instance $(\gr{C}_R,\gr{C}/\gr{C}_{L},q^{d'+1})\not\in\mathcal{R}_{\textsf{PoE}}$ then we can construct $\adv_{\textsf{AdaptiveRoot}}(\crs)$ that computes an adaptive root in $\GG\sample \ggen$. This happens with negligible probability per $\textsf{PoE}$ execution. Since the adversary produces at most a polynomial number of transcripts and each transcript contains only a logarithmic number of $\textsf{PoE}$ we have that with overwhelming probability, under the adaptive root assumption, no such event can happen. 
This means that all transcripts are equivalent to having the verifier directly check $(\gr{C}_R,\gr{C}/\gr{C}_{L},q^{d'+1})\in\mathcal{R}_{\textsf{PoE}}$. Now we forward all these transcripts, without the $\textsf{PoE}$ to the $\eval'$ extractor $E'$. By assumption, $E'$ succeeds with overwhelming probability on all transcripts $\tr$ such that $\adv(\tr)=1$. and $E$ can simply output the same witnesses as $E'$. $E$ will therefore be a valid extractor for the protocol $\eval$ which shoes that $\eval$ has witness extended emulation and by definition so does the polynomial commitment scheme.

 adversary $(\adv,P^*)$ can break the witness extended emulation for $\eval$ then there exists an adversary $(\adv,P^*)$ that can break witness extended emulation for $\eval'$ or an efficient adversary $\adv_{\textsf{AdaptiveRoot}}$ that can compute adaptive roots. This would contradict the existence $E'$ which is the efficient extractor for $\eval'$ or the adaptive root assumption. 
\end{proof}
\begin{theorem}
	The polynomial commitment scheme for polynomials in $\ZZ_p[X]$ of degree at most $d=\poly$, instantiated using $q>2^{\lceil \log_2(d+1) \rceil+1} p^{3 \lceil \log_2(d+1) \rceil+1}$ and $\ggen$, has witness extended emulation (Definition \ref{def:wee}) if the adaptive root assumption and the strong RSA assumption hold for $\ggen$.
\end{theorem}

\begin{proof}
We will prove security by showing that given a polynomial time adversary $\adv_{\eval}$ that succeeds in convincing an honest verifier in the $\eval$ protocol on any public input with non-negligible probability we can either (1) construct an adaptive root adversary $\adv_{\textsf{Adaptive Root}}$, (2) extract an element of known order, and hence break the order assumption, (3) extract a fractional root of $\gr{g}\in \GG$ or (4) extract the polynomial $f(X)\in \mathcal{D}[X]$ such that $f(X)$ has degree at most $d$ and the coefficients of $f(X)$ are dyadic rationals, \emph{i.e.}, elements of $\mathcal{D}$ and bounded such that $f(q)$ is a unique encoding of $f(X)$. Additionally $\gr{g}^{f(q)}=\gr{C}$ and $f(z) \bmod p=y$. The proof will use the general forking lemma (Lemma \ref{lem:forking}) to show that the polynomial commitment scheme has witness-extended emulation.

In particular we construct an extractor $\mathcal{X}$ that given transcripts with $2$ distinct challenges per round, \emph{i.e.} $2^{\lceil\log_2(d+1)\rceil}<2 (d+1)$ total transcripts, can compute either an opening to the commitment scheme, an element of known order or a fractional root of $\gr{g}\in\GG$ as encoded in the public parameters $\params$.

First we consider the protocol $\eval'$ which is identical to $\eval$ but in line \ref{line:PoE} of $\pro{EvalBounded}$ $\verifier$ directly checks $C_LC_R^{q^{d'+1}}=\gr{C}$ instead of using a $\textsf{PoE}$ to outsource the computation to the prover. We will show that given a tree of valid extracting $\eval'$ transcripts we can compute a valid witness with overwhelming probability. This shows that $\eval'$ has witness extended emulation. We then show that under the adaptive root assumption this implies that $\eval$ has witness extended emulation and as such the entire polynomial commitment scheme.


%Now consider the case where $\gr{C}_L \gr{C}_R^{(q^{d'+1})}= \gr{C}$ for all executions. 
We will now construct the extractor that given a tree of $\eval'$ transcripts, recursively either extracts the encoding of a dyadic rational polynomial $f(X)\in \mathcal{D}[X]$ with bounded coefficients or a break of the order assumption or the fractional root assumption. In order to break the order assumption we instantiate the adversary $\adv_{\textsf{Order}}$ with the description of the group $\GG$. We also instantiate the fractional root adversary $\adv_{\textsf{FractionalRoot}}$ with $\GG$ and $\gr{g}$ as encoded in $\crs$.

Given the tree of transcripts as specified in the general forking lemma (Lemma \ref{lem:forking})  with branching factor $2$ at each level, \emph{i.e.} $2$ different challenges, we will extract a witness at each node of the tree given witness for both nodes' children. Each level corresponds to a separate invocation to $\pro{EvalBounded}'$. We denote the input to $\pro{Eval}'$ without subscripts, i.e. $\gr{C},z,y,d;f(X)$ and the input to $\pro{EvalBounded}'$ with a subscript indicating the round, \emph{e.g.} $d_0=d$, $\gr{C}_0=\gr{C}$ and $d_{\lceil \log_2(d)\rceil }=0,\gr{C}_{\lceil \log_2(d+1)\rceil }=g^{f}$ \emph{etc}. For the witness polynomials we use superscripts and parentheses, i.e. $f^{(i)}(X)$ to avoid confusion with the notation for coefficients.  We let $\alpha$ and $\alpha'$ denote the two distinct challenges at each node of the transcript tree. We use $'$ to denote the proof elements and witnesses corresponding to the $\alpha'$ challenge, \emph{e.g.} $\gr{C}_i'$.

In each round the extracted witness is a dyadic rational polynomial $f^{(i)}(X)\in \mathbb{D}[X]$ such that $\gr{g}^{f^{(i)}(q)}=\gr{C}_i$ such that the coefficients of $f^{(i)}(X)$ are in $C_{b_n,b_d}$, \emph{i.e.} have bounded numerators and denominators. The degree of $f^{(i)}(X)$ is at most $d_i$ and $f(z) \equiv y \bmod p$. Note that for odd primes $p$ and integer $z$, $f(z)\bmod p$ is always defined.

We extract starting from the leafs of the tree, \emph{i.e.} $d_{\lceil \log_2(d)\rceil}=0$. From the transcript we can directly extract the constant integer polynomial $f(X)=f \in \ZZ$ such that $\vert f \vert < p^{\lceil\log_2(d+1)\rceil+1}$, $y=f \mod p$, $f(X)=y\in \ZZ_p[X]$ and $\gr{g}^{f}=\gr{C}$ as the witness.

We now show how to compute the witness for $i-1$ given a witnesses for $i$. 

If $d_i+1$ is odd then we have $\gr{C}_{i-1}^q=\gr{C}_i$. Since $\gr{C}_{i-1}=\gr{g}^{f^{(i-1)}(q)}$ we either have that $q$ divides $f^{(i-1)}(q)$ or since $q$ is odd we have a fractional root of $\gr{g}$. 
If this is not the case then $f^{(i-1)}(q)=f^{(i)}(q)\cdot q^{-1}$ and $f^{(i)}(X)=\dec(f^{(i)}(q))$ has a zero constant term. Additionally since $y_i=y_{i-1}\cdot z$ and $f^{(i)}(z)\equiv y_i \bmod p$ we have $f^{(i-1)}(z)\equiv y_{i-1} \bmod p$, i.e. $f^{(i-1)}(q)$ is a valid witness and the degree of $f^{(i-1)}(X)=\dec(f^{(i-1)}(q))$ is at most $d_{i-1}=d_i-1$. 

Now if $d_i+1$ is even then we have for a challenge $\alpha$: $\gr{C}_{L,i-1}^\alpha \gr{C}_{R,i-1}=\gr{C}_i=\gr{g}^{f^{(i)}(q)}$ additionally for a challenge $\alpha'\neq \alpha$ we have $\gr{C}_{L,i-1}^{\alpha'} \gr{C}_{R,i-1}=\gr{C}'_i=\gr{g}^{f'^{(i)}(q)}$.  

 This gives us $\gr{C}_{L,i-1}^{\alpha-\alpha'}=\gr{g}^{f^{(i)}(q)-f'^{(i)}(q)}$. 
 If $\frac{f^{(i)}(q)-f'^{(i)}(q)}{\alpha-\alpha'}$ is not a dyadic rational then this gives us a fractional root of $\gr{g}$, that is the tuple $(f^{(i)}(q)-f'^{(i)}(q),\alpha-\alpha',\gr{C}_{L,i-1})$. If this is not the case then we can compute $\gr{D}=\gr{g}^{\frac{f^{(i)}(q)-f'^{(i)}(q)}{\alpha-\alpha'}}$. Either $\gr{D}=\gr{C}_{L,i-1}$ or $(\gr{D}/\gr{C}_{L,i-1})^{\alpha-\alpha'}=1$, \emph{i.e.} $\gr{D}/\gr{C}_{L,i-1}$ is an element of known order. This would break the order assumption.
 
Note that if $\frac{f^{(i)}(q)-f'^{(i)}(q)}{\alpha-\alpha'}$ is in fact a dyadic rational but not an integer then computing $D$ requires the extractor to take power of two roots. In class groups with discriminants that are prime and $7 \bmod 8$ this is always efficiently possible using an algorithm by GauÃ\cite{bosma1996computation}. In other groups of unknown order, such as $\ZZ_N/\{-1,1\}$ for composite $N$, it is not known how to efficiently compute square roots. This is, however, not a problem as the scheme can still be proven secure under a stronger fractional root assumption where any rational root breaks the assumption. Even a dyadic rational $\frac{f^{(i)}(q)-f'^{(i)}(q)}{\alpha-\alpha'}$ would then lead to a break of the assumption.
% Under the order assumption finding elements of known, bounded, order happens with negligible probability $\advantage{\textsf{Order}}{}$.

Finally, if no bad event occurs and no assumption is broken we have $\gr{C}_{L,i-1}=\gr{g}^{f^{(i-1)}_L(q)}$ where $f^{(i-1)}_L(q)=\frac{f^{(i)}(q)-f'^{(i)}(q)}{\alpha-\alpha'}$ is a dyadic rational.  
 
 In that case $\gr{C}_{R,i-1}=\gr{g}^{f^{(i-1)}_R(q)}=\gr{g}^{f_{i}(q)-\alpha \cdot f^{(i-1)}_L(q)}$. The extractor has now successfully obtained $f^{(i-1)}_L(q)\in \mathbb{D}$ and $f^{(i-1)}_R(q)\in \mathbb{D}$.
 
 If $f^{(i)}(q)\in C_{b_n,b_d}$ and $f'^{(i)}(q)\in C_{b_n,b_d}$, \emph{i.e.} their numerators are bounded by $b_n$ in absolute value and their denominator is bounded by $2^{b_d}$. The denominator of $f^{(i-1)}_L(q)$ is at most $|\alpha-\alpha'|<p$ times $2^{b_d}$. Since $\lambda=\lceil\log_2(p)\rceil$ we can deduce that $2^{b_d+\lambda}$ is a bound on the size of the denominator of $f^{(i-1)}_L(q)$ and consequently also on $f^{(i-1)}_R(q)$
By triangle equality we also have that the numerator of $f^{(i-1)}_L(q)$ is at most $2\cdot b_n$. For $f^{(i-1)}_R(q)=f_{i}(q)-\alpha f^{(i-1)}_L(q)$ we get a bound of $(2 p )\cdot  b_n$. 
For a sufficiently large $q$ we can still decode dyadic rational polynomials $f^{(i-1)}_L(X)=\dec(f^{(i-1)}_L)(q) \in C_{b_n\cdot (p+1),b_d+\lambda}[X]$ and $f^{(i-1)}_R(X)=\dec(f^{(i-1)}_R)(q) \in C_{b_n\cdot (p+1),b_d+\lambda}[X]$. 
The homomorphic properties of the commitment scheme along with soundness of the $\textsf{PoE}$ ensure that $f^{(i-1)}(X)=f^{(i-1)}_L(X)+X^{d_{i}+1} f^{(i-1)}_R(X)$. 
Since $ \alpha f^{(i-1)}_L(z)+ f^{(i-1)}_R(z)=f_{i}(z) \equiv y_i \bmod p$ and $ y_i=\alpha y_{L,i-1}+  y_{R,i-1} \bmod p$ we can compute $f^{(i-1)}_L(z)\equiv y_{L,i-1}\bmod p$ and $f^{(i-1)}_R(z)\equiv y_{R,i-1}\bmod p$. This gives us $f^{(i-1)}(z)\equiv y_{i-1}\bmod p$ and $f^{(i-1)}(X)\in C_{b_n\cdot (p+1),b_d+\lambda}[X] $ is a valid witness.  
Given that the protocol has $\lceil \log_2(d+1)\rceil$ rounds and $|f|< p^{\lceil\log_2(d+1)\rceil+1}$ then the final extracted polynomial $f_0(X)\in C_{b_n,b_d}$ for $b_n=2^{\lceil\log_2(d+1)\rceil}p^{2 \lceil\log_2(d+1)\rceil+1}$ and $b_d=\lambda \lceil\log_2(d+1)\rceil$. A sufficient bound on $q$ is therefore, $q>2^{\lceil\log_2(d+1)\rceil}p^{3 \lceil\log_2(d+1)\rceil+1}\approx d \cdot p^3$.

We can successfully extract from any tree of valid transcripts unless the adversary can find an element of known order or a fractional root. This, however, only happens with negligible probability by assumption, where the probability is taken over the randomness of the setup. Finally using the forking lemma (Lemma \ref{lem:forking}) we can show that if the strong RSA assumption and the adaptive root assumption (which in turn imply the fractional root and the order assumption) hold then $\eval'$ has witness extended emulation.

Now consider the protocol $\eval$. We will show that if $\eval'$ has witness extended emulation then under the adaptive root assumption so does $\eval$.
We will show that if an adversary $(\adv,P^*)$ can break the witness extended emulation for $\eval$ then there exists an adversary $(\adv,P^*)$ that can break witness extended emulation for $\eval'$ or an efficient adversary $\adv_{\textsf{AdaptiveRoot}}$ that can compute adaptive roots. This would contradict the existence $E'$ which is the efficient extractor for $\eval'$ or the adaptive root assumption. 

 For any transcript that $P^*$ produces we check for all \textsf{PoE} invocations whether the input $(C_R,C/(C_L),q^{d+1})\in \mathcal{R}_\textsf{PoE}$. If for all transcripts this holds but $(\adv,P^*)$ break witness extended emulation then $(\adv,P^*)$ would also break witness extended emulation for $\eval'$. The transcripts of $\eval'$ contain strictly less information then the transcripts of $\eval$ and are thus no harder to extract from then from $\eval$.


 Let $E'$ be the extractor for $\eval'$. We construct $E$ from $E'$ as an extractor for $\eval$. If for all $\textsf{PoE}$ evaluations the input $(u,w,x)$ is indeed in $\mathcal{R}_\textsf{PoE}$ then the transcripts for $\eval'$ can be derived directly from the transcripts for $E'$. $P^*$


First consider all the $\textsf{PoE}$ executions in all transcripts. There are $\lceil\log_2(d+1)\rceil$ $\textsf{PoE}$s per transcript. Consider the probability $\advantage{\textsf{PoE}Break}{}$ of the event that the adversary can break the $\textsf{PoE}$ soundness for any execution, \emph{i.e.}, $\gr{C}_L \gr{C}_R^{(q^{d'+1})}\neq \gr{C}$. Under the adaptive root assumption and by Lemma~\ref{lem:poe}, $\adv_{\eval}$ has negligible probability $\advantage{AR}{}$ in succeeding in each execution. Using a simple union bound we therefore have that the probability of $\advantage{\textsf{PoE}Break}{}$ is bounded by $2d \lceil\log_2(d+1)\rceil \cdot \advantage{AR}{}$ and still negligible in $\lambda$. The probability is taken over the $\textsf{PoE}$ verifier randomness, the adversary's randomness and the randomness of the $\setup$ but importantly not over the randomness of the $\alpha$ challenges. The forking lemma simply assumes that the challenges for each branch are distinct but not necessarily randomly distributed.


\alaninline{I think there are a couple of problems with this argument. \\
 - The various execution events are not independent. \\
 - No adaptive root adversary is constructed, so it's not clear why $\advantage{\textsf{PoE}Break}{}$ would even apply. \\
 - The transcripts are presented non-interactively to the extractor, but breaking PoE is an interactive game. It is not at all clear how to go from a fishy transcript to breaking PoE.}
 
 \alaninline{I think the solution might be something along these lines. For every PoE, the tree of transcripts branches into $n$ new branches, where $n$ is whatever number such that you can get the hidden power $q^{d'+1}$ from CRT-ing together $n$ remainders modulo distinct primes.}
 \benedikt{I think this should be resolved. Indpenendence is not an issue because of the union bound. I wrote up Lemma 5 which says that the precise advantage is advantage adaptive root. I don't think the interactivity matters. It's really important of course that PoE is independent of the $\alpha$ challenges.}
 
\alaninline{Interactivity does matter. The argument holds only if the primes $\ell$ are selected at random. But the extractor is only presented with a list of transcripts. The various $\ell$ are not probability variables anymore. Specifically, taking the probability over the adversary's coins and the verifier's coins does not make any sense anymore. How the transcripts came about is not relevant; the adversary may have produced them after an exponential amount of time. What is relevant is only that they are accepting transcripts.}


\end{proof}

{\it Note 1.} The extractability proof shows that the extractor is successful whenever the coefficients of the prover's polynomial are bounded in absolute value by $2^ip^{\lceil \log_2(d_{\it max} + 1) \rceil+i}$ or, after the final induction step, by $2^{\lceil \log_2(d_{\it max} + 1) \rceil}p^{2\lceil \log_2(d_{\it max} + 1) \rceil}$. In other words, prover who starts with a polynomial with at least one of the coefficients outside of this range, will succeed with negligible probability. However, the proof fails to cover what happens when he selects a polynomial within this range but outside $[0;p-1]$. As per correctness, his success is only guaranteed if all coefficients lie within this last range. Additionally this growing bound supplies in turn a lower bound on $q$. The coefficients that are too large in absolute value should percolate along with the recursion, remaining outside the bounds even after multiplication by a random $\alpha$. The set of possible coefficients must therefore be a factor $2^\lambda$ larger than the bounded interval. And therefore, $q > 2^{\lambda + \lceil \log_2(d_{\it max} + 1) \rceil}p^{2\lceil \log_2(d_{\it max} + 1) \rceil}$.




\subsection{Discussion and Optimizations}

We opted for an accessible presentation of the $\pro{Eval}$ protocol. In practice, it might make sense to apply certain optimizations.

\textbf{Precomputation.} The prover has to compute powers of $\gr{g}$ as large as $q^d$. While this can be done in linear time, this expense can be shifted to a preprocessing phase in which all elements $\gr{g}^{q^i}, i \in \{1, \ldots, d_{\it max}\}$ are computed.

\begin{enumerate}
	\item Precompute $g^{q^i}$ to use parallelism etc.
	\item join PoEs
	\item early termination
	\item Parallel Evals using different base elements \emph{e.g.}, $\gr{g}$ and $\gr{h}$. Merge commitments.
	\item ZK
	\item SNARK without falsifiable assumptions
	\item First polynomial commitment scheme with constant size parameters
\end{enumerate}

\subsection{Multivariate Commitment}\label{section:multivariate}
  We extend the Polynomial Commitment scheme to handle multivariate polynomials. The idea is to simply use higher degrees of $q$ to encode the polynomial. The protocol is linear in the number of variables and logarithmic in the total degree of the polynomial. For simplicity we only present a protocol for $n$-variate polynomials where the degree in each variable is $d$. The protocol naturally extends to different degrees per variable.
Let $q_i=q^{(d+1)^i}$ then $f(q_1,\dots,q_n)\in \ZZ$ is an encoding of the multivariate polynomial $f(X_1,\dots,X_n)$ with maximum degree $d$. Using this encoding we can naturally derive the multi-variate commitment scheme and $\eval$ protocol. The $\eval$ protocol  computes the univariate polynomials $f(q_1,\dots,q_{n-1},X_n)$ and then uses the univariate eval protocol to reduce the claim from a claim about an $n$-variate polynomial to one about an $n-1$-variate one. At the final step the prover opens the now constant polynomial and the verifier can check the claim. For a bivariate (say $X$ and $Y$) cubic polynomial the protocol would first reduce the degree of $X$ to $0$ in two rounds of interaction and then reduce the degree of $Y$ using another two rounds.
 
 \begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{Setup}(1^\secpar):$
		\begin{enumerate}[nolistsep]
			\item $ \GG \sample \ggen(\secpar)$
			\item $ \gr{g} \sample \GG$
			%\item $q \gets 2^k$ such that $q > (d+1) \cdot 2\cdot p^{\log_2(d+1)+1} $
			\item Pick a prime $p\in \NN$ such that $\lceil\log_2(p)\rceil=\lambda$.
			\item Pick a sufficiently large and odd $q\in \NN$
			\item $\pcreturn \params = (\secpar,\GG,\gr{g},p,q)$
		\end{enumerate}
	$\pro{Commit}(\crs;f(X_1,\dots,X_n) \in B_{2\cdot p}^n[X]\subset \ZZ[X]):$ 		\begin{enumerate}[nolistsep]
			\item $d\gets \deg(d)$\pccomment{For simplicity assume $f(X_1,\dots,X_n)$ has degree $d$ in each variable}
			\item $q_i\gets q^{(d+1)^{i-1}}$ for each $i\in [1,n]$
			\item $\gr{C} \gets \gr{g}^{f(q_1,\dots,q_n)}$
			\item $\pcreturn (\gr{C};f(X_1,\dots,X_n))$
		\end{enumerate}
			\end{flushleft}
\end{minipage}
\end{mdframed}
 
 \begin{mdframed}
\begin{minipage}{\textwidth}
			$\pro{MultiEval}(\crs, \gr{C}\in \GG, z_1,\dots z_n,y \in \ZZ_p, d,n \in \NN; f(X_1,\dots,X_n)\in Z_p^n[X]) :$ 			\begin{enumerate}[nolistsep]
			\item \pcif{n=1} 
			\item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\params,\gr{C},z_1,y,d,q;f(X_1))$ 
			\item \pcelse
			\item \pcind[1] Let $f(X_n)\gets f(q_1,\dots,q_{n-1},X_n)$
			\item \pcind[1] Let $\crs_n \gets \{\lambda,\GG,\gr{g},p,q_n\}$
			\item \pcind[1] \prover and \verifier run the univariate $\pro{EvalBounded}(\params_n,\gr{C},z_n,y,d,q_n;f(X))$ but instead of sending $f$ in the last round, which is of size $q_n^{d+1}$, the protocol returns it's input, i.e. $\gr{C}',y',b$ and the provers witness $f'(X_1,\dots,X_{n-1})=\dec(f)$.
			\item \pcind[1]\prover and \verifier run $\eval(\pp,C',z_1,\dots,z_{n-1},y',d,n-1;f'(X_1,\dots,X_{n-1}))$
		    \end{enumerate}
      \end{minipage}
\end{mdframed}

 
 


\begin{small}
 \begin{minipage}{1.1\textwidth}
\begin{mdframed}[userdefinedwidth=1\textwidth]  \label{prot:Opening}
	\noindent \underline{\textsf{Protocol \eval} (Polynomial evaluation)}\\
\noindent Params: $\crs=\{\secpar,p,\GG,g,d_{\max},n_{\max},q\}$;\ \
Inputs: $C\in \GG,z_1,\dots,z_n,y\in \FF_p,d \in \NN,n \in \NN $\\
Witness: $f(X_1,\dots,X_n) \in B_q[X^n]$ of degree at most d and with coefficients bounded by $p$\footnote{We describe the protocol using an integer polynomial with bounded coefficient. This generalizes the case where the polynomial is in $\FF_p[X^n]$};\\ 
Claim: $C=g^{f(q_1,q_2,\dots,q_n)}$ where $q_i=q^{(d_{\max}+1)^{i-1} },\deg(f)\leq d$ and $y=f(z_1,\dots,z_n) \mod p$

\begin{enumerate}[nolistsep]
\item \pcif $n=0 \wedge d=0$:
\item \pcind[1] Prover sends $f(X)$ to the verifier, $f(X)$ is a constant. 
\item \pcind[1] Verifier checks that $0\leq f(q)< p^{n_{\max}\cdot \log_2(d_{\max}+1)+1}$,  $f(z) \bmod p=y$ and $g^{f(q)}=C$ otherwise rejects
\item \pcelse: 
\item \pcind[1] $d'\gets \frac{d+1}{2}-1$
\item \pcind[1] Prover computes $f_0(X_1,\dots,X_n)\gets \sum_{\vec{i} \in [0,d_{\max}]^{n-1}}  \prod_{j=1}^{n-1} X_{j}^{i_j} \cdot(\sum_{k=0}^{d'} f_{\vec{i},k} X_{n}^k)\in \ZZ[X^n]$ and
$f_1(X_1,\dots,X_n)\gets \sum_{\vec{i} \in [0,d_{\max}]^{n-1}} \prod_{j=1}^{n-1} X_{j}^{i_j}(  \sum_{k=0}^{d'} f_{\vec{i},k+d'+1} X_{n}^{k})\in \ZZ[X^n]$
\item \pcind[1] $y_0\gets f_0(z_1,\dots,z_n) \bmod p$, $y_1\gets f_1(z_1,\dots,z_n)\bmod p$,\\ $C_0\gets g^{f_0(q_1,\dots,q_n)}$,$C_1\gets g^{f_1(q_1,\dots,q_n)}$
\item \pcind[1] Prover sends $y_0,y_1,C_0,C_1$ to the Verifier
\item \pcind[1] Verifier checks that $y_0+z_n^{d'+1} y_1=y\in \FF_p$ 
\item \pcind[1] Prover and Verifier engage in $\textsf{PoE}(C_1,C/C_0,q_n^{d'+1})$ to show that $C_0C_1^{q_n^{d'+1}}=C$
\item \pcind[1] Verifier samples $\alpha \sample \FF_p$ and sends it to the prover
\item \pcind[1] Prover and Verifier compute $y'\gets\alpha y_0 +y_1 \bmod p$, $C'\gets C_0^{\alpha}C_1 \in \GG$. \\Prover also computs $f'(X_1,\dots,X_n)\gets\alpha  \cdot f_0(X_1,\dots,X_n)+f_1(X_1,\dots,X_n) \in \ZZ[X^n]$ 
\item \pcind[1] \pcif $d=0$ and $n>0$: \pccomment{$f'$ is constant in $X_n$ so we write it as an $n-1$ variate polynomial.}
\item \pcind[2] $d'\gets d_{\max}$
\item \pcind[2] $n'\gets n-1$
\item \pcind[2] $\vec{z}\gets (z_1,\dots,z_{n-1})$
\item \pcind[1] Prover and Verifier run $\eval(C',\vec{z},y',d',n';f'(X))$
\end{enumerate}
\end{mdframed}
\end{minipage}
\end{small}



\begin{comment}
\subsection{Fix coefficients and negative degrees}
\begin{itemize}
	\item Several ways to do this.
\end{itemize}

\subsection{Range Proofs}

Follows from security proof of Eval.
\end{comment}



\subsection{Vector Commitments}

A commitment to a polynomial is a commitment to a list of coefficients, and the ability to extract any indicated coefficient from a polynomial commitment effectively upgrades the scheme to a vector commitment scheme.\footnote{For this classification we allow logarithmic-size proofs to qualify, in contrast to the original definition of Catalano and Fiore~\cite{PKC:CatFio13} which requires them to be constant size.} While it is possible to extract an indicated coefficient using only a polynomial commitment scheme (see Section~\ref{subsection:openindex_from_polycom} for a demonstration of this fact), it is possible to achieve this task much more efficiently by exploiting the homomorphic properties of our commitment scheme. For the following description we will identify polynomials $f(X)$ with their coefficient vectors $\mathbf{f}$ and vice versa, and we will switch between notations whenever it is convenient.

We achieve this task in two steps. Protocol $\pro{ExtractCoefficient}(\params, \gr{C}, i, \gr{C}_a; \mathbf{f}) \rightarrow b \in \{0,1\}$ validates that a given commitment really is a commitment to an indicated coefficient of a vector commitment. Next, Protocol $\pro{OpenIndex}$ uses this as a subprotocol to realize the syntax defined in the preliminaries (Section~\ref{subsection:openindex}). 

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{ExtractCoefficient}(\params, \gr{C}, i, \gr{C}_a; \mathbf{f}):$ \pccomment{$\mathbf{f} = (f_0, \ldots, f_d)^\mathsf{T} \in \ZZ^{d+1}$ and $a = f_i$}
		\begin{enumerate}[nolistsep]
		    \item \prover computes $f_L(X) \gets \sum_{j=0}^{i-1} f_j X^j$ and $f_R \gets \sum_{j=i+1}^d f_j X^{j-i-1}$
		    \item \prover computes $\gr{C}_L \gets \gr{g}^{f_L(q)}$, and $\gr{C}_R \gets \gr{g}^{f_R(q)}$
		    \item \prover computes $\gr{C}_a' \gets \gr{C}_a^{q^i}$ and $\gr{C}_R' \gets \gr{C}_R^{q^{i+1}}$
		    \item \prover sends $\gr{C}_L, \gr{C}_a', \gr{C}_R$ to \verifier
		    \item \verifier computes $\gr{C}_R' \gets \gr{C} \gr{C}_L^{-1} {\gr{C}_a'}^{-1}$
		    \item \prover and \verifier run $\pro{PoE}(\gr{C}_a, \gr{C}_a', q^i)$ and $\pro{PoE}(\gr{C}_R, \gr{C}_R', q^{i+1})$
		    \item \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}_L, z, f_L(z), i-1, b; f_L(X))$ for an arbitrary $z$ and any $b$ such that $\max_j f_j \leq b \ll q$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\textit{Note.} Instead of line 7, \prover and \verifier might as well run any range proof that establishes that $\gr{C}_L$ is a commitment to an integer smaller than $q^i$ in absolute value.

\begin{lemma}
    Protocol $\pro{ExtractCoefficient}$ has witness-extended emulation for the relation
    \[
        \mathcal{R}_\mathsf{EC}(\params) = \left\{
            \langle(\gr{C}, i, \gr{C}_a), (\mathbf{f}, r_f, r_a)\rangle \ : \ \begin{array}{l}
                 \mathbf{f} = (f_0, \ldots, f_d)^\mathsf{T} \in \mathbb{Z}_p^{d+1} \\
                 \pro{Open}(\params, \gr{C}, \mathbf{f}, r_f) = 1 \\
                 \pro{Open}(\params, \gr{C}_a, f_i, r_a) = 1
            \end{array}
        \right \} \enspace .
    \]
\end{lemma}
\begin{proof}
Full version/appendix.
\end{proof}

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{OpenIndex}(\params, \gr{C}, a, i; \mathbf{f}):$ \pccomment{$\mathbf{f} \in \ZZ_p^{d+1}$}
		\begin{enumerate}[nolistsep]
		    \item \prover computes $\gr{C}_a \gets \gr{c}^{f_i}$ and sends it to \verifier
		    \item \prover and \verifier run $\pro{ExtractCoefficient}(\params, \gr{C}, i, \gr{C}_a; \mathbf{f})$
		    \item \prover and \verifier run $\pro{Open}(\params, \gr{C}_a, a; f_i)$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\begin{lemma}
    Protocol $\pro{OpenIndex}$ has witness-extended emulation for the relation
    \[
        \mathcal{R}_\mathsf{Index}(\params) = \left\{
            \langle(\gr{C}, a, i, d), (\mathbf{f}, r_f)\rangle \ : \ \begin{array}{l}
                \mathbf{f} = (f_0, \ldots, f_d)^\mathsf{T} \in \mathbb{Z}_p^{d+1} \\
                f_i = a \\
                \pro{Open}(\params, \gr{C}, \mathbf{f}, r_f) = 1
            \end{array}
        \right\} \enspace .
    \]
\end{lemma}

\begin{proof}
Full version/appendix.
\end{proof}

\subsection{Inner Products}

The polynomial commitment scheme has a multiplicative homomorphism. Specifically, let $f(X), g(X) \in \ZZ_p[X]$ and let $\gr{C}$ be a commitment to $f(X)$. Then, provided that $q$ is large enough to prevent overflow, $\gr{C}^{g(q)}$ is a commitment to $f(X) \times g(X)$. This feature is particularly useful in the context of vector commitments where the goal is to extract not an indicated coefficient but a linear combination of all coefficients. To see how this might work, consider the coefficient vectors $\mathbf{f} = (f_0, \ldots, f_{d})$ and $\mathbf{g} = (g_0, \ldots, g_d)$. Then $\gr{C}$ is simultaneously a vector commitment to $\mathbf{f}$, and raising this commitment to %the integer encoding of the reciprocal of $g(X)$
the power $\sum_{i=0}^d g_{d-i} q^i$
gives a commitment to a new vector whose middle coefficient contains the inner product $\langle \mathbf{f}, \mathbf{g} \rangle$. To see this, consider the logarithm of $\gr{C}^{\sum\limits_{i=0}^{d} g_{d-i} q^i}$ base $\gr{g}$:
\begin{flalign*}
\left( \sum\limits_{i=0}^d f_i q^i \right) \left( \sum\limits_{i=0}^d g_{d-i} q^i \right) = \sum\limits_{i=0}^d \sum\limits_{j=0}^d f_i g_j q^{d-j+i} = q^d \sum_{i=0}^d f_i g_i \ + o(q^{d+1}) + \omega(q^{d-1}) \enspace .
\end{flalign*}

We use this property to realize protocols for extracting inner products. A minor issue is that the right hand vector commitment must represent the coefficients in reversed order. To circumvent this obstacle we denote by $\mathbf{\bar{g}}$ the vector $\mathbf{g}$ but with its coefficients reversed. For applications where this issue cannot be solved with notational cleverness, Appendix \textbf{[todo]} presents a protocol to establish that two vector commitments represent the same coefficients but in reversed order. 

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{InnerProduct}(\params, \gr{C}_\mathbf{f}, \gr{C}_\mathbf{\bar{g}}, a; \mathbf{f}, \mathbf{\bar{g}}):$ \pccomment{$\mathbf{f}, \mathbf{\bar{g}} \in \ZZ^{d+1}$ and $\gr{C}_\mathbf{\bar{g}} = \gr{g}^{\sum_{i=0}^d g_{d-i} q^i}$}
		\begin{enumerate}[nolistsep]
		    \item \prover computes $\gr{C}_h \gets \gr{C}_\mathbf{f}^{\sum_{i=0}^{d} g_{d-i} q^i}$ and sends it to \verifier
		    \item \verifier samples $z \xleftarrow{\$} \mathbb{Z}_p$ and sends it to \prover
		    \item \prover computes $h(X) \gets \left(\sum_{i=0}^d f_i X^i\right) \left(\sum_{i=0}^d g_{d-i} X^i\right)$
		    \item \prover computes $y_f \gets f(z)$, $y_g \gets g(z)$, and $y_h \gets h(z)$ and sends $(y_f, y_g, y_h)$ to \verifier
		    \item \verifier checks that $y_h = y_f \times y_g$
		    \item \verifier samples $\beta, \gamma \xleftarrow{\$} \mathbb{Z}_p$ and sends $(\beta, \gamma)$ to \prover
		    \item \prover computes $\gr{C}' \gets (\gr{C}_\mathbf{f}^\beta \gr{C}_\mathbf{g}^\gamma)^{q^{d-1}}$ and sends $\gr{C}'$ to \verifier
		    \item \prover and \verifier run $\pro{PoE}(\gr{C}_\mathbf{f}^\beta \gr{C}_\mathbf{g}^\gamma, \gr{C}', q^{d-1})$
		    \item \prover and \verifier run $\pro{Eval}(\gr{C}'\gr{C}_h^{-1}, z, {\beta{} z^{d-1} y_f + \gamma{} z^{d-1} y_g - y_h} , {2d-1} ;$ ${\beta{} X^{d-1} f(X) + \gamma{} X^{d-1} g(X) - h(X)})$
		    \item \prover computes $\gr{C}_a \leftarrow \gr{g}^{h_d}$
		    \item \prover and \verifier run $\pro{ExtractCoefficient}(\params, \gr{C}_h, d, \gr{C}_a; h(X))$
		    \item \prover and \verifier run $\pro{Open}(\params, \gr{C}_a, a, h_d)$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\begin{lemma}
    The protocol $\pro{InnerProduct}$ has witness-extended emulation for the relation
\[\mathcal{R}_\mathsf{IP}(\params) = \left\{
    \langle(\gr{C}_\mathbf{f}, \gr{C}_\mathbf{\bar{g}}, a), (\mathbf{f}, \mathbf{\bar{g}}, r_f, r_g)\rangle \ : \     \begin{array}{l}
            \mathbf{f}, \mathbf{\bar{g}} \in \mathbb{Z}_p^{d+1} \\
            \langle \mathbf{f}, \mathbf{g} \rangle = a \\
            \pro{Open}(\params, \gr{C}_\mathbf{f}, \mathbf{f}, r_f) = 1 \\
            \pro{Open}(\params, \gr{C}_\mathbf{\bar{g}}, \mathbf{\bar{g}}, r_g) = 1
        \end{array}
    \right\} \enspace .
\]
\end{lemma}

\begin{proof}
In the full version of the paper.
\end{proof}

\begin{comment}
\section{Security}

\begin{lemma}
	The fractional root assumption holds in the generic group model.
\end{lemma}
\begin{lemma}
	The polynomial commitment scheme satisfies the opening binding property
\end{lemma}
\begin{proof}
	Assume $\hat{f}(X)$ and $\hat{f}'(X)$ are integer encodings of two distinct polynomials $f(X),f'(X) \in \FF_p[X]$. Assume that the adversary can open a commitment $C$ to both $f(X)$ and $f'(X)$. We show that we can use this adversary to break the fractional root assumption (Assumption \ref{assum:fracroot}).
	
	 Then $\hat{h}(X)=\hat{f}(X)-\hat{f}'(X) \in \ZZ[X]$ is a polynomial of degree at most $d$. Since $g^{\hat{f}(q)}=g^{\hat{f}'(q)}=C$ we have that $g^{\hat{h}(q)}=1$. Note that the coefficients of $\hat{f}(X)$ and $\hat{f}'(X)$ are all less than $q/2$ in absolute value. By triangle inequality we have that $\hat{h}(X)$'s coefficients are less than $q$. $\hat{h}$ is by assumption not the zero polynomial. This implies that $\hat{h}(q)\neq 0$ is a multiple of the order of $g\in \GG$. This however can directly be used to break the adaptive root assumption (Assumption \ref{assum:adaptiveroot}) by taking the inverse of $\ell$ modulo $\hat{h}(q)$.
\end{proof}

\begin{theorem}
	The polynomial commitment scheme from Section \ref{sec:protocol} satisfies extraction under the fractional root Assumption and the Order assumption. We show that we can either extract a fractional root of $g$ or a witness \benedikt{Formally we should define witness extended emulation }
\end{theorem}
\begin{proof}
(SKETCH)
We prove the statement by showing that we can recursively either extract the encoding of an integer polynomial $f(X) \in \ZZ[X]$ of degree $d$ with bounded coefficients or a break of the fractional root assumption for element $g$ or a non trivial element of known (random) order in $\GG$. We recurse over degree $\hat{d}$ up to the final degree $d$.
In each round the extracted witness is an integer $\hat{y}$ such that $\hat{y}=\enc(f(X))$ where the coefficients of $f(X)$ are less than $B$ in absolute value and the degree is at most $\hat{d}$ and such that $g^{\hat{y}}=C$. Also $f(z) \equiv y \mod p$.
If $\hat{d}=0$ then we can directly extract $f(X)=\hat{y}$ such that $\vert \hat{y} \vert < p^{\log_2(d+1)+1}$, $y=\hat{y}\mod p$, $f(X)=y\in \FF_p[X]$ and $g^{\hat{y}}=C$ as the witness. We proceed with $d=1$.
For $d>0$ we have $g^{\hat{y}}=C=C_0^{\alpha}C_1$. Rewinding once we get 
 $C=C_0^{\alpha}C_1=g^{\hat{y}}$ and $C'=C_0^{\alpha'}C_1=g^{\hat{y}'}$ for distinct $\alpha$ and $\alpha'$. 
 This gives us $C_0^{\alpha-\alpha'}=g^{\hat{y}-\hat{y}'}$. 
 Either $\alpha-\alpha' \not|~ \hat{y}-\hat{y}' $ which would directly break the fractional root assumption or we can compute $D=g^{\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}}$. Either $D=C_0$ or $(D/C_0)^{\alpha-\alpha'}=1$, i.e. $D/C_0$ is an element of known order. In either of the cases the extraction succeeds and is completed. (Invoke order assumption).
 
 If $D=C_0$ then we have $\hat{y}_0=\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}$ and
 $g^{\hat{y}_0}=C_0$. In that case $C_1=g^{\hat{y}_1}=g^{\hat{y}-\alpha\hat{y}_0}$. The extractor has now successfully obtained $\hat{y}_0$ and $\hat{y}_1$
 
 If $|y|=|y'|<B$ then $|y_0|<  2 \cdot B$ and $|y_1|<|\hat{y}-\hat{y}+\alpha\hat{y}'|=|\alpha \hat{y}'|<\lambda \cdot B$. 
 We define $f(X)=\dec(y_0+X^{d} \cdot y_1)$ and with coefficients less than $2B$ in absolute value. 
 Note that $y_0=\hat{y}_0 \mod p=\dec(y_0)(z)$ and $y_1=\hat{y}_1 \mod p=\dec(y_1)(z)$. Since $y=\dec(\hat{y})(z)=\alpha \cdot \dec(\hat{y}_0)(z)+\dec(\hat{y}_1)(z)$ and $f(X)=\dec(y_0+X^{\hat{d}} \cdot y_1)$ we have that $y=y_0 +z^{\hat{d}/2}y_1 \mod p=f(z) \mod p$.
 Additionally $C=C_0^{\alpha}C_1=\commit(f(X))$ or we get a break of the adaptive root assumption.\benedikt{So this is technically a bit difficult because it's not actually a witeness}.
 
 The extractor recuses with the encoding of $f(X)$ and degree $\hat{d}'=\hat{d}\cdot 2$.
 
 Repeating this $\log_2(d+1)$ times we get a polynomial $f(X)$ of degree $d$ that has coefficients that are bounded by $(d+1) \cdot p^{\log_2(d+1)+1} <q/2$. 
 


\end{proof}

\begin{corollary}
	If $q<bla$ there exists an efficient adversary that can break the evaluation binding property of the polynomial commitment.
\end{corollary}
\benedikt{Figure out at what q we can attack the scheme. Probably needs to use negative coefficients and such.}
\end{comment}




\section{Zero knowledge polynomial commitment} 
This section sketches how to make the polynomial commitment scheme zero knowledge. 

\paragraph{Commit} Let $g_1 \sample \GG$ be a random base distinct from $g$. 
The hiding polynomial commitment is $C \leftarrow g^{f(q)}g_1^r$ for $r \sample [-2^\lambda, 2^\lambda]$. 

\paragraph{Open} The opening of the entire polynomial is the same, but additionally gives the blinding factor $r$. 

\paragraph{Eval}

\begin{itemize}
\item In each recursive step we commit to polynomials $f_0$ and $f_1$ using the same hiding commitment scheme, where $f_0 + f_1 q^{d/2} = f$ as integer polynomials. 

\item Note that if $C_0 = g^{f_0(q)}g_1^{r_0}$ and $C_1 = g^{f_1(q)} g_1^{r_1}$ then $C_0 \cdot C_1^{q^{d/2}} = C \cdot g_1^{r'}$ where $r' = r_0 + q^{d/2} r_1$. The prover can give a non-interactive zk proof of this relation to the verifier using a sigma protocol. E.g., the prover provides $C_1' = C_1^{q^{d/2}}$ with a PoE, and then a zk-PoKE of $r'$ such that $g_1^{r'} = C_0 C_1' / C$. 

\item We could then recurse on $C_0^\alpha C_1$ which commits to $\alpha f_0 + f_1$ with the blinding factor $\alpha r_0 + r_1$. BUT we are not done yet, see next bullet point... 

\item The remaining problem is that the evaluation protocol opens $y_0 = f_0(z) \bmod p$ and $y_1 = f_1(z) \bmod p$, which is not zero knowledge. We need $y_0, y_1$ to be independently distributed subject to the constraint $y_0 + z^{d/2} y_1 = y \bmod p$, which the verifier checks. 

A solution is to modify $f_0$ and $f_1$ by adding constant terms $\alpha, \beta$ to each that cancel, i.e. $\alpha + z^{d/2} \beta = 0 \bmod p$, where $\alpha$ is uniformly distributed in $\ZZ_p$. This way the polynomials $f_0' = f_0 + \alpha$ and $f_1' = f_1 + \beta$ satisfy the relation $f_0'(z) + z^{d/2}f_1'(z) = f(z) \bmod p$. We end up revealing $y_0' = y_0 + \alpha \bmod p$ and $y_1' = y_1 + \beta \bmod p$, which is uniformly distributed in $\ZZ_p$ subject to $y_0' + y_1' = y \bmod p$. 

Finally, the prover needs to convince the verifier that it modified the $C_0$ and $C_1$ commitments appropriately. (It could not simply choose $f_0'$ and $f_1'$ in the first step because $f_0' + q^{d/2} f_1' \neq f$ as integer polynomials). 

However, the solution is still simple. The prover creates hiding commitments $C_\alpha$ to $\alpha$ and $C_\beta$ to $\beta$ and provides a zero-knowledge proof that $C_\alpha C_\beta ^{z^{d/2}}$ is a commitment to an integer multiple of $p$. This can be done efficiently through a combination of PoE and a PoKE. (Given $g^a$, to prove that $a = 0 \bmod p$ it suffices to provide $Q$ such that $Q^p = g^a$ and a PoKE for $Q$ base g. This can be made zero knowledge w/ the standard tricks). 

The protocol then proceeds on modified commitments $C_0' = C_0 C_\alpha$ and $C_1' = C_1 C_\beta$.

\end{itemize}



\begin{comment}
\section{Vector Commitment}

\subsection{Commitment Scheme}

In the following we denote by $(a_i)_{i=0}^{d-1} \in \ZZ_p^{d}$ a vector of prime field elements. The vector commitment scheme is given by the following algorithms.
\begin{itemize}
\item $\mathsf{vcom} : \ZZ_p^d \rightarrow \mathbb{G} \, , \quad (a_i)_{i=0}^{d-1} \mapsto g^{\sum_{i=0}^{d-1} a_iq^i} \enspace .$
\item $\mathsf{vopen} : \mathbb{G} \times \mathbb{Z} \rightarrow \ZZ_p^d \cup \{\bot\} \, , $
\item[] $\phantom{\mathsf{vopen} :} (C, z = \sum_{i=0}^{d-1} z_iq^i) \mapsto \left\lbrace \begin{array}{ll}
(z_i \, \mathsf{mod} \, p)_{i=0}^{d-1} & \textnormal{\bf if } g^z = C \\
\quad \textnormal{where all } z_i \in \{0,\ldots,q-1\} & \\
\bot & \textnormal{\bf otherwise.}
\end{array} \right.$ 
\end{itemize}

Note: somewhat homomorphic properties: multiplication by constant, additivity. As long as coefficients don't overflow.

\subsection{Coordinate Extraction}

The following protocol enables the prover to extract a commitment to the $i$th component of the vector. Both Prover and Verifier know $i, g, C$. Only the prover knows an integer $z$ such that $g^z = C$ and corresponding to a vector $(a_j)_{j=0}^{d-1}$.
\begin{itemize}
\item Prover computes (or already knows) the $q$-ary expansion of $z$, \emph{i.e.}, $(z_j)_{j=0}^{d-1}$ such that $\sum_{j=0}^{d-1} z_j q^j = z$ and all $z_j \in \{0,\ldots, q-1\}$. He then sends to Verifier:
\begin{itemize}
\item $C_l = g^{\sum_{j=0}^{i-1} z_jq^j}, C_i = g^{z_i}, C_r = g^{\sum_{j=i+1}^{d-1} z_j q^{j-i-1}}$
\item $C_i^{q^i}, C_r^{q^{i+1}}$
\end{itemize}
\item Prover and Verifier run a proof of correct exponentiation to establish that $C_m^{q^i}, C_r^{q^{i+1}}$ were computed correctly.
\item Verifier checks that $C_l \times C_i^{q^i} \times C_r^{q^{i+1}} \stackrel{?}{=} C$ and aborts if false.
\item Prover and Verifier run a range proof to establish that the discrete logarithm of $C_l$ base $g$ is within the range $\{0, \ldots, q^i-1\}$.
\end{itemize}

Correctness, soundness, etc. (todo)

\subsection{Inner Product}
\label{section:inner_product}

The following protocol enables the prover to extract a commitment to the inner product $\mathbf{a}^\mathsf{T} \mathbf{s}$, where $\mathbf{a} = (a_i)_{i=0}^{d-1}$ is the vector to which $C$ is a commitment. The vector $\mathbf{s} \in \ZZ_p^d$ is known to the verifier in the basic protocol, but later on we show how to hide this vector and simultaneously reduce the verifier's running time.
\begin{itemize}
\item Prover and Verifier flip $\mathbf{s}$ to obtain $\bar{\mathbf{s}} = (s_{d-1-i})_{i=0}^{d-1}$ and the matching integer encoding $z_{\bar{\mathbf{s}}} = \sum_{i=0}^{d-1} s_{d-1-i} q^i$.
\item Prover computes $C^{z_{\bar{\mathbf{s}}}}$ and sends this value to the verifier.
\item Prover and Verifier engage in a proof of correct exponentiation.
\item Prover and Verifier extract a commitment to coordinate $d$, which is exactly $\sum_{i=0}^{d-1} a_is_i$ modulo $p$.
\end{itemize}

Correctness, soundness, etc. (todo) Special attention for coefficient size.

Note that the Verifier must process all of $z_{\bar{\mathbf{s}}}$ in order to verify the exponentiation, which in particular is linear in $d$. However, it is possible to reduce this complexity and simultaneously hide the value of $z_{\bar{\mathbf{s}}}$. To do this, the prover must have committed to $z_{\bar{\mathbf{s}}}$ by sending $g^{z_{\bar{\mathbf{s}}}}$ (possibly with respect to a different base). At this point, a batched proof of knowledge of exponent establishes that the discrete logarithms of $C^{z_{\bar{\mathbf{s}}}}$ base $C$ and of $g^{z_{\bar{\mathbf{s}}}}$ base $g$ are equal.

\section{Illustration: QAP-based SNARK}

The next protocol describes an efficiently verifiable proof system for rank-one constraint satisfaction problems. Specifically, we start from a list of $m$ constraints of the form
\begin{equation} \label{equation:r1cs}
    \mathbf{a_i}^\mathsf{T} \mathbf{s} \times \mathbf{b}_i^\mathsf{T} \mathbf{s} = \mathbf{c_i}^\mathsf{T} \mathbf{s} \enspace ,
\end{equation}
where $\mathbf{s} \in \ZZ_p^n$ is the secret witness and the $m$ triples $(\mathbf{a_i}, \mathbf{b_i}, \mathbf{c_i})_{i=0}^{m-1} \in \ZZ_p^{3 \times m \times n}$ are the known parameters that define the constraints. Furthermore, $s_0 = 1$.

Translate this to a quadratic arithmetic program (QAP) by selecting $m$ arbitrary but different elements $\{e_0, \ldots, e_{m-1}\} \subset \ZZ_p$ and defining $\mathbf{a}(X) \in \ZZ^n[X]$ such that $\mathbf{a}(e_i) = \mathbf{a_i}$, and similarly for $\mathbf{b}(X)$ and $\mathbf{c}(X)$. Furthermore, set $h(X) = \prod_{i=0}^{m-1} (X-e_i)$. Then Equation~\ref{equation:r1cs} becomes
\begin{equation} \label{equation:qap_modular}
    \mathbf{a}(X)^\mathsf{T}\mathbf{s} \times \mathbf{b}(X)^\mathsf{T}\mathbf{s} \equiv \mathbf{c}(X)^\mathsf{T}\mathbf{s} \,\, \mathsf{mod} \,\, h(X) \enspace .
\end{equation}
Moreover, a prover knowledgeable of $\mathbf{s}$ can produce another polynomial $t(X)$ such that
\begin{equation} \label{equation:qap_explicit}
    \mathbf{a}(X)^\mathsf{T}\mathbf{s} \times \mathbf{b}(X)^\mathsf{T}\mathbf{s} = \mathbf{c}(X)^\mathsf{T}\mathbf{s} + t(X) \times h(X) \enspace .
\end{equation}

The proof establishes that the prover knows a vector $\mathbf{s}$ and a polynomial $h(X)$ such that Equation~\ref{equation:qap_explicit} is satisfied. Specifically:
\begin{itemize}
    \item Common input to Prover and Verifier: $A = \mathsf{vcom}(\mathbf{a}(X))$, $B = \mathsf{vcom}(\mathbf{b}(X))$, $C = \mathsf{vcom}(\mathbf{c}(X))$, $H = \mathsf{com}(h(X))$, and $D = \mathsf{vcom}((1 \, 0 \, \cdots \, 0)^\mathsf{T})$.
    \item Prover produces commitments $A_\mathbf{s} = \mathsf{com}(\mathbf{a}(X)^\mathsf{T} \mathbf{s})$, and similarly for $B_\mathbf{s}, C_\mathbf{s}$ with the inner product protocol of Section~\ref{section:inner_product}. Additionally, $D_\mathbf{s}$ is computed. All four inner product protocols are performed simultaneously, thereby establishing that the $\mathbf{s}$ used is the same in all four cases.
    \item Prover opens $D_\mathbf{s}$ to $1$, showing that $s_0$ is $1$.
    \item Prover multiplies $t(X)$ into $H$, thereby obtaining $H_t = \mathsf{com}(t(X) \times h(X))$.
    \item Prover and Verifier run a proof of knowledge of exponent.
    \item Prover multiplies $\mathbf{b}(X)^\mathsf{T} \mathbf{s}$ into $A_\mathbf{s}$, thereby obtaining $A_{\mathbf{s}B\mathbf{s}} = \mathsf{com}(\mathbf{a}(X)^\mathsf{T} \mathbf{s} \times \mathbf{b}(X)^\mathsf{T} \mathbf{s})$.
    \item Prover and Verifier run a proof of equal discrete logarithms showing that $A_{\mathbf{s}B\mathbf{s}}$ is to $A_\mathbf{s}$ as $B$ is to $g$.
    \item Verifier selects a random point, $z \xleftarrow{\$} \ZZ_p$ and sends it to the prover.
    \item Prover and Verifier compute the weighted commitment $K = A_{\mathbf{s}B\mathbf{s}} \times C^{-1} \times H_T^{-1} = \mathsf{com}(\mathbf{a}(X)^\mathsf{T} \mathsf{s} \times \mathbf{b}(X)^\mathsf{T} \mathbf{s} - \mathbf{c}(X)^\mathsf{T} \mathbf{s} - h(X) \times t(X)) = \mathsf{com}(k(X))$
    \item Prover and Verifier run an evaluation proof establishing that $k(z) = 0$.
\end{itemize}

Note: we need to pay special attention to the size of the coefficients of $\mathbf{s}$ and of $t(X)$ are not too big. It is possible that the random selection of $z$ makes the prover who cheats by choosing larger coefficients overwhelmingly unlikely to succeed. Alternatively, we can devise a proof of small coefficients or something like that.
\end{comment}




\section{Transparent Preprocessing SNARKs via Linear IOPs} 
\input{lineariop}

\section{Conclusion}

 * talk about the importance of polynomial commitments from an information theoretical point of view, how it links to vector commitments and inner product arguments, how existing SNARK constructions are really just polynomial-IOPs in disguise, how polynomial-IOPs relate to other IOPs
 
 * how to interface between IOPs and integer relations, as opposed to relations between polynomials and scalars 
 
 * groups of unknown order are the natural algebraic object for concisely encoding integer relations
 
 * integer relations are really powerful, especially if you add interaction to the mix. ``You do not know the power of the DARK side.''
 
 * nevertheless, polynomial commitment schemes do not necessarily correspond integer relations; it's just that integer relations are powerful enough to do that also --- what other things can they do beyond polynomial commitments?
 
 * future work:
 
  - constant-size evaluations
  
  - constructions for smaller groups of unknown order (because no subexponential algorithms)
  
  - PQ analogues $<--$ for capturing integer relations
  
  - PQ analogues $<--$ for capturing polynomial commitments
  
  - polynomial commitment schemes from DLOG ?

%\bibliography{cryptobib/references}
\bibliographystyle{alpha}
  \bibliography{cryptobib/crypto,biblography}

\appendix


\section{Protocols for Proving Permutations}


\subsection{Flip}

The following protocol establishes that two commitments, $c_a$ and $c_b$ represent polynomials $f_a, f_b \in \ZZ_p$ (or vectors, for that matter) whose coefficients are flipped. Specifically, that $f_a = \sum_{i=0}^{d}f_i X^i$ for some coefficients $f_i$, and $f_b = \sum_{i=0}^df_ix^{d-i}$ for the same coefficients $f_i$.
Protocol:
\begin{itemize}
    \item Common knowledge: $c_a, c_b \in \mathbb{G}$.
    \item Verifier chooses $z \xleftarrow{\$} \ZZ_p \backslash \{0\}$ and sends it to Prover.
    \item Prover and Verifier engage in proofs of correct evaluation producing $f_a(z)$ and $f_b(z^{-1})$, matching $c_a$ and $c_b$, respectively.
    \item Verifier checks that $f_a(z) \stackrel{?}{=} z^d f_b(z^{-1})$.
\end{itemize}

To see why it works, observe that $f_a(X) = X^df_b(X^{-1})$ and we can test this equation probabilistically by choosing a random $z \in \mathbb{F}_p \backslash \{0\}$ to evaluate $f_a$ and $f_b$ in. If $f_a$ is indeed the flipping of $f_b$ then the polynomial $F = f_a(X) - X^df_b(X^{-1})$ is identically zero; but otherwise it has at most $d$ zeros, and so the inequality will be exposed with overwhelming probability $(p-1-d)/(p-1)$.

\subsection{Rotation}

A similar observation gives rise to a proof of correct rotation. If $f(X) = \sum_{i=0}^d f_i X^i \in \mathbb{F}_p$ and $p(X) = \sum_{i=0}^d f_{i+r \, \mathsf{mod} \, d+1} X^i \in \mathbb{F}_p$ are polynomials consisting of the same coefficients but rotated by $r$ positions, then $p(X) = X^r f(X) \, \mathsf{mod} \, X^r - 1$ in all points. More explicitly, $p(X) = X^r f(X) + k(X) (X^r - 1)$ for some $k(X) \in \mathbb{F}_p$. The verifier can test this relation probabilistically.

\begin{itemize}
    \item Common knowledge: $c_f, c_p \in \mathbb{G}$ --- commitments to $f(X)$ and $p(X)$, respectively. Secret knowledge for the prover $f(X), p(X)$.
    \item Prover computes $k(X) = (p(X) - X^r f(X)) / X^r - 1$ and sends the commitment $c_k = g^{\hat{k}(q)}$ to it to Verifier.
    \item Verifier chooses a random point $z \xleftarrow{\$} \mathbb{F}_p$ and sends it to Prover.
    \item Prover and Verifier engage in proofs of correct evaluation for $f(z)$, $p(z)$, and $k(z)$.
    \item Verifier checks that $z^r f(z) + k(z) (z^r-1) = p(z)$.
\end{itemize}

\subsection{Generic Permutation}

The following protocol establishes that two polynomial commitments have the same coefficients but permuted according to a known permutation $\sigma : \{0,\ldots,d\} \rightarrow \{0,\ldots,d\}$. Specifically, $c_f$ is a commitment to $f(X) = \sum_{i=0}^d f_i X^i$ and $c_p$ is a commitment to $p(X) = \sum_{i=0}^d f_{\sigma(i)} X^i$. The proof makes use of the relation $p(X) = X^{\sigma(0)} f(X^{d+1}) - d(X)$ where $d(X) = \sum_{i=1}^d f_i (X^{i(d+1) + \sigma(0)} - X^{\sigma(i)})$. As $d(X)$ relies on the coefficients of $f(X)$, it is important to establish that $d(X)$ is correctly formed.

\begin{itemize}
    \item Common knowledge: $c_f, c_p, \sigma$ -- commitment to $f(X)$, commitment to $p(X)$, and permutation of coefficients.
    \item Secret knowledge for Prover: $f(X), p(X) \in \mathbb{F}_p$.
    \item Prover computes $n = \hat{f}(q^{d^2})$ and sends $c_n = g^n$ to Verifier.
    \item Prover and Verifier run an inner product protocol between $c_n$ and $(q^{di})_{i=0}^d$, and again between the result and $(q^i)_{i=0}^d$. This establishes that $n$ has the same coefficients as $c_f$ but spaced differently.
    \item Prover and Verifier run an inner product protocol between $c_n$ and $(q^{(i(d+1) + \sigma(0)} - q^{\sigma(i)})_{i=0}^d$ to compute $c_d$, the commitment to $d(X)$ that is well-formed wrt. $f(X)$.
    \item Verifier chooses a random point $z \xleftarrow{\$} \mathbb{F}_p$.
    \item Prover and Verifier engage in proofs of correct evaluation for $f(z), p(z), d(z)$.
    \item Verifier checks that $p(z) = z^{\sigma(0)} f(z^{d+1}) - d(z)$.
\end{itemize}


\end{document}
