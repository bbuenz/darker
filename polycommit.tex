\documentclass{article}
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics,advantage]{cryptocode}
\usepackage{notations}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsmath,amsthm,amssymb}
\usepackage[utf8x]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{xspace}
\usepackage{comment}

%Theorems
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{fact}{Fact}
\newtheorem{corollary}{Corollary}

\newif\ifcomments
\commentstrue


\ifcomments
	\newcommand{\benedikt}[1]{{\textcolor{red}{[Benedikt: #1]}}}
	\newcommand{\ben}[1]{{\textcolor{green}{[Ben: #1]}}}
	\newcommand{\alan}[1]{{\todo[color=blue!40!white]{Alan: #1}}}
	\newcommand{\alaninline}[1]{{\todo[color=blue!20!white, inline]{Alan: #1}}}
	\else
	\newcommand{\benedikt}[1]{}
	\newcommand{\ben}[1]{}
	\newcommand{\alan}[1]{}
	\newcommand{\alaninline}[1]{}
	\fi

\begin{document}
\title{Transparent SNARKs from DARK Arguments}
\maketitle

\begin{abstract} 
We construct a new polynomial commitment scheme for multivariate polynomials over a finite field, with public-coin evaluation proofs that have logarithmic communication in the degree of the polynomial. The techniques are reminiscent of \emph{Diophantine Arguments of Knowledge} (Lipmaa, Asiacrypt'03), leveraging integer representations of polynomials and groups of unknown order. Security is shown from falsifiable assumptions that hold in generic groups. Moreover, the scheme does not require a trusted setup if instantiated with class groups. We apply this new cryptographic compiler to algebraic linear IOPs in order to obtain doubly-efficient public-coin IPs with succinct communication and witness-extended emulation for any NP relation. Allowing for linear preprocessing, the online verifier's work is logarithmic in the circuit complexity of the relation.

Concretely, compiling a QAP-based IOP results in quadratic prover time, but we obtain quasi-linear prover time when compiling instead the IOP employed in Sonic (Maller et. al., CCS 2019) based on bivariate Laurent polynomials. Applying the Fiat-Shamir transform in the random oracle model results in a transparent preprocessing zk-SNARK system with quasi-linear prover time, logarithmic proof size, and logarithmic verification time for arbitrary circuits, which we call \textsf{\textbf{Supersonic}}.

\end{abstract} 

\section*{Notes for Writing}
\begin{table}
    \caption{Notation}
    \label{tab:notation}
    \centering
    \begin{tabular}{l|l}
        symbol & meaning   \\ \hline \hline
        {\bf polynomials} & \\ \hline
        $f \in \mathbb{F}_p[x]$ or $f \in \mathbb{Z}[x]$ & polynomial modulo $p$ or without modulo, depending on context \\
        $f_L, f_R \in \mathbb{F}_p[x]$ & first and second half of $f(x)$ \\
        $f_0, f_1, f_i \in \mathbb{F}_p$ & coefficients \emph{s.t.} $f(x) = \sum_{i=0}^d f_ix^i$ \\ \hline
        {\bf group elements} &  \\ \hline
        $\mathsf{g} \in \mathbb{G}$ & designated base element (the term ``generator'' is misleading) \\
        $\mathsf{c}, \mathsf{c}_0, \mathsf{c}_1 \in \mathbb{G}$ & commitments \\
        $\mathsf{c}_0^a \times \mathsf{c}_1^b, \mathsf{c}_0^a\mathsf{c}_1^b \, \textnormal{for} \, a, b \in \mathbb{Z}$ & multiplicative notation \\ 
    \end{tabular}
\end{table}

\section{Introduction}

A polynomial commitment scheme enables a prover to bind himself to a polynomial in much less bandwidth than transmitting all coefficients would require. A skeptical verifier can subsequently test the commitment for certain algebraic relations as though he were in possession of the polynomial's full description, except at a much smaller work cost. Indeed, polynomial commitments lie at the heart of a host of efficiently verifiable interactive proof systems.

Of particular interest to this paper are proof systems whereby the prover establishes the correct performance of an arbitrary computation (that may or may not involve secret information) in such a way that the communication or verification complexity scales asymptotically better than performing the computation naïvely. Without exception, these proof systems rely on a technique called \emph{arithmetization}: characterizing the computation in question as a collection of arithmetic operations over a finite field. The utility of polynomial commitments stems from their capacity to succinctly capture a canonical representation of such collections while retaining the algebraic properties that make arithmetization work in the first place.

The literature on proof systems for arbitrary computations focuses on two techniques to achieve polynomial commitments. First: Merkle trees --- here every leaf represents the polynomial's evaluation in a given point, and the Merkle root represents the commitment to the polynomial. The verifier needs to verify the authentication paths of selected points, which can be done in logarithmic space and time (as a function of the number of points). Second: groups equipped with bilinear maps --- in this case a structured reference string (SRS)\footnote{Previously known as \emph{common reference string}, CRS.} provides the values of all monomials up to a given degree when evaluated in an unknown point. By computing a weighted sum of these monomial values, the prover obtains the evaluation of his polynomial in the unknown point. The verifier performs the pairing operation to verify that multiplicative relations hold between committed polynomials.

This paper provides a third option for generating polynomial commitment schemes, namely by relying on groups of unknown order --- such as the group of integers with multiplication modulo an RSA modulus of unknown factorization, or the ideal class group of an order of an imaginary quadratic number field. These groups have seen relatively little adoption or even attention from the cryptographic community because the only known constructions thereof have subexponential attack algorithms. As a result, for a practical security level, elements of groups of unknown order typically require several hundreds of bytes to represent, in contrast to the tens of bytes needed for elements of elliptic curves for which no subexponential algorithms exist. 

Nevertheless, groups of unknown order provide a property that groups of known order, such as elliptic curve groups, cannot match: they enable homomorphic  commitments to an \emph{infinite} domain, namely the integers. Indeed, if the prover were capable of reducing a large integer to a smaller one without sacrificing the homomorphic properties, then he must know the group's order. The power of integer commitments was already noted by Lipmaa~\cite{} who characterizes proof systems arising therefrom as \emph{Diophantine} --- a reference to the family of languages for which such proof systems establish. Specifically, a set $S \subset \mathbb{Z}^n$ is called \emph{Diophantine} if it is the projection onto the first $n \leq m$ coordinates of the set of roots to a polynomial $P(x_1, \ldots, x_m) \in \mathbb{Z}[x_1, \ldots, x_m]$. Much more recently, Wesolowski produced a conceptually simple verifiable delay function (VDF) which builds on a proof of correct exponentiation in groups of unknown order. Building on this result, Boneh \emph{et al.} developed accumulators and vector commitments (with batch openings) from groups of unknown order~\cite{}. Both results have been received with great enthusiasm in the cryptocurrency community for their capacity to improve sustainability and scalability of blockchains.

\alaninline{Todo: \\
 - applications (trustless snarks etc) \\
 - implications (no unfalsifiable assumptions) \\
 - overview of techniques \\
 - related work}

\vspace{0.25cm}
\textsc{Contributions.} The contributions of this paper are divisible into three rubrics:
\begin{itemize}
    \item[] \textbf{Tools.} We start with an encoding scheme that represents polynomials over a prime field $\mathbb{F}_p$ as integers, by encoding the polynomial's coefficients into the integer's base-$q$ expansion. Adjoined with a group of unknown order and a designated base element $g \in \mathbb{G}$, this encoding scheme naturally gives rise to a polynomial commitment scheme that inherits its somewhat homomorphic properties. Next, we provide protocols for proving the correct evaluation of a committed polynomial, and showing that two polynomials have the same coefficients but flipped or rotated. We also present a protocol for extracting the $i$th coefficient, thereby promoting the commitment scheme to one that also provides vector commitment functionality. Building on this observation, we provide another protocol for showing that a commitment represents the inner product between two vectors of which at least one is represented by its vector commitment. Another protocol establishes that two vector commitments represent the same vector up to an arbitrary but known permutation of the coefficients.
    \item[] All the proof systems mentioned so far have logarithmic communication complexity and logarithmic verification time. Moreover, with the exception of the inner product proof and the permutation proof, the prover's complexity is quasi-linear. If one is willing to sacrifice this scalability for the prover, we also provide counterparts to all the above proofs with constant communication and verification complexity.
    \item[] \textbf{Applications.} To illustrate the usefulness and the versatility of the enumerated tools, we join them straightforwardly to construct a simple succinct non-interactive argument of knowledge (SNARK) based on quadratic arithmetic programs (QAPs). To the best of our knowledge, this is the first SNARK for circuits without trusted setup (when instantiated with the class group) or with an SRS whose size is independent of the circuit (when instantiated with the RSA group).\footnote{This classification takes note of the STARK proof system of Ben Sasson \emph{et al.}~\cite{C:BBHR19} whose verification time is polylogarithmic but as a function of the \emph{running time} of some program and not of any circuit; as well as of Hyrax~\cite{SP:WTTW17} and Spartan~\cite{eprint:Setty19}, which do apply to circuits but whose verification times are not polylogarithmic and thus fail to satisfy the definition of SNARKs as set forth in the paper that coined the term~\cite{JC:BCCGLRT17}.}
    \item[] \alan{deprecated} We follow up this conceptually simple QAP-based proof system with a survey of popular communication-efficient proof systems for arbitrary computations, in which we replace their constituent components with tools developed earlier in this paper. In this light we analyze Sonic, Spartan, Hyrax, Bulletproofs, and STARK. In all cases we find that using our techniques leads to different trade-offs; improving on some metrics while degrading others.
\end{itemize}

\subsection{Related Work}

Homomorphic integer commitment schemes based on the RSA group were first proposed by Fujisaki and Okamoto~\cite{C:FujOka97}, who also provide a protocol to prove that a list of committed integers satisfy a polynomial equation modulo an arbitrary positive integer as well as one for opening a commitment bit by bit. Damgård and Fujisaki~\cite{AC:DamFuj02} fix an issue with the soundness proof of that protocol and are the first to suggest using class groups of an imaginary quadratic order as a candidate group of unknown order. Around the same time, Lipmaa draws the link between zero-knowledge proofs constructed from integer commitment schemes and Diophantine complexity~\cite{AC:Lipmaa03b}. Much later, Couteau~\emph{et al.} study protocols derived from integer commitments specifically in the RSA group in order to lift their security proofs so as to require weaker assumptions; in the process they develop proofs for polynomial evaluation modulo a prime $\pi$ that is not initially known to the verifier, in addition to a proof showing that an integer $x$ lies in the range $\{a, \ldots, b\}$ by showing that $1+4(x-a)(b-x)$ decomposes as the sum of 3 squares~\cite{EC:CouPetPoi17}.

Spurred by the recent demand for cryptographic tools from the blockchain industry, Pietrzak~\cite{Pietrzak18} adds efficient verifiability to the RSA-based time lock puzzle due to Rivest, Shamir, and Wagner~\cite{RivShaWag96}, thereby obtaining a conceptually simple verifiable delay function (VDF). Wesolowski~\cite{EC:Wesolowski19} improves on this result by proposing a single-round protocol to prove correct exponentiation in groups of unknown order, down from a logarithmic (in the size of the exponent) number for Pietrzak's protocol. Boneh~\emph{et al.} generalize this protocol to arbitrary exponents (not just powers of 2), and adapt it for zero-knowledge and batching, providing the base tools for constructing efficient accumulators and vector commitment schemes~\cite{C:BonBunFis19}.

\section{Preliminaries}
\paragraph{Notation}
\begin{itemize}
\item Let $f(x) \in \mathbb{F}_p[x]$ be a polynomial of degree at most $N-1$ where $N$ is a power of two. The coefficients of $f(x)$ are denoted by $f_i$ such that $f(x) \stackrel{\triangle}{=} \sum_{i=0}^{N-1} f_i x^i$.
\item Throughout, $p$ is a prime of at least $\lambda$ bits, and $q \in \mathbb{N}$ be an integer with $q \gg p$.  $\primes$ denotes the set of primes less than $2^{\lambda \log(\lambda)}$. There are at least $2^\lambda$ primes in that set.
\item We work in a group $\mathbb{G}$ of unknown order together with one or many designated base elements $\gr{g}, \gr{h} \in \mathbb{G}$ with unknown order. 
%(It might be tempting refer to these elements as \emph{generators} but that terminology would imply that $\mathbb{G}$ is cyclic, which is not necessarily true. \ben{Every element is a generator of a cyclic subgroup; why make this comment at all?}\textcolor{blue}{Alan: true; moot point.})
We use multiplicative notation and use \textsf{sans-serif} font to indicate group elements, as opposed to integers, polynomials, or field elements.
\item Some protocols in this paper are between two parties, the prover and the verifier. We write $\boldsymbol{\it Protocol}(x;w) \rightarrow (y;z)$ to describe such a protocol with common input $x$, private input for the prover $w$, public output $y$, and private output for the prover $z$. We write $(y;z) \gets \boldsymbol{\it Protocol}(x;w)$ to denote the protocol's execution. Any of $x,w,y,z$ can consist of tuples of objects. This notation facilitates protocol composition and modular analysis.
\end{itemize}

\subsection{Assumptions}

The cryptographic compilers make extensive use of groups of unknown order, \emph{i.e.}, groups for which the order cannot be computed efficiently.
Concretely, we require groups for which two specific hardness assumptions hold.
First the strong RSA assumption\cite{CCS:CraSho99} which roughly states that it is hard to take \emph{arbitrary} roots of \emph{random} elements. Secondly, the much newer adaptive root assumption\cite{EC:Wesolowski19} which is the dual of the strong RSA assumption and states that it is hard to take \emph{random} roots of \emph{arbitrary} group elements. 
Both of these assumption hold in generic groups of unknown order\cite{genericunknown,C:BonBunFis19}, i.e. there are no efficient algorithms that only have black-box access to the group but are able to break these assumptions. 
It is an open research problem to show whether one of these assumption implies the other.


\begin{assumption}[Strong RSA Assumption]
The \defn{strong RSA Assumption} sates that no efficient adversary can compute any root of a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
\[
    \Pr\left[\gr{u}^\ell = \gr{g} \, \wedge \, \ell > 2:
    \begin{array}{l}
         \GG \leftarrow \ggen(\lambda)  \\
         \gr{g} \sample \GG \\
         (\gr{u}, \ell) \in \mathbb{G} \times \mathbb{N} \leftarrow \adv(\mathbb{G}, \gr{g}) \\
    \end{array}\right] \leq \negl \enspace .
\]
\end{assumption}
We note that some definitions of the strong RSA assumption additionally require that $\ell$ be a prime~\cite{EC:BarPfi97,journals/iacr/BonehBF18a}. We follow that of Cramer and Shoup~\cite{CCS:CraSho99}.

\begin{assumption}[Adaptive Root Assumption]
\label{assum:adaptiveroot}
We say that the \defn{adaptive root assumption} holds for $\ggen$ if 
there is no efficient adversary $(\adv_0,\adv_1)$ that succeeds 
in the following task.
First, $\adv_0$ outputs an element $\gr{w} \in \GG$ and some $\state$.
Then, a random prime $\ell$ in $\primes$ is chosen
and $\adv_1(\ell,\state)$ outputs $\gr{w}^{1/\ell} \in \GG$.
More precisely, for all efficient $(\adv_0,\adv_1)$:
\[           \advantage{AR}{(\adv_0,\adv_1)}\deq 
                \Pr\left[\gr{u}^\ell = \gr{w} \neq 1 \ : \ 
                \begin{array}{l}
                      \GG \sample \ggen(\lambda) \\ 
                      (\gr{w},\state) \sample \adv_0(\GG) \\
                      \ell \sample \primes \\ 
                      \gr{u} \gets \adv_1(\ell, \state)
                \end{array} 
        \right] \leq \negl.
\]
\end{assumption}

We additionally use two more assumptions, however both of them reduce to the Strong RSA and the Adaptive Root assumption.

The first assumption states that computing the order for \emph{any} element is hard. It reduces to the adaptive root assumption. Interestingly, it doesn't necessarily hold for all candidate groups of unknown order. In $\ZZ_n$ for composite $n$, the element $-1\in \ZZ_n$ has known order $2$. For other candidate groups such as class groups with fundamental discriminants or $\ZZ_n/\{-1,1\}$ we have no efficient algorithms for computing elements of known order. We note that if $n=p\cdot q$ for strong primes $p$ and $q$ and we operate in the group of quadratic residues of $\ZZ_n$ then the order assumption reduces to the strong RSA assumption.\benedikt{Suitable citation}
\begin{assumption}[Order assumption]
\label{assum:order}
	The order assumption holds for $\ggen$ if for any efficient adversary $\adv$:
\[        
                \Pr\left[\gr{w}\neq 1 \wedge \gr{w}^{\alpha}= 1: 
                \begin{array}{l} 
                      \GG \sample \ggen(\lambda) \\ 
                      (\gr{w},\alpha) \sample \adv(\GG) \\
                      \text{where } |\alpha|<2^{\poly{}}\in \ZZ\\
                      \text{and } \gr{w}\in \GG
                \end{array} 
        \right] \leq \negl \enspace .
\]
\end{assumption}
\begin{lemma}
\label{lem:ordertoadaptive}
	The adaptive root assumption implies the order assumption.
\end{lemma}
\begin{proof}
	We show that given an adversary $\adv_{\textsf{Order}}$ that breaks the order assumption we can construct with overwhelming probability $\adv_{\textsf{Adaptive Root}}$ that breaks the adaptive root assumption. We run $\adv_{\textsf{Order}}$ to get a $\gr{w}\neq 1\in \GG$ and $\alpha \in \ZZ$ such that $\gr{w}^{\alpha}=1$. To construct $\adv_{\textsf{Adaptive Root}}$, $\adv_{\textsf{Adaptive Root},0}$ outputs $(\gr{w},\alpha)$. The challenger generates a random challenge $\ell$. If $\gcd(\ell,\alpha)=1$ then $\adv_{\textsf{Adaptive Root},1}$ can compute $\beta\gets \ell^{-1} \bmod \alpha$ and output $\gr{u}\gets\gr{w}^{\beta}$. By construction $\gr{u}^{\ell}=\gr{w}$. The probability that $\gcd(\ell,\alpha)=1$ is overwhelming because $\gcd(\ell,\alpha)\neq 1 \implies \ell \not\vert \alpha$. This happens with negligible probability as $\ell$ is picked from a set of $2^\lambda$ primes and at most $\poly$ distinct primes can divide $\alpha$.
	\end{proof}
	
	
We additionally define the pseudo root assumption which is a generalization of the Strong RSA assumption. It reduces to the order assumption (and therefore to the adaptive root assumption) and the strong RSA assumption. Shoup\benedikt{Cite shoup strong rsa paper} showed that for the unknown order group of quadratic residues in $\ZZ_n$, where $n$ is the composite of two strong primes, that the pseudo root assumption reduces to just the strong RSA assumption.
\begin{assumption}[Pseudo root assumption]
\label{assum:fracroot}
The pseudo root assumption holds for $\ggen$ if for any efficient adversary $\adv$:
\[        
                \Pr\left[\gr{u}^\beta = \gr{g}^{\alpha} \wedge \vert\frac{\beta}{\gcd(\alpha,\beta)}|>2   : 
                \begin{array}{l} 
                      \GG \sample \ggen(\lambda) \\ 
                      \gr{g} \sample \GG \\
                      (\alpha, \beta, y) \sample \adv(\GG, \gr{g}) \\
                      \quad \textnormal{where} \, |\alpha|<2^{\poly}, |\beta|<2^{\poly} \in \ZZ \\
                      \quad \textnormal{and} \, \gr{u} \in \GG 
                \end{array} 
        \right] \leq \negl \enspace .
\]
\end{assumption}
\begin{lemma}
	The adaptive root assumption and the strong RSA assumption imply the pseudo root assumption.
\end{lemma}
\begin{proof}
	Given an adversary $\adv_{\textsf{PseudoRoot}}$ that succeeds for $\ggen$ we can construct either an adversary $\adv_{RSA}$ for the strong RSA assumption or an adversary $\adv_{\textsf{Order}}$ that breaks the order assumption for $\ggen$. As shown in Lemma \ref{lem:ordertoadaptive} the order assumption reduces to the adaptive root assumption with overwhelming probability. 
	We first generate a group of unknown order $\GG \sample \ggen(\lambda)$.
	Then we generate $\gr{g}\sample \GG$ as done in the \textsf{RSA} security definition.
	
	We now run the $\adv_{\textsf{PseudoRoot}}$ on input $\GG$ and $\gr{g}$ to generate a tuple $(\alpha,\beta,\gr{u})$ such that $\gr{u}^{\beta}=\gr{g}^{\alpha}$. Let $\gamma=\gcd(\alpha,\beta)$ and $\alpha'=\frac{\alpha}{\gamma}\in \ZZ$ and  $\beta'=\frac{\beta}{\gamma}$. Now either $\gr{g}^{\alpha'}=\gr{u}^{\beta'}$ or $\gr{g}^{\alpha'}/\gr{u}^{\beta'}$ is a non trivial element of order $\gamma$ which would directly break the order assumption. In that case we constructed $\adv_{\textsf{Order}}$ that outputs $(\gr{g}^{\alpha'}/\gr{u}^{\beta'},\gamma)$.
	
	Now assume otherwise, i.e. $\gr{g}^{\alpha'}=\gr{u}^{\beta'}$. By construction $\gcd(\alpha',\beta')=1$ and we can efficiently compute integers $a,b$ such that $a \alpha'+b \beta'=1$. By assumption on $\adv_{\textsf{PseudoRoot}}$ $\beta'$ is not $1$. Now let $\gr{w}\gets \gr{u}^{a}\gr{g}^{b}$. Note that $\gr{w}^{\alpha'\beta'}=\gr{g}^{\alpha'}$. So either $\gr{w}^{\beta'}=\gr{g}$ or $\gr{w}^{\beta'}/\gr{g}$ is a non-trivial element of order $\alpha'$. The first case breaks the strong RSA assumption, as we can construct $\adv_{\textsf{RSA}}$ that outputs $(\gr{w},\beta)$, and the second breaks the order assumption.
\end{proof}


\benedikt{Talk about specific groups of unknown order}

\subsection{Interactive Arguments of Knowledge}
Interactive arguments are \emph{interactive proofs}~\cite{GolMicRac89} in which security holds only against a computationally bounded prover. In an interactive argument for a relation $\mathcal{R}$, the prover convinces the verifier that it ``knows" a witness $w$ for a statement $x$ such that $(x, w) \in \mathcal{R}$. The standard definition of \emph{proofs of knowledge}~\cite{C:BelGol92} is based on the existence of an extractor machine $E$ that has oracle access to a malicious prover $P^*$, and if $P^*$ would cause the verifier to accept on input $x$ with high probability then $E$ outputs $w$ such that $(x, w) \in \mathcal{R}$ (with overwhelming probability). $E$ runs in expected polynomial time. This definition quantifies the success of $E$ over all inputs $x$, which unfortunately is problematic in the case of interactive  \emph{arguments}. In particular, if the interactive argument relies on a \emph{common reference string} setup with trapdoor information (e.g. the factorization of an RSA modulus) then one of the inputs $x^*$ could leak the trapdoor to the prover. Any extractor should clearly fail on input $x^*$ while $P^*$ may succeed, hence the definition cannot be satisfied. This is rememedied 
\subsection{Commitment Schemes}

In defining the syntax of the various types of commitment schemes, we use the following convention with respect to public values (known to both the prover and the verifier) and secret ones (known only to the prover). In any list of arguments or returned tuple $(a, b, c; d, e)$ those variables listed before the semicolon are public, and those variables listed after it are secret. When there is no secret information, the semicolon is omitted.

\begin{definition}[commitment scheme]
A \defn{commitment scheme} $\Gamma$ is a tuple $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open})$ of protocols where
\begin{itemize}
    \item $\pro{Setup}(1^\lambda) \rightarrow \params$ generates public parameters $\params$;
    \item $\pro{Commit}(\params; x[, r]) \rightarrow (c; d)$ takes a secret message $x$ (and, optionally, secret randomness $r$) and outputs a public commitment $c$ and secret decommitment information $d$;
    \item $\pro{Open}(\params, c, x; d) \rightarrow b \in \{\bot, \top\}$ opens the commitment $c$ to the message $x$ using secret decommitment information $d$.
\end{itemize}
A commitment scheme $\Gamma$ is \defn{binding} if for all probabilistic polynomial time adversaries $\adv$,
\[
    \Pr\left[
        b_0 = b_1 \neq \bot \, \wedge \, x_0 \neq x_1 \ : \
        \begin{array}{l}
             \params \gets \pro{Setup}(1^\lambda) \\
             (c, x_0, x_1, d_0, d_1) \gets \adv(\params) \\
             b_0 \gets \pro{Open}(\params, c, x_0; d_0) \\
             b_1 \gets \pro{Open}(\params, c, x_1; d_1) \\
        \end{array}
    \right] \leq \negl \enspace .
\]
A commitment scheme $\Gamma$ is \defn{hiding} if for all probabilistic polynomial time adversaries $\adv=(\adv_0,\adv_1)$,
\[
    \left|
        1 - 2\Pr\left[
            \hat{b} = b \ : \
        \begin{array}{l}
             \params \gets \pro{Setup}(1^\lambda) \\
             (\state, x_0, x_1) \gets \adv_0(\params) \\
             b \sample \{0,1\} \\
             (\gr{c}; *) \gets \pro{Commit}(\params; x_b) \\
             \hat{b} \gets \adv_1(\state, \gr{c})
        \end{array}
        \right]
    \right| \leq \negl \enspace .
\]
\end{definition}

We now extend the syntax to polynomial commitment schemes. The following definition generalizes that of Kate~\emph{et al.}~\cite{AC:KatZavGol10} to allow interactive evaluation proofs. It also stipulates that the polynomial's degree be an argument to the protocol, contrary to Kate~\emph{et al.} where the degree is known and fixed.

\begin{definition}
A \defn{polynomial commitment scheme} is a tuple of protocols $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open}, \pro{Eval})$ where $(\pro{Setup},$ $\pro{Commit}, \pro{Open})$ is a binding commitment scheme for a message space $R[x]$ of polynomials over some ring $R$, and where
\begin{itemize}
    \item $\pro{Eval}(\params, c, z, y, d; f(x)) \rightarrow b \in \{\top, \bot\}$ is a protocol that takes a public commitment $c$, point $z \in R$, and a value $y$, degree $d$, along with a secret polynomial $f(x) \in R[x]$ with $\deg(f(x)) \leq d$ to which $c$ is a commitment, and shows that the evaluation of the secret committed polynomial $f(x)$ at $z$ is indeed $y$.
\end{itemize}
A polynomial commitment scheme is \defn{correct} if an honest committer can successfully convince the verifier of any evaluation. Specifically, if the prover is honest then for all polynomials $f(x) \in R[x]$ and all points $z \in R$,
\[
    \Pr\left[b = 1 \ : \ \begin{array}{l}
        \params \gets \setup(1^\lambda) \\
        (c; s) \gets \pro{Commit}(\params, f(x)) \\
        y \gets f(z) \\
        d \gets \deg(f(x))
        b \gets \pro{Eval}(\params, c, z, y, d; s) \\
    \end{array} \right] = 1 \enspace .
\]
A polynomial commitment scheme is \defn{evaluation binding} if no efficient adversary can convince the verifier that the committed polynomial $f(x)$ evaluates to different values $y_0 \neq y_1 \in R$ in the same point $z \in R$. Let $b \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \mathsf{V}\rangle}(c, z, y, d; s)$ denote an execution of this protocol with a malicious prover $\adv_1$ where $c, z, y, d$ is public and $s$ is a secret known only to the malicious prover. Then evaluation binding requires that for all probabilistic polynomial-time adversaries $\adv = (\adv_0, \adv_1)$,
\[
    \Pr\left[
         b_0 = b_1 \neq \bot \, \wedge \, y_0 \neq y_1 \ : \ \begin{array}{l}
            \params \gets \pro{Setup}(1^\lambda) \\
            (c, z, y_0, y_1, d_0, d_1, s_0, s_1) \gets \adv_0(\params) \\
            b_0 \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \mathsf{V}} \rangle(\params, c, z, y_0, d_0; s_0) \\
            b_1 \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \mathsf{V}} \rangle(\params, c, z, y_1, d_1; s_1) \\
        \end{array}
    \right] \leq \negl \enspace .
\]
\end{definition}

The syntax generalizes naturally to multivariate polynomial commitment schemes. Specifically, one obtains the syntax for an $m$-variate polynomial commitment scheme by replacing all occurrences of $x$ and $z$ by their $m$-dimensional vectorial counterparts, $\mathbf{x}$ and $\mathbf{z}$.

\begin{comment}
We now define a security games for polynomial commitments

\alaninline{Kate \emph{et al.} define a polynomial commitment scheme as a tuple of 6 algorithms $(\mathsf{Setup},\mathsf{Commit},\mathsf{Open},\mathsf{VerifyPoly},\mathsf{CreateWitness},\mathsf{VerifyEval})$. There is a difference between verifying a commitment and opening it. The proof-of-correct-evaluation is a ``witness''. Proving and verifying are given by non-interactive algorithms.}
\alaninline{Sonic defines a polynomial commitment scheme as a tuple $(\mathsf{Commit}, \mathsf{Open}, \mathsf{pvC})$. The generation of the public parameters is not part of the polynomial commitment scheme. There is no special decommitment information; the $\mathsf{Commit}$ function takes a polynomial $f(x)$ and $\mathsf{Open}$ takes \emph{the same} polynomial. The algorithm $\mathsf{Open}$ outputs the evaluation $f(z)$ along with a proof; this proof is verified by $\mathsf{pcV}$.}

\begin{definition}[Polynomial Commitment see \cite{AC:KatZavGol10} ]
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocols $\open$ and $\eval$ is secure interactive if it satisfies the following properties:
\paragraph{Correctness}
For an honest prover $\prover$ and a public coin honest verifier $\verifier$, is correct if for all polynomials $f(x)\in \ZZ_p[X]$ with degree polynomial in $\lambda$ and evaluation points $z\in \FF_p$:
	\[        
                \Pr\left[\begin{array}{c}\open_{\prover,\verifier}(\crs,f(x),C)=\text{"accept"}\\
                \eval_{\prover,\verifier}(\crs,C,z,y;f(x))=\text{"accept"}
                \end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, \deg(p(x)) \\
                      C\gets \commit(\crs,f(x))]\\
               z\sample \FF_p\\
                      y\gets f(z) \in \FF_p
                \end{array} 
        \right] =1.
\]
\benedikt{ok to mesh them together?}
\paragraph{Opening Binding}
\alaninline{This property is called ``polynomial binding'' in Kate \emph{et al.}}
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocol $\open$, is opening binding if for all polynomial degrees $d=\poly\in \NN$ and for any efficient adversary $\adv$ and honest verifier $\verifier$:

	\[        
                \Pr\left[\begin{array}{c}\open_{\adv,\verifier}(\crs,C,f(x))=\text{"accept"}\\
                \wedge\\
           \open_{\adv,\verifier}(\crs,C,g(x))=\text{"accept"}\\
                \wedge\\
                f(x)\neq g(x) \vee \deg(f(x))\neq d\end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      (C,z,f(x),g(x))\sample \adv(\crs)]
                \end{array} 
        \right] \leq \negl.
\]
\paragraph{Evaluation Binding}
	\[        
                \Pr\left[\begin{array}{c}\eval_{\adv,\verifier}(\crs,z,y_0,C)=\text{"accept"}\\
                \wedge\\
                \eval_{\adv,\verifier}(\crs,z,y_1,C)=\text{"accept"}\\
                \wedge\\
                y_0\neq y_1\end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      (C,z,y_0,y_1)\sample \adv(\crs)]
                \end{array} 
        \right] \leq \negl.
\]
\end{definition}
\end{comment}

In order to provide a strong soundness guarantee, we would like to require that any successful prover must display \emph{knowledge} of a polynomial $f(x)$ that $c$ is a commitment to, and that evaluates to $y$ in $z$. This is already implied if the verifier can choose $z$, since opening the polynomial in $\deg(f(x))+1$ points determines it completely. However, we want an even stronger soundness notion, one that applies even when $z$ is not chosen by the verifier. This motivates the following definition of extractability.

\begin{comment}
We additionally require a stronger extraction property that had in different variations been defined by Zhang~\emph{et al.}~\cite{SP:ZGKPP17} and Sonic~\cite{EPRINT:MBKM19}.
\begin{definition}[PolyCommit extraction]
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocol $\eval$, is extractable if there exists a rewinding \benedikt{Define more properly}extractor $\extractor$ such that for all polynomial degrees $d=\poly\in \NN$ and for any efficient adversary $\adv$:
	\[        
                \Pr\left[\begin{array}{c}\eval_{\adv,\verifier}(\crs,C,z,y)=\text{"accept"}\\
                \wedge\\
                f(x)\gets\extractor^{<\eval_{\adv,\verifier}(\crs,C,z,y)>}(\crs,C)\in \FF_p[X]\\
                \wedge\\
               \commit(f(x))\neq C\vee f(z)\neq y \vee \deg(f)\neq d
                 \end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      \tau \sample (0,1)^\lambda\\
                      (C,z,y)\sample \adv_1(\crs,\tau)]
                      
                \end{array} 
        \right] \leq \negl.
\]
\end{definition}
\end{comment}

\begin{definition}[extractability]
Let let $\Gamma$ be a polynomial commitment scheme, let $\adv = (\adv_0, \adv_1)$ be any probabilistic polynomial-time adversary attacking the scheme where in particular $\adv_0$ decides on a statement and $\adv_1$ tries to convince the verifier of it, and let $\extractor$ be a probabilistic polynomial-time black-box extractor algorithm that satisfies the following description.
\begin{itemize}
    \itemsep0em 
    \item $\extractor$ interacts with $\adv_1$ in accordance with the $\eval$ protocol syntax, where $\extractor$ assumes the role of the verifier and $\adv_1$ the role of the prover.
    \item $\extractor$ can rewind $\adv_1$ to any previous point in time, at which point the protocol will resume from that point onward. $\ext$ remembers the observed messages from previous execution branches.
    \item We write $f(x) \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \extractor\rangle}(c,z,y,d;\st)$ to denote an execution of this extraction procedure whereby $\extractor$ finally outputs $f(x)$.
\end{itemize}
We say the polynomial commitment scheme $\Gamma$ is \defn{extractable} if there is an extractor $\extractor$ for all adversaries $\adv = (\adv_0, \adv_1)$ that convince the honest verifier with noticeable probability\alan{Actually, I am not convinced that with this order of quantifiers, the text definition is equivalent as the formula definition.}, $\extractor$ outputs a polynomial $f(x) \in R[x]$ of degree at most $d$ that matches the commitment with overwhelming probability. Specifically, this means that
\[
    \Pr \left[
        b \neq \bot \, \wedge \, c' \neq c \ : \ 
        \begin{array}{l}
             \params \gets \pro{Setup}(1^\lambda) \\
             (c, z, y, d; \state) \gets \adv_0(\params) \\
             b \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \verifier\rangle}(c, z, y, d; \state) \\
             f(x) \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \extractor\rangle}(c, z, y, d; \state) \\
             (c'; *) \gets \pro{Commit}(\params; f(x))
        \end{array}
    \right] \leq \negl \enspace .
\]
\end{definition}

\begin{lemma}[binding $\wedge$ extractability $\Rightarrow$ evaluation binding]
	A binding polynomial commitment scheme that satisfies extractability also satisfies evaluation binding.
\end{lemma}
\begin{proof}
Proof by contradiction. We assume that there exists an adversary $\adv_{\rm eval} = (\adv_{{\rm eval},0}, \adv_{{\rm eval},1})$ capable of breaking the evaluation-binding property with non-negligible probability. With this algorithm we construct another algorithm that breaks the binding or the extractability properties. The description of this constructed adversary follows.

Run $\adv_{{\rm eval}, 0}(\params)$ to obtain $(c, z, y_0, y_1, d_0, d_1, s_0, s_1)$. Then run the extractor to obtain the polynomials $f_0(x) \gets \eval_{\langle \adv_{{\rm eval}, 1} \leftrightarrow \extractor \rangle}(c, z, y_0, d_0; s_0)$ and $f_1(x) \gets \eval_{\langle \adv_{{\rm eval}, 1} \leftrightarrow \extractor \rangle}(c, z, y_1, d_1; s_1)$. The algorithm's final step depends on the property under consideration.

Let $(c_0; *) \gets \pro{Commit}(\params, f_0(x))$ and $(c_1; *) \gets \pro{Commit}(\params, f_1(x))$. Since $y_0 \neq y_1 \Rightarrow f_0(x) \neq f_1(x)$, the probability $\Pr[c_0 = c_1]$ is negligible due to the binding property. Specifically, the final step here consists of outputting $(c, f_0(x), f_1(x), f_0(x), f_1(x))$ and this would break the binding property.

The probability $\Pr[c_0 \neq c \, \vee \, c_1 \neq c]$ is also negligible, because either clause breaks the extractability property. Specifically, the final step would consist of outputting either $(c,z,y_0, \deg(f_0(x), \state)$ where $\state = f_0(x)$ or $(c, z, y_1, \deg(f_1(x)), \state)$ where $\state = f_1(x)$; the second half of the extractability adversary is identical to that of the evaluation binding adversary, in which case the extractor proceeds to extract $f_0(x)$ or $f_1(x)$, respectively.

The remaining option is that $\Pr[b \neq \bot]$ is non-negligible, but this would imply, contrary to our assumption, that the adversary $\adv_{\rm eval} = (\adv_{{\rm eval},0}, \adv_{{\rm eval},1})$ is not capable of breaking the evaluation binding property.
\end{proof}


\subsection{Proofs of Exponentiation}
Wesolowski \cite{EC:Wesolowski19} in his work on efficient verifiable delay functions introduced a simple yet powerful proof of exponentiation in groups of unknown order. A prover can efficiently convince a verifier that a large exponentiation in a group of unknown order was done correctly. The verifier needs to do little more than read the exponent. If the exponent is smooth then the protocol takes constant space/time in the security parameter.
\benedikt{Describe PoE protocol}
Boneh et al. \cite{journals/iacr/BonehBF18a} built on top of PoE to also develop PoKEs. \benedikt{Finish this section}
\section{Protocol}
\label{sec:protocol}

\subsection{Polynomial Encoding}

	Consider the set $B_{q/2}\subset \ZZ$ of integers with absolute value of less than $q/2$. $B_{q/2}[X]$ is the polynomial ring of that set such that the polynomials have bounded coefficients. $p(q) \in \ZZ$ for $p(x)\in P_q$ is a unique encoding of the polynomial:
\begin{itemize}
	\item Domain $B_{q/2}[X]\subset \ZZ[X]$, Alphabet: $\ZZ$
	\item 	$f(x):=\sum_{i=0}^{\lfloor\log_q(y)\rfloor} f_i x^i$
	\item $\enc(f(x) \in X)\rightarrow  f(q) \in \ZZ$
	\item $\dec(y \in \ZZ): f_i \in [0,q-1]\gets \frac{y \mod q^{i+1}-y \mod q^{i}}{q^i} \forall i \in [0,\lfloor\log_q(y)\rfloor]$
	\item Fix negative case
\end{itemize}

\begin{fact}
	Under certain conditions\todo{todo: elaborate me}, polynomial encoding scheme is uniquely decodable.
\end{fact}

Note that the encoding has limited homomorphic properties. $\enc(g(x))+\enc(h(x))=\enc(g(x)+h(x))$ if $g(x)+h(x)\in P_q$, i,.e. all its coefficients are less than $q/2$ in absolute value.\ This is ensured if for example the coefficients of $g$ and $h$ are less than $q/4$. Additionally $\enc(g(x))\cdot \enc(h(x))=\enc(g(x)\cdot h(x))$ if $g(x)\cdot h(x)\in P_q$.

\subsection{Polynomial Commitment}

We now present our main result: a polynomial commitment scheme with an efficient evaluation protocol based on groups of unknown order. We use lower-case \textsf{sans-serif} font to denote group elements. To save space, we denote the prover by $\prover$ and the verifier by $\verifier$. The scheme is parameterized by three values that are independent of the setup: the prime $p$ that defines the field over which the polynomial is defined; the degree $d_{\it max}$ that provides an upper bound on the degree of the polynomials for which the scheme works; and the integer $q$ which is ``large enough'' power of two, where what ``large enough'' means depends on the context.

The commitment and opening protocols are straightforward. They simply raise the designated group element $\gr{g}$ to the integer encoding of the polynomial as described in the previous section. The evaluation protocol uses the limited homomorphic properties of this encoding scheme to reduce the statement to smaller versions of itself.

In every iteration of the evaluation protocol, the working polynomial $f(x)$ is split in half, the left part $f_L(x)$ and the right part $f_R(x)$ such that $f(x) = f_L(x) + f_R(x) \cdot x^{d'}$ where $d' = \left\lceil \frac{d+1}{2}\right\rceil - 1$ and $d = \mathrm{deg}(f(x))$. The evaluation $y = f(z) \mod p$ is also split into two halves, $y_L = f_L(z) \mod p$ and $y_R = f_R(z) \mod p$ such that $y = y_L + y_R \cdot z^{d'}$, and so is the commitment with $\gr{c}_L = \gr{g}^{f_L(q)}$, $\gr{c}_R = \gr{g}^{f_R(q)}$. The verifier infers $y_L$ from $y$ and $y_R$, and infers $\gr{c}_L$ from $\gr{c}$ and $\gr{c}_R^{q^{d'}}$ --- but to save verification work, the prover sends both $\gr{c}_R$ and $\gr{c}_R^{q^{d'}}$ and the two engage in a $\pro{PoE}$ to establish that the one commitment really is the correct power of the other. At this point, the verifier samples a randomizer $\alpha \sample \mathbb{F}_p$ and the protocol recurses to prove a folded version of the statement, namely that $\gr{c}' = \gr{c}_L^\alpha \times \gr{c}_R$ is a commitment to $f'(x)$ that evaluates to $y' = \alpha y_L + y_R$ in $z$ modulo $p$. In the last recursion step, the degree of the polynomial is zero, \emph{i.e.}, $f(x)$ is a constant; in this case the prover simply sends this constant $f(x) = f_0$ and the verifier checks that $f_0 = y \mod p$ along with $\gr{g}^{f_0} = \gr{c}$ and $0 \leq f_0 < q$. If all checks succeed, the verifier accepts.

This intuitive description omits special care afforded to the case where the degree of the polynomial is not one less than a power of two. To take care of this, the left polynomial is guaranteed to have odd degree (unless in the last step when it is zero), and the right half polynomial $f_R(x)$ is shifted to the right by one digit whenever its degree is even. The evaluation $y_R$ and commitment $\gr{c}_R$ are adapted accordingly.

\begin{figure}
\renewcommand{\figurename}{Scheme}
\caption{polynomial commitment scheme} \label{scheme:polynomial_commitment}
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{Setup}(1^\secpar):$
		\begin{enumerate}[nolistsep]
			\item $ \GG \gets \ggen(\secpar)$
			\item $ \gr{g} \sample \GG$
			%\item $q \gets 2^k$ such that $q > (d+1) \cdot 2\cdot p^{\log_2(d+1)+1} $
			\item $\pcreturn \params = (\secpar,\GG,\gr{g})$
		\end{enumerate}
	$\pro{Commit}(\crs;f(x)):$ \pccomment{$f(x) \in \mathbb{Z}[x]$ with coefficients in $[0;p-1]$}
		\begin{enumerate}[nolistsep]
			\item $\gr{c} \gets g^{f(q)}$
			\item $\pcreturn (\gr{c};f(x))$
		\end{enumerate}
	$\pro{Open}(\crs,\gr{c},\bar{f}(x);f(x)):$ \pccomment{$f(x) \in \mathbb{Z}[x]$ but $\bar{f}(x) \in \mathbb{F}_p[x]$}
		\begin{enumerate}[nolistsep]
		    \item \prover sends $f(x)$ to \verifier.
			\item \verifier checks that $\gr{g}^{f(q)} = \gr{c}$
			\item \verifier checks that for all $i \in \{0, \ldots, d\}$, $0 \leq f_i < p^{d_{\it max}}$
			\item \verifier checks that $f(x) \equiv \bar{f}(x) \mod p$
			\item \pcif all checks pass \textbf{then} \pcreturn $\top$ \textbf{else} \pcreturn $\bot$
		\end{enumerate}
	$\pro{Eval}(\params, \gr{c}, z, y, d; f(x)) :$ \pccomment{$f(x) = \sum_{i=0}^d f_i x^i \in \mathbb{Z}[x]$}
	    \begin{enumerate}[nolistsep]
        \item \pcif $d=0$:
        \item \pcind[1] $\pcreturn \pro{Open}(\params, \gr{c}, y; f(x))$ \pccomment{$f(x) = f_0 \in \mathbb{Z}$}
        \item \pcelse: \pccomment{$d \geq 1$}
        \item \pcind[1] \prover and \verifier compute $d' \gets \lceil\frac{d+1}{2}\rceil - 1$
        \item \pcind[1] \prover computes $f_L(x) \gets \sum\limits_{i=0}^{d'} f_i x^i$ and $f_R(x)\gets\sum\limits_{i=0}^{d-d'-1} f_{d'+1+i} x^{i}$
        \item \pcind[1] \prover computes $y_L\gets f_L(z) \bmod p$ and $y_R\gets f_R(z)\bmod p$
        \item \pcind[1] \prover computes $\gr{c}_L \gets \gr{g}^{f_L(q)}$ and $\gr{c}_R \gets \gr{g}^{f_R(q)}$ and $\gr{c}_R^\star \gets \gr{c}_R^{q^{d'+1}}$
        \item \pcind[1] \prover sends $y_R, \gr{c}_R, \gr{c}_R^\star$ to \verifier
        \item \pcind[1] \verifier computes $y_L \gets y - y_R \cdot z^{d'+1}$ and $\gr{c}_L \gets \gr{c} \times \gr{c}_R^{\star \, -1}$
        \item \pcind[1] \prover and \verifier run $\pro{PoE}(\gr{c}_R, \gr{c}_R^\star, q^{d'+1})$
        \item \pcind[1] \verifier samples $\alpha \sample \FF_p$ and sends it to \prover
        \item \pcind[1] \pcif $d$ is odd $:$ \pccomment{degree of $f_R$ is odd}
        \item \pcind[1] \pcind[1] \prover and \verifier compute $y'\gets\alpha y_L +y_R \bmod p$ and $\gr{c}' \gets \gr{c}_L^\alpha \times \gr{c}_R$. 
        \item \pcind[1] \pcind[1] \prover computes $f'(x) \gets \alpha \cdot f_L(x) + f_R(x) \in \ZZ[x]$ 
        \item \pcind[1] \pcind[1] \prover and \verifier run $\pro{Eval}(\params, \gr{c}', z, y', d'; f'(x))$
        \item \pcind[1] \pcelse $:$ \pccomment{degree of $f_R$ is even}
        \item \pcind[1] \pcind[1] \prover and \verifier compute $y'\gets\alpha y_L + y_R \cdot z \bmod p$, $\gr{c}' \gets \gr{c}_L^\alpha \times \gr{c}_R^q$. 
        \item \pcind[1] \pcind[1] \prover computes $f'(x) \gets \alpha \cdot f_L(x) + f_R(x) \cdot x \in \ZZ[x]$ 
        \item \pcind[1] \pcind[1] \prover and \verifier run $\pro{Eval}(\params, \gr{c}', z, y', d'; f'(x))$
        \end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\alaninline{Todo: correctness.}

\begin{lemma}
	The polynomial commitment scheme (\ref{scheme:polynomial_commitment}) is binding if the adaptive root assumption holds.
\end{lemma}
\begin{proof}
    Assume that there is an adversary that breaks the binding property of the scheme. Specifically, assume that some probabilistic polynomial time algorithm $\adv$ takes $(\params)$ and outputs $\gr{c}, f(x), f'(x), \hat{f}(x), \hat{f'}(x)$ such that with high probability $\pro{Open}(\params, \gr{c}, f(x); \hat{f}(x)) = \pro{Open}(\params, \gr{c}, f'(x), \hat{f'}(x)) = \top$ and $f(x) \neq f'(x)$. We proceed to show that this implies a violation of the adaptive root assumption~\ref{assum:adaptiveroot}.
    
	Let $\hat{h}(x)=\hat{f}(x)-\hat{f'}(x) \in \ZZ[X]$; this is a polynomial of degree at most $\max(f(x), f'(x))$. Since $\gr{g}^{\hat{f}(q)}=\gr{g}^{\hat{f'}(q)}=\gr{c}$ we have that $\gr{g}^{\hat{h}(q)}=1$. Note that the coefficients of $\hat{f}(x)$ and $\hat{f'}(x)$ are all less than $q/2$ in absolute value. By triangle inequality we have that the coefficients of $\hat{h}(x)$ are less than $q$. We have $\hat{f}(x) \neq \hat{f'}(x)$ because this inequality still holds modulo $p$, otherwise the adversary fails to open the commitment to two \emph{different} values. So $\hat{h}$ is not the zero polynomial. This implies that $\hat{h}(q) \neq 0$ and is a multiple of the order of $\gr{g} \in \GG$. Construct an adversary that breaks the adaptive root assumption (Assumption \ref{assum:adaptiveroot}) by outputting $\gr{g}$ in the first round, and by using $\hat{h}(q)$ to compute the inverse of $\ell$ modulo $\hat{h}(q)$.
\end{proof}

\begin{theorem}
	The polynomial commitment scheme (\ref{scheme:polynomial_commitment}) has extractability if the Fractional Root Assumption holds.
\end{theorem}\alan{Is it true that we don't need the order assumption?}
\begin{proof}
Suppose there is an adversary $\adv$ that breaks extractability with non-negligible probability $\gamma$. Assuming $\adv$ convinces the verifier with non-negligible probability, we proceed to build an algorithm violating the Fractional Root Assumption.

The proof works by induction on the sequence $d \mapsto d' = \left\lceil \frac{d+1}{2} \right\rceil - 1 \mapsto d'' = \left\lceil \frac{d'+1}{2} \right\rceil - 1 \mapsto \cdots \mapsto 0$ in reverse order. Specifically, at every step we unravel the innermost nesting of the recursion. We show that the following invariants hold at every iteration.
\begin{itemize}
    \itemsep0pt
    \item The coefficients of $f(x), f_L(x), f_R(x) \in \mathbb{Z}[x]$ lie in the interval $[-2^ip^{d_{\it max}}, 2^ip^{d_{\it max}}]$ in the $i$th induction step (starting at $i=0$).
    \item The polynomials $f_L(x)$ and $f_R(x)$ satisfy $f(x) = f_L(x) + f_R(x) \cdot x^{d'+1}$ and $\deg(f_L(x)) \leq d'$ and $\deg(f_R(x)) \leq d - d' - 1$.
    \item The commitment $\gr{c}$ satisfies $\gr{c} = \gr{g}^{f(q)}$.
    \item The commitments $\gr{c}, \gr{c}_L$, $\gr{c}_R$ and $\gr{c}_R^\star$ satisfy $\gr{c} = \gr{c}_L \times \gr{c}_R^\star$ and $\gr{c}_R^{q^{d'+1}} = \gr{c}_R^\star$ where $d' = \left\lceil \frac{d+1}{2} \right\rceil - 1$.
    \item The evaluation $y$ satisfies $f(z) = y \mod p$.
    \item The evaluations $y, y_R$ and $y_L$ satisfy $y = y_L + y_R \cdot z^{d'+1}$.
\end{itemize}

After the last step of the induction argument, the extractor is in possession of a degree-$d$ polynomial $f(x) \in \mathbb{Z}[x]$ such that $\gr{c} = \gr{g}^{f(q)}$ and $f(z) = y \mod p$. This situation contradicts the assumption that $\adv$ breaks extractability, so the extractor constructed here must fail at one of the identified points of possible failure --- any one of which leads to a violated assumption.

\underline{$d = 0$.} The extractor receives $\gr{c}$, $y = f(z) \mod p$ and $f_0 = f(x) \in \mathbb{Z}$. The checks performed in the $\pro{Open}$ protocol guarantee that the invariants are satisfied.

\underline{Induction step.} We denote by primes (\emph{e.g.}, $f'(x)$) the values of the previous iteration; variables without primes are those of the present one. The task is to show that if the invariants for $(f'(x), f_L'(x), f_R'(x), y', y_L', y_R', \gr{c}', \gr{c}_L', \gr{c}_R', {\gr{c}_R^{\star}}')$ are satisfied, then so are they satisfied for $(f(x), f_L(x), f_R(x), y, y_L, y_R, \gr{c}, \gr{c}_L, \gr{c}_R, \gr{c}_R^{\star})$. The extractor runs steps 11-19 with a different $\alpha''$, thereby obtaining the tuple $(f''(x), f_L''(x), f_R''(x), y'', y_L'', y_R'', \gr{c}'', \gr{c}_L'', \gr{c}_R'', {\gr{c}_R^{\star}}'')$. Let $b \in \{0,1\}$ indicate whether $d$ is odd, by assuming the value 1 when this is so.

Due to the way $\gr{c}', \gr{c}'', y', y''$ are constructed, we know that $\gr{c}'\gr{c}''^{-1} = \gr{c}_L^{\alpha' - \alpha''}$ as well as $y'-y'' = (\alpha' - \alpha'')y_L$, regardless of the value of $b$. The extractor uses $f'(x)-f''(x) = (\alpha' - \alpha'')f_L(x)$ to obtain $f_L(x)$. We distinguish three cases.
\begin{itemize}
    \itemsep0pt
    \item[1.] $(\alpha' - \alpha'')$ divides $f'(x) - f''(x)$. Then $f_L(x) = (f'(x) - f''(x)) / (\alpha' - \alpha'')$ is well defined and has coefficients bounded in absolute value by $p^{d_{\it max}}$. From here, the extractor computes $f_R(x) \leftarrow f'(x) - \alpha' \cdot f_L(x)$ coefficients bounded by $2p^{d_{\it max}}$ and $\gr{c}_R = \gr{g}^{f_R(q)}$ because $\gr{c}' = \gr{g}^{f'(q)} = \gr{g}^{\alpha' \cdot f_L(q) + f_R(q)} = \gr{c}_L^{\alpha'} \cdot \gr{c}_R$. This suffices establish that all the invariants are satisfied. \alan{Todo: don't forget to unshift $f_R(x)$ if $b=1$.}
    \item[2.] $(\alpha' - \alpha'')$ does not divide $f'(x) - f''(x)$ but does divide $f'(q) - f''(q)$. The coefficients of $f'(x) - f''(x)$ are bounded. This implies that $f'(q) - f''(q)$ denotes an integer distinct from zero.
    \item[] Let $f_{L,q} = (f'(q) - f''(q))/(\alpha' - \alpha'')$ and let $\{\tilde{f}_i\}_{i=0}^{d'}$ be its base-$q$ expansion, \emph{i.e.}, $f_{L,q} = \sum_{i=0}^{d'} \tilde{f}_i q^i$ with all $\tilde{f}_i \in \{0,\ldots,q-1\}$. Also, note that $\gr{g}^{f_{L,q}} = \gr{c}_L$. The extractor obtains a polynomial with coefficients bounded by $p^{d_{\it max}}$ by starting from $f_L(x) = \sum_{i=0}^{d'} \tilde{f}_i x^i$ and iterating over all powers $j$ from 0 to $d'-1$, and subtracting that unique multiple of $x^{j}(x-q)$ that sends the coefficient of $x^j$ to the interval $[-p^{d_{\it max}};p^{d_{\it max}}]$. There are two possible causes for failure.
    \begin{itemize}
        \item[2.1.] No polynomial $f_L(x) \in \mathbb{Z}[x]$ with bounded coefficients and satisfying $f_L(q) = f_{L,q}$ exists. Then at least one coefficient lies outside the interval $[-p^{d_{\it max}};p^{d_{\it max}}]$. As a result, with overwhelming probability, at least one coefficient of $\alpha \cdot f_L(x) + f_R(x)$ lies outside the magical interval for random $\alpha$. With overwhelming probability, the non-membership percolates to the terminal case where the coefficient $f_0$ is tested and this non-membership is observed, causing the verifier to reject the opening. As a result, if $f_L(x)$ does not exist, then the prover cannot have more than a negligible chance of success, in contradiction to the requirement for breaking the evaluation binding property.
        \item[2.2.] The polynomial $f_L(x)$ does exist and it does have bounded coefficients, but $f(z) \neq y_L \mod p$. Then with overwhelming probability $\alpha \cdot f_L(z) + f_R(z) \neq \alpha \cdot y_L + y_R$. With overwhelming probability this inequality percolates to the terminal case where $f_0 \neq y \mod p$ and the prover fails to convince the verifier. As a result, if $f_L(z) \neq y \mod p$ then the prover cannot have more than a negligible chance of success, in contradiction to the requirement for breaking the evaluation binding property.
    \end{itemize}
    \item[] We may therefore assume that $f_L(x) \in \mathbb{Z}[x]$ with bounded coefficients exists, and satisfies both $f_L(q) = f_{L,q}$ and $f_L(z) = y \mod p$. The extractor then computes $f_R(x) \leftarrow f'(x) - \alpha' \cdot f_L(x)$ which also has bounded coefficients. It follows that the induction invariants are satisfied.
    \item[3.] $(\alpha' - \alpha'')$ divides neither $f'(x) - f''(x)$ nor $f'(q) - f''(q)$. Then $\gr{c}_L$ is a $(\alpha' - \alpha'')$th root of $\gr{g}^{f'(q) - f''(q)} = \gr{c}'{\gr{c}''}^{-1}$ and outputting $(f'(q) - f''(q), \alpha'-\alpha'', \gr{c}_L)$ breaks the fractional root assumption. \alan{Todo: don't forget to unshift $f_R(x)$ if $b=1$.}
\end{itemize}
This completes the inductive argument, which in turn completes the proof.
\end{proof}

\begin{proof}
(SKETCH)
We prove the statement by showing that we can recursively either extract the encoding of an integer polynomial $f(x) \in \ZZ[X]$ of degree $d$ with bounded coefficients or a break of the pseudo root assumption for element $g$ or a non trivial element of known (random) order in $\GG$. We recurse over degree $\hat{d}$ up to the final degree $d$.
In each round the extracted witness is an integer $\hat{y}$ such that $\hat{y}=\enc(f(x))$ where the coefficients of $f(x)$ are less than $B$ in absolute value and the degree is at most $\hat{d}$ and such that $g^{\hat{y}}=C$. Also $f(z) \equiv y \mod p$.
If $\hat{d}=0$ then we can directly extract $f(x)=\hat{y}$ such that $\vert \hat{y} \vert < p^{\log_2(d+1)+1}$, $y=\hat{y}\mod p$, $f(x)=y\in \FF_p[X]$ and $g^{\hat{y}}=C$ as the witness. We proceed with $d=1$.
For $d>0$ we have $g^{\hat{y}}=C=C_0^{\alpha}C_1$. Rewinding once we get 
 $C=C_0^{\alpha}C_1=g^{\hat{y}}$ and $C'=C_0^{\alpha'}C_1=g^{\hat{y}'}$ for distinct $\alpha$ and $\alpha'$. 
 This gives us $C_0^{\alpha-\alpha'}=g^{\hat{y}-\hat{y}'}$. 
 Either $\alpha-\alpha' \not|~ \hat{y}-\hat{y}' $ which would directly break the pseudo root assumption or we can compute $D=g^{\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}}$. Either $D=C_0$ or $(D/C_0)^{\alpha-\alpha'}=1$, i.e. $D/C_0$ is an element of known order. In either of the cases the extraction succeeds and is completed. (Invoke order assumption).
 
 If $D=C_0$ then we have $\hat{y}_0=\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}$ and
 $g^{\hat{y}_0}=C_0$. In that case $C_1=g^{\hat{y}_1}=g^{\hat{y}-\alpha\hat{y}_0}$. The extractor has now successfully obtained $\hat{y}_0$ and $\hat{y}_1$
 
 If $|y|=|y'|<B$ then $|y_0|<  2 \cdot B$ and $|y_1|<|\hat{y}-\hat{y}+\alpha\hat{y}'|=|\alpha \hat{y}'|<\lambda \cdot B$. 
 We define $f(x)=\dec(y_0+x^{d} \cdot y_1)$ and with coefficients less than $2B$ in absolute value. 
 Note that $y_0=\hat{y}_0 \mod p=\dec(y_0)(z)$ and $y_1=\hat{y}_1 \mod p=\dec(y_1)(z)$. Since $y=\dec(\hat{y})(z)=\alpha \cdot \dec(\hat{y}_0)(z)+\dec(\hat{y}_1)(z)$ and $f(x)=\dec(y_0+x^{\hat{d}} \cdot y_1)$ we have that $y=y_0 +z^{\hat{d}/2}y_1 \mod p=f(z) \mod p$.
 Additionally $C=C_0^{\alpha}C_1=\commit(f(x))$ or we get a break of the adaptive root assumption.\benedikt{So this is technically a bit difficult because it's not actually a witeness}.
 
 The extractor recuses with the encoding of $f(x)$ and degree $\hat{d}'=\hat{d}\cdot 2$.
 
 Repeating this $\log_2(d+1)$ times we get a polynomial $f(x)$ of degree $d$ that has coefficients that are bounded by $(d+1) \cdot p^{\log_2(d+1)+1} <q/2$. 

\end{proof}

\begin{mdframed}[userdefinedwidth=0.8\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	\setup(\secpar,p,d,n):
		\begin{enumerate}[nolistsep]
			\item $ \GG \sample \ggen(\secpar)$
			\item $ g \sample \GG$
			\item $q\gets 2^k \text{s.t.} q>(d+1) \cdot 2\cdot p^{\log_2(d+1)+1} $
			\item $\pcreturn \crs=\{\secpar,p,\GG,g,q\}$
		\end{enumerate}
		$\commit(\crs,f(x)\in \ZZ[X])$ \pccomment{$f(x)$'s coefficients are \textcolor{blue}{in $[0,p-1]$}} 
		\begin{enumerate}[nolistsep]
			\item 	$f(q)\gets \enc(f(x)) \in \ZZ$
			\item \textcolor{blue}{$C \gets g^{f(q)}$}
			\item $\pcreturn \textcolor{blue}{C},f(q)$ \textcolor{blue}{Alan: why is including the degree necessary?}\benedikt{Probably commit should have a public and private output. I changed it but we need to think about this.}
		\end{enumerate}
		$\open(\crs,\textcolor{blue}{C},f(x)\in \ZZ[X])$ \pccomment{\textcolor{blue}{$f(x)$'s coefficients are in $[-q/2,q/2]$}} 
		\begin{enumerate}[nolistsep]
			\item $f(q)\gets \enc(f(x)) \in \ZZ$
			\item Prover sends $f(q),f(x)$ to verifier.
			\item Verifier checks that $\dec(f(q)) \mod p=f(x)$
			\item If $C=g^{f(q)}$ the verifier accepts.
		\end{enumerate}
	\end{flushleft}
	
\end{minipage}
\end{mdframed}

\begin{small}
 \begin{minipage}{1.1\textwidth}
\begin{mdframed}[userdefinedwidth=1\textwidth]  \label{prot:Opening}
	\noindent \underline{\textsf{Protocol \eval{} Information theoretic} (Polynomial evaluation)}\\
Inputs: $\enc(f(x)),z,y\in \FF_p,d \in \NN $\\
Witness: $f(x) \in \ZZ[X]$ of degree at most $d$ and with coefficients bounded by $p$ \textcolor{blue}{Alan: if it is bounded by $p$ then you cannot recurse, because the coefficients grow every step.}\footnote{We describe the protocol using an integer polynomial with bounded coefficient. This generalizes the case where the polynomial is in $\FF_p[X]$};\\ 
Claim: $f(x)\gets \dec(\enc(f(x))), y=f(z) \mod p$

\begin{enumerate}[nolistsep]
\item \pcif $d=0$:
\item \pcind[1] Prover sends $\hat{y}\gets \enc(f(x))$ to the verifier. 
\item \pcind[1] Verifier runs that $f(x)\gets \dec(\hat{y})$ and checks that  $f(z) \bmod p=y$, or rejects otherwise 
%\textcolor{blue}{Alan: not in the exponent of $p$?}, 
%right
\item \pcelse: 
\item \pcind[1] $d'\gets \frac{d+1}{2}-1$
\item \pcind[1] Prover computes $f_0(x)\gets\sum_{i=0}^{d'} f_i x^i\in \ZZ[x]$ and $f_1(x)\gets\sum_{i=0}^{d'} f_{d'+1+i} x^{i}\in \ZZ[x]$
\item \pcind[1] $y_0\gets f_0(z) \bmod p$, $y_1\gets f_1(z)\bmod p$
\item \pcind[1] Prover sends $y_0,y_1, \enc(f_0(x)),\enc(f_1(x))$ to the Verifier
\item \pcind[1] Verifier checks that $y_0+z^{d'+1} y_1=y\in \FF_p$ 
\item \pcind[1] Verifier checks that $\enc(f_0(x))+x^{d'+1}\cdot \enc(f_1(x))=\enc(f(x))$
\item \pcind[1] Verifier samples $\alpha \sample \FF_p$ and sends it to the prover
\item \pcind[1] Prover and Verifier compute $y'\gets\alpha y_0 +y_1 \bmod p$, $\enc(f'(x))\gets \alpha \cdot \enc(f_0(x)) +\enc(f_1(x))$. 
\item \pcind[1] Prover also computes $f'(x)\gets\alpha  \cdot f_0(x)+f_1(x) \in \ZZ[x]$ 
\item \pcind[1] Prover and Verifier run $\eval(\enc(f'(x),z,y',d';f'(x))$
\end{enumerate}
\end{mdframed}
\end{minipage}
\end{small}

\begin{small}
 \begin{minipage}{1.1\textwidth}
\begin{mdframed}[userdefinedwidth=1\textwidth]  \label{prot:Opening}
	\noindent \underline{\textsf{Protocol \eval} (Polynomial evaluation)}\\
\noindent Params: $\crs=\{\secpar,p,\GG,g,d_{\max},q\}$;\ \
Inputs: $C\in \GG,z,y\in \FF_p,d \in \NN $\\
Witness: $f(x) \in \ZZ[X]$ of degree at most $d$ and with coefficients bounded by $p$ \textcolor{blue}{Alan: if it is bounded by $p$ then you cannot recurse, because the coefficients grow every step.}\footnote{We describe the protocol using an integer polynomial with bounded coefficient. This generalizes the case where the polynomial is in $\FF_p[X]$};\\ 
Claim: $C=g^{f(q)},\deg(f)\leq d$ and $y=f(z) \mod p$

\begin{enumerate}[nolistsep]
\item \pcif $d=0$:
\item \pcind[1] Prover sends $f(x)$ to the verifier, $f(x)$ is a constant. 
\item \pcind[1] Verifier checks that $0\leq f(q)<  p^{\log_2(d+1)+1}$,  $f(z) \bmod p=y$ and $g^{f(q)}=C$, or rejects otherwise 
%\textcolor{blue}{Alan: not in the exponent of $p$?}, 
%right
\item \pcelse: 
\item \pcind[1] $d'\gets \frac{d+1}{2}-1$
\item \pcind[1] Prover computes $f_0(x)\gets\sum_{i=0}^{d'} f_i x^i\in \ZZ[x]$ and $f_1(x)\gets\sum_{i=0}^{d'} f_{d'+1+i} x^{i}\in \ZZ[x]$
\item \pcind[1] $y_0\gets f_0(z) \bmod p$, $y_1\gets f_1(z)\bmod p$, $C_0\gets g^{f_0(q)}$,$C_1\gets g^{f_1(q)}$
\item \pcind[1] Prover sends $y_0,y_1,C_0,C_1$ to the Verifier
\item \pcind[1] Verifier checks that $y_0+z^{d'+1} y_1=y\in \FF_p$ 
\item \pcind[1] Prover and Verifier engage in $\textsf{PoE}(C_1,C/C_0,q^{d'+1})$ to show that $C_0C_1^{(q^{d'+1})}=C$
\item \pcind[1] Verifier samples $\alpha \sample \FF_p$ and sends it to the prover
\item \pcind[1] Prover and Verifier compute $y'\gets\alpha y_0 +y_1 \bmod p$, $C'\gets C_0^{\alpha}C_1 \in \GG$. 
\item \pcind[1] Prover also computes $f'(x)\gets\alpha  \cdot f_0(x)+f_1(x) \in \ZZ[x]$ 
\item \pcind[1] Prover and Verifier run $\eval(C',z,y',d';f'(x))$
\end{enumerate}
\end{mdframed}
\end{minipage}
\end{small}

\subsection{Discussion and Optimizations}
\begin{enumerate}
	\item Precompute $g^{q^i}$ to use parallelism etc.
	\item SNARK without falsifiable assumptions
	\item First polynomial commitment scheme with constant size parameters
	\item join PoEs
	\item ZK
	\item early termination
\end{enumerate}

\subsection{Zero-Knowledge}

\subsection{Multivariate Commitment}
  We extend the Polynomial Commitment scheme to handle multivariate polynomials. The idea is to simply use higher degrees of $q$ to encode the polynomial. The protocol is linear in the number of variables and logarithmic in the total degree of the polynomial. For simplicity we only present a protocol for $n$-variate polynomials where the degree in each variable is $d$ and $d$ is a power of $2$. The protocol naturally extends to different degrees per variable.
We first define an encoding for multi-variate integer polynomials with small coefficients:
 \begin{itemize}
	\item Domain $B_{q/2}[X^n] \subset \ZZ[X^n]$, Alphabet: $\ZZ$, \\$f(x_0,\dots,x_{n-1})=\sum_{\vec{i} \in [0,d]^n} f_{\vec{i}} \prod_{j=1}^{n} x_j^{i_j}$
	\item $\enc(f(x_0,\dots,x_{n-1}) \in B_{q/2}[X^n]): f(q,q^{d+1},q^{(d+1)^2},\dots,q^{(d+1)^{n-1}})$
	\item $\textsf{Q-ary}(\vec{i}):\sum_{j=1}^{n} i_j\cdot (d+1)^{j-1}$
	\item $\dec(y \in \ZZ): f_{\vec{i}}=\frac{y \bmod q^{\textsf{Q-ary}(\vec{i})+1}-y \bmod q^{\textsf{Q-ary}(\vec{i})}}{q^{\textsf{Q-ary}(\vec{i})}} \forall \vec{i} \in [0,d]^n$
	\item \benedikt{Negative Coefficients?}

\end{itemize}
\begin{small}
 \begin{minipage}{1.1\textwidth}
\begin{mdframed}[userdefinedwidth=1\textwidth]  \label{prot:Opening}
	\noindent \underline{\textsf{Protocol \eval} (Polynomial evaluation)}\\
\noindent Params: $\crs=\{\secpar,p,\GG,g,d_{\max},n_{\max},q\}$;\ \
Inputs: $C\in \GG,z_1,\dots,z_n,y\in \FF_p,d \in \NN,n \in \NN $\\
Witness: $f(x_1,\dots,x_n) \in B_q[X^n]$ of degree at most d and with coefficients bounded by $p$\footnote{We describe the protocol using an integer polynomial with bounded coefficient. This generalizes the case where the polynomial is in $\FF_p[X^n]$};\\ 
Claim: $C=g^{f(q_1,q_2,\dots,q_n)}$ where $q_i=q^{(d_{\max}+1)^{i-1} },\deg(f)\leq d$ and $y=f(z_1,\dots,z_n) \mod p$

\begin{enumerate}[nolistsep]
\item \pcif $n=0 \wedge d=0$:
\item \pcind[1] Prover sends $f(x)$ to the verifier, $f(x)$ is a constant. 
\item \pcind[1] Verifier checks that $0\leq f(q)< p^{n_{\max}\cdot \log_2(d_{\max}+1)+1}$,  $f(z) \bmod p=y$ and $g^{f(q)}=C$ otherwise rejects
\item \pcelse: 
\item \pcind[1] $d'\gets \frac{d+1}{2}-1$
\item \pcind[1] Prover computes $f_0(x_1,\dots,x_n)\gets \sum_{\vec{i} \in [0,d_{\max}]^{n-1}}  \prod_{j=1}^{n-1} x_{j}^{i_j} \cdot(\sum_{k=0}^{d'} f_{\vec{i},k} x_{n}^k)\in \ZZ[X^n]$ and
$f_1(x_1,\dots,x_n)\gets \sum_{\vec{i} \in [0,d_{\max}]^{n-1}} \prod_{j=1}^{n-1} x_{j}^{i_j}(  \sum_{k=0}^{d'} f_{\vec{i},k+d'+1} x_{n}^{k})\in \ZZ[X^n]$
\item \pcind[1] $y_0\gets f_0(z_1,\dots,z_n) \bmod p$, $y_1\gets f_1(z_1,\dots,z_n)\bmod p$,\\ $C_0\gets g^{f_0(q_1,\dots,q_n)}$,$C_1\gets g^{f_1(q_1,\dots,q_n)}$
\item \pcind[1] Prover sends $y_0,y_1,C_0,C_1$ to the Verifier
\item \pcind[1] Verifier checks that $y_0+z_n^{d'+1} y_1=y\in \FF_p$ 
\item \pcind[1] Prover and Verifier engage in $\textsf{PoE}(C_1,C/C_0,q_n^{d'+1})$ to show that $C_0C_1^{q_n^{d'+1}}=C$
\item \pcind[1] Verifier samples $\alpha \sample \FF_p$ and sends it to the prover
\item \pcind[1] Prover and Verifier compute $y'\gets\alpha y_0 +y_1 \bmod p$, $C'\gets C_0^{\alpha}C_1 \in \GG$. \\Prover also computs $f'(x_1,\dots,x_n)\gets\alpha  \cdot f_0(x_1,\dots,x_n)+f_1(x_1,\dots,x_n) \in \ZZ[X^n]$ 
\item \pcind[1] \pcif $d=0$ and $n>0$: \pccomment{$f'$ is constant in $x_n$ so we write it as an $n-1$ variate polynomial.}
\item \pcind[2] $d'\gets d_{\max}$
\item \pcind[2] $n'\gets n-1$
\item \pcind[2] $\vec{z}\gets (z_1,\dots,z_{n-1})$
\item \pcind[1] Prover and Verifier run $\eval(C',\vec{z},y',d',n';f'(x))$
\end{enumerate}
\end{mdframed}
\end{minipage}
\end{small}

\subsection{Fix coefficients and negative degrees}
\begin{itemize}
	\item Several ways to do this.
\end{itemize}

\subsection{Range Proofs}

\subsection{Vector Commitments}

\subsection{Inner Product Argument}

\section{Security}

\begin{lemma}
	The pseudo root assumption holds in the generic group model.
\end{lemma}
\begin{lemma}
	The polynomial commitment scheme satisfies the opening binding property
\end{lemma}
\begin{proof}
	Assume $\hat{f}(x)$ and $\hat{f}'(x)$ are integer encodings of two distinct polynomials $f(x),f'(x) \in \FF_p[X]$. Assume that the adversary can open a commitment $C$ to both $f(x)$ and $f'(x)$. We show that we can use this adversary to break the pseudo root assumption (Assumption \ref{assum:fracroot}).
	
	 Then $\hat{h}(x)=\hat{f}(x)-\hat{f}'(x) \in \ZZ[X]$ is a polynomial of degree at most $d$. Since $g^{\hat{f}(q)}=g^{\hat{f}'(q)}=C$ we have that $g^{\hat{h}(q)}=1$. Note that the coefficients of $\hat{f}(x)$ and $\hat{f}'(x)$ are all less than $q/2$ in absolute value. By triangle inequality we have that $\hat{h}(x)$'s coefficients are less than $q$. $\hat{h}$ is by assumption not the zero polynomial. This implies that $\hat{h}(q)\neq 0$ is a multiple of the order of $g\in \GG$. This however can directly be used to break the adaptive root assumption (Assumption \ref{assum:adaptiveroot}) by taking the inverse of $\ell$ modulo $\hat{h}(q)$.
\end{proof}

\begin{theorem}
	The polynomial commitment scheme from Section \ref{sec:protocol} satisfies extraction under the Pseudo Root Assumption and the Order assumption. We show that we can either extract a pseudo root of $g$ or a witness \benedikt{Formally we should define witness extended emulation }
\end{theorem}
\begin{proof}
(SKETCH)
We prove the statement by showing that we can recursively either extract the encoding of an integer polynomial $f(x) \in \ZZ[X]$ of degree $d$ with bounded coefficients or a break of the pseudo root assumption for element $g$ or a non trivial element of known (random) order in $\GG$. We recurse over degree $\hat{d}$ up to the final degree $d$.
In each round the extracted witness is an integer $\hat{y}$ such that $\hat{y}=\enc(f(x))$ where the coefficients of $f(x)$ are less than $B$ in absolute value and the degree is at most $\hat{d}$ and such that $g^{\hat{y}}=C$. Also $f(z) \equiv y \mod p$.
If $\hat{d}=0$ then we can directly extract $f(x)=\hat{y}$ such that $\vert \hat{y} \vert < p^{\log_2(d+1)+1}$, $y=\hat{y}\mod p$, $f(x)=y\in \FF_p[X]$ and $g^{\hat{y}}=C$ as the witness. We proceed with $d=1$.
For $d>0$ we have $g^{\hat{y}}=C=C_0^{\alpha}C_1$. Rewinding once we get 
 $C=C_0^{\alpha}C_1=g^{\hat{y}}$ and $C'=C_0^{\alpha'}C_1=g^{\hat{y}'}$ for distinct $\alpha$ and $\alpha'$. 
 This gives us $C_0^{\alpha-\alpha'}=g^{\hat{y}-\hat{y}'}$. 
 Either $\alpha-\alpha' \not|~ \hat{y}-\hat{y}' $ which would directly break the pseudo root assumption or we can compute $D=g^{\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}}$. Either $D=C_0$ or $(D/C_0)^{\alpha-\alpha'}=1$, i.e. $D/C_0$ is an element of known order. In either of the cases the extraction succeeds and is completed. (Invoke order assumption).
 
 If $D=C_0$ then we have $\hat{y}_0=\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}$ and
 $g^{\hat{y}_0}=C_0$. In that case $C_1=g^{\hat{y}_1}=g^{\hat{y}-\alpha\hat{y}_0}$. The extractor has now successfully obtained $\hat{y}_0$ and $\hat{y}_1$
 
 If $|y|=|y'|<B$ then $|y_0|<  2 \cdot B$ and $|y_1|<|\hat{y}-\hat{y}+\alpha\hat{y}'|=|\alpha \hat{y}'|<\lambda \cdot B$. 
 We define $f(x)=\dec(y_0+x^{d} \cdot y_1)$ and with coefficients less than $2B$ in absolute value. 
 Note that $y_0=\hat{y}_0 \mod p=\dec(y_0)(z)$ and $y_1=\hat{y}_1 \mod p=\dec(y_1)(z)$. Since $y=\dec(\hat{y})(z)=\alpha \cdot \dec(\hat{y}_0)(z)+\dec(\hat{y}_1)(z)$ and $f(x)=\dec(y_0+x^{\hat{d}} \cdot y_1)$ we have that $y=y_0 +z^{\hat{d}/2}y_1 \mod p=f(z) \mod p$.
 Additionally $C=C_0^{\alpha}C_1=\commit(f(x))$ or we get a break of the adaptive root assumption.\benedikt{So this is technically a bit difficult because it's not actually a witeness}.
 
 The extractor recuses with the encoding of $f(x)$ and degree $\hat{d}'=\hat{d}\cdot 2$.
 
 Repeating this $\log_2(d+1)$ times we get a polynomial $f(x)$ of degree $d$ that has coefficients that are bounded by $(d+1) \cdot p^{\log_2(d+1)+1} <q/2$. 
 


\end{proof}

\begin{corollary}
	If $q<bla$ there exists an efficient adversary that can break the evaluation binding property of the polynomial commitment.
\end{corollary}
\benedikt{Figure out at what q we can attack the scheme. Probably needs to use negative coefficients and such.}

\section{Zero knowledge polynomial commitment} 
This section sketches how to make the polynomial commitment scheme zero knowledge. 

\paragraph{Commit} Let $g_1 \sample \GG$ be a random base distinct from $g$. 
The hiding polynomial commitment is $C \leftarrow g^{f(q)}g_1^r$ for $r \sample [-2^\lambda, 2^\lambda]$. 

\paragraph{Open} The opening of the entire polynomial is the same, but additionally gives the blinding factor $r$. 

\paragraph{Eval}

\begin{itemize}
\item In each recursive step we commit to polynomials $f_0$ and $f_1$ using the same hiding commitment scheme, where $f_0 + f_1 q^{d/2} = f$ as integer polynomials. 

\item Note that if $C_0 = g^{f_0(q)}g_1^{r_0}$ and $C_1 = g^{f_1(q)} g_1^{r_1}$ then $C_0 \cdot C_1^{q^{d/2}} = C \cdot g_1^{r'}$ where $r' = r_0 + q^{d/2} r_1$. The prover can give a non-interactive zk proof of this relation to the verifier using a sigma protocol. E.g., the prover provides $C_1' = C_1^{q^{d/2}}$ with a PoE, and then a zk-PoKE of $r'$ such that $g_1^{r'} = C_0 C_1' / C$. 

\item We could then recurse on $C_0^\alpha C_1$ which commits to $\alpha f_0 + f_1$ with the blinding factor $\alpha r_0 + r_1$. BUT we are not done yet, see next bullet point... 

\item The remaining problem is that the evaluation protocol opens $y_0 = f_0(z) \bmod p$ and $y_1 = f_1(z) \bmod p$, which is not zero knowledge. We need $y_0, y_1$ to be independently distributed subject to the constraint $y_0 + z^{d/2} y_1 = y \bmod p$, which the verifier checks. 

A solution is to modify $f_0$ and $f_1$ by adding constant terms $\alpha, \beta$ to each that cancel, i.e. $\alpha + z^{d/2} \beta = 0 \bmod p$, where $\alpha$ is uniformly distributed in $\ZZ_p$. This way the polynomials $f_0' = f_0 + \alpha$ and $f_1' = f_1 + \beta$ satisfy the relation $f_0'(z) + z^{d/2}f_1'(z) = f(z) \bmod p$. We end up revealing $y_0' = y_0 + \alpha \bmod p$ and $y_1' = y_1 + \beta \bmod p$, which is uniformly distributed in $\ZZ_p$ subject to $y_0' + y_1' = y \bmod p$. 

Finally, the prover needs to convince the verifier that it modified the $C_0$ and $C_1$ commitments appropriately. (It could not simply choose $f_0'$ and $f_1'$ in the first step because $f_0' + q^{d/2} f_1' \neq f$ as integer polynomials). 

However, the solution is still simple. The prover creates hiding commitments $C_\alpha$ to $\alpha$ and $C_\beta$ to $\beta$ and provides a zero-knowledge proof that $C_\alpha C_\beta ^{z^{d/2}}$ is a commitment to an integer multiple of $p$. This can be done efficiently through a combination of PoE and a PoKE. (Given $g^a$, to prove that $a = 0 \bmod p$ it suffices to provide $Q$ such that $Q^p = g^a$ and a PoKE for $Q$ base g. This can be made zero knowledge w/ the standard tricks). 

The protocol then proceeds on modified commitments $C_0' = C_0 C_\alpha$ and $C_1' = C_1 C_\beta$.

\end{itemize}

\section{Vector Commitment}


\subsection{Commitment Scheme}

In the following we denote by $(a_i)_{i=0}^{d-1} \in \mathbb{F}_p^{d}$ a vector of prime field elements. The vector commitment scheme is given by the following algorithms.
\begin{itemize}
\item $\mathsf{vcom} : \mathbb{F}_p^d \rightarrow \mathbb{G} \, , \quad (a_i)_{i=0}^{d-1} \mapsto g^{\sum_{i=0}^{d-1} a_iq^i} \enspace .$
\item $\mathsf{vopen} : \mathbb{G} \times \mathbb{Z} \rightarrow \mathbb{F}_p^d \cup \{\bot\} \, , $
\item[] $\phantom{\mathsf{vopen} :} (C, z = \sum_{i=0}^{d-1} z_iq^i) \mapsto \left\lbrace \begin{array}{ll}
(z_i \, \mathsf{mod} \, p)_{i=0}^{d-1} & \textnormal{\bf if } g^z = C \\
\quad \textnormal{where all } z_i \in \{0,\ldots,q-1\} & \\
\bot & \textnormal{\bf otherwise.}
\end{array} \right.$ 
\end{itemize}

Note: somewhat homomorphic properties: multiplication by constant, additivity. As long as coefficients don't overflow.

\subsection{Coordinate Extraction}

The following protocol enables the prover to extract a commitment to the $i$th component of the vector. Both Prover and Verifier know $i, g, C$. Only the prover knows an integer $z$ such that $g^z = C$ and corresponding to a vector $(a_j)_{j=0}^{d-1}$.
\begin{itemize}
\item Prover computes (or already knows) the $q$-ary expansion of $z$, \emph{i.e.}, $(z_j)_{j=0}^{d-1}$ such that $\sum_{j=0}^{d-1} z_j q^j = z$ and all $z_j \in \{0,\ldots, q-1\}$. He then sends to Verifier:
\begin{itemize}
\item $C_l = g^{\sum_{j=0}^{i-1} z_jq^j}, C_i = g^{z_i}, C_r = g^{\sum_{j=i+1}^{d-1} z_j q^{j-i-1}}$
\item $C_i^{q^i}, C_r^{q^{i+1}}$
\end{itemize}
\item Prover and Verifier run a proof of correct exponentiation to establish that $C_m^{q^i}, C_r^{q^{i+1}}$ were computed correctly.
\item Verifier checks that $C_l \times C_i^{q^i} \times C_r^{q^{i+1}} \stackrel{?}{=} C$ and aborts if false.
\item Prover and Verifier run a range proof to establish that the discrete logarithm of $C_l$ base $g$ is within the range $\{0, \ldots, q^i-1\}$.
\end{itemize}

Correctness, soundness, etc. (todo)

\subsection{Inner Product}
\label{section:inner_product}

The following protocol enables the prover to extract a commitment to the inner product $\mathbf{a}^\mathsf{T} \mathbf{s}$, where $\mathbf{a} = (a_i)_{i=0}^{d-1}$ is the vector to which $C$ is a commitment. The vector $\mathbf{s} \in \mathbb{F}_p^d$ is known to the verifier in the basic protocol, but later on we show how to hide this vector and simultaneously reduce the verifier's running time.
\begin{itemize}
\item Prover and Verifier flip $\mathbf{s}$ to obtain $\bar{\mathbf{s}} = (s_{d-1-i})_{i=0}^{d-1}$ and the matching integer encoding $z_{\bar{\mathbf{s}}} = \sum_{i=0}^{d-1} s_{d-1-i} q^i$.
\item Prover computes $C^{z_{\bar{\mathbf{s}}}}$ and sends this value to the verifier.
\item Prover and Verifier engage in a proof of correct exponentiation.
\item Prover and Verifier extract a commitment to coordinate $d$, which is exactly $\sum_{i=0}^{d-1} a_is_i$ modulo $p$.
\end{itemize}

Correctness, soundness, etc. (todo) Special attention for coefficient size.

Note that the Verifier must process all of $z_{\bar{\mathbf{s}}}$ in order to verify the exponentiation, which in particular is linear in $d$. However, it is possible to reduce this complexity and simultaneously hide the value of $z_{\bar{\mathbf{s}}}$. To do this, the prover must have committed to $z_{\bar{\mathbf{s}}}$ by sending $g^{z_{\bar{\mathbf{s}}}}$ (possibly with respect to a different base). At this point, a batched proof of knowledge of exponent establishes that the discrete logarithms of $C^{z_{\bar{\mathbf{s}}}}$ base $C$ and of $g^{z_{\bar{\mathbf{s}}}}$ base $g$ are equal.

\section{Illustration: QAP-based SNARK}

The next protocol describes an efficiently verifiable proof system for rank-one constraint satisfaction problems. Specifically, we start from a list of $m$ constraints of the form
\begin{equation} \label{equation:r1cs}
    \mathbf{a_i}^\mathsf{T} \mathbf{s} \times \mathbf{b}_i^\mathsf{T} \mathbf{s} = \mathbf{c_i}^\mathsf{T} \mathbf{s} \enspace ,
\end{equation}
where $\mathbf{s} \in \mathbb{F}_p^n$ is the secret witness and the $m$ triples $(\mathbf{a_i}, \mathbf{b_i}, \mathbf{c_i})_{i=0}^{m-1} \in \mathbb{F}_p^{3 \times m \times n}$ are the known parameters that define the constraints. Furthermore, $s_0 = 1$.

Translate this to a quadratic arithmetic program (QAP) by selecting $m$ arbitrary but different elements $\{e_0, \ldots, e_{m-1}\} \subset \mathbb{F}_p$ and defining $\mathbf{a}(x) \in \mathbb{F}^n[x]$ such that $\mathbf{a}(e_i) = \mathbf{a_i}$, and similarly for $\mathbf{b}(x)$ and $\mathbf{c}(x)$. Furthermore, set $h(x) = \prod_{i=0}^{m-1} (x-e_i)$. Then Equation~\ref{equation:r1cs} becomes
\begin{equation} \label{equation:qap_modular}
    \mathbf{a}(x)^\mathsf{T}\mathbf{s} \times \mathbf{b}(x)^\mathsf{T}\mathbf{s} \equiv \mathbf{c}(x)^\mathsf{T}\mathbf{s} \,\, \mathsf{mod} \,\, h(x) \enspace .
\end{equation}
Moreover, a prover knowledgeable of $\mathbf{s}$ can produce another polynomial $t(x)$ such that
\begin{equation} \label{equation:qap_explicit}
    \mathbf{a}(x)^\mathsf{T}\mathbf{s} \times \mathbf{b}(x)^\mathsf{T}\mathbf{s} = \mathbf{c}(x)^\mathsf{T}\mathbf{s} + t(x) \times h(x) \enspace .
\end{equation}

The proof establishes that the prover knows a vector $\mathbf{s}$ and a polynomial $h(x)$ such that Equation~\ref{equation:qap_explicit} is satisfied. Specifically:
\begin{itemize}
    \item Common input to Prover and Verifier: $A = \mathsf{vcom}(\mathbf{a}(x))$, $B = \mathsf{vcom}(\mathbf{b}(x))$, $C = \mathsf{vcom}(\mathbf{c}(x))$, $H = \mathsf{com}(h(x))$, and $D = \mathsf{vcom}((1 \, 0 \, \cdots \, 0)^\mathsf{T})$.
    \item Prover produces commitments $A_\mathbf{s} = \mathsf{com}(\mathbf{a}(x)^\mathsf{T} \mathbf{s})$, and similarly for $B_\mathbf{s}, C_\mathbf{s}$ with the inner product protocol of Section~\ref{section:inner_product}. Additionally, $D_\mathbf{s}$ is computed. All four inner product protocols are performed simultaneously, thereby establishing that the $\mathbf{s}$ used is the same in all four cases.
    \item Prover opens $D_\mathbf{s}$ to $1$, showing that $s_0$ is $1$.
    \item Prover multiplies $t(x)$ into $H$, thereby obtaining $H_t = \mathsf{com}(t(x) \times h(x))$.
    \item Prover and Verifier run a proof of knowledge of exponent.
    \item Prover multiplies $\mathbf{b}(x)^\mathsf{T} \mathbf{s}$ into $A_\mathbf{s}$, thereby obtaining $A_{\mathbf{s}B\mathbf{s}} = \mathsf{com}(\mathbf{a}(x)^\mathsf{T} \mathbf{s} \times \mathbf{b}(x)^\mathsf{T} \mathbf{s})$.
    \item Prover and Verifier run a proof of equal discrete logarithms showing that $A_{\mathbf{s}B\mathbf{s}}$ is to $A_\mathbf{s}$ as $B$ is to $g$.
    \item Verifier selects a random point, $z \xleftarrow{\$} \mathbb{F}_p$ and sends it to the prover.
    \item Prover and Verifier compute the weighted commitment $K = A_{\mathbf{s}B\mathbf{s}} \times C^{-1} \times H_T^{-1} = \mathsf{com}(\mathbf{a}(x)^\mathsf{T} \mathsf{s} \times \mathbf{b}(x)^\mathsf{T} \mathbf{s} - \mathbf{c}(x)^\mathsf{T} \mathbf{s} - h(x) \times t(x)) = \mathsf{com}(k(x))$
    \item Prover and Verifier run an evaluation proof establishing that $k(z) = 0$.
\end{itemize}

Note: we need to pay special attention to the size of the coefficients of $\mathbf{s}$ and of $t(x)$ are not too big. It is possible that the random selection of $z$ makes the prover who cheats by choosing larger coefficients overwhelmingly unlikely to succeed. Alternatively, we can devise a proof of small coefficients or something like that.

\section{Transparent Preprocessing SNARKs via Linear IOPs} 
\input{lineariop}

\section{Applications to Other Proof Systems}

\subsection{DARK-Sonic}

\subsection{DARK-Spartan}

\subsection{DARK-Bulletproofs}

\subsection{DARK-STARK}

\subsection{Comparison}

%\bibliography{cryptobib/references}
\bibliographystyle{alpha}
  \bibliography{cryptobib/crypto}

\appendix


\section{Protocols for Proving Permutations}


\subsection{Flip}

The following protocol establishes that two commitments, $c_a$ and $c_b$ represent polynomials $f_a, f_b \in \mathbb{F}_p$ (or vectors, for that matter) whose coefficients are flipped. Specifically, that $f_a = \sum_{i=0}^{d}f_i x^i$ for some coefficients $f_i$, and $f_b = \sum_{i=0}^df_ix^{d-i}$ for the same coefficients $f_i$.
Protocol:
\begin{itemize}
    \item Common knowledge: $c_a, c_b \in \mathbb{G}$.
    \item Verifier chooses $z \xleftarrow{\$} \mathbb{F}_p \backslash \{0\}$ and sends it to Prover.
    \item Prover and Verifier engage in proofs of correct evaluation producing $f_a(z)$ and $f_b(z^{-1})$, matching $c_a$ and $c_b$, respectively.
    \item Verifier checks that $f_a(z) \stackrel{?}{=} z^d f_b(z^{-1})$.
\end{itemize}

To see why it works, observe that $f_a(x) = x^df_b(x^{-1})$ and we can test this equation probabilistically by choosing a random $z \in \mathbb{F}_p \backslash \{0\}$ to evaluate $f_a$ and $f_b$ in. If $f_a$ is indeed the flipping of $f_b$ then the polynomial $F = f_a(x) - x^df_b(x^{-1})$ is identically zero; but otherwise it has at most $d$ zeros, and so the inequality will be exposed with overwhelming probability $(p-1-d)/(p-1)$.

\subsection{Rotation}

A similar observation gives rise to a proof of correct rotation. If $f(x) = \sum_{i=0}^d f_i x^i \in \mathbb{F}_p$ and $p(x) = \sum_{i=0}^d f_{i+r \, \mathsf{mod} \, d+1} x^i \in \mathbb{F}_p$ are polynomials consisting of the same coefficients but rotated by $r$ positions, then $p(x) = x^r f(x) \, \mathsf{mod} \, x^r - 1$ in all points. More explicitly, $p(x) = x^r f(x) + k(x) (x^r - 1)$ for some $k(x) \in \mathbb{F}_p$. The verifier can test this relation probabilistically.

\begin{itemize}
    \item Common knowledge: $c_f, c_p \in \mathbb{G}$ --- commitments to $f(x)$ and $p(x)$, respectively. Secret knowledge for the prover $f(x), p(x)$.
    \item Prover computes $k(x) = (p(x) - x^r f(x)) / x^r - 1$ and sends the commitment $c_k = g^{\hat{k}(q)}$ to it to Verifier.
    \item Verifier chooses a random point $z \xleftarrow{\$} \mathbb{F}_p$ and sends it to Prover.
    \item Prover and Verifier engage in proofs of correct evaluation for $f(z)$, $p(z)$, and $k(z)$.
    \item Verifier checks that $z^r f(z) + k(z) (z^r-1) = p(z)$.
\end{itemize}

\subsection{Generic Permutation}

The following protocol establishes that two polynomial commitments have the same coefficients but permuted according to a known permutation $\sigma : \{0,\ldots,d\} \rightarrow \{0,\ldots,d\}$. Specifically, $c_f$ is a commitment to $f(x) = \sum_{i=0}^d f_i x^i$ and $c_p$ is a commitment to $p(x) = \sum_{i=0}^d f_{\sigma(i)} x^i$. The proof makes use of the relation $p(x) = x^{\sigma(0)} f(x^{d+1}) - d(x)$ where $d(x) = \sum_{i=1}^d f_i (x^{i(d+1) + \sigma(0)} - x^{\sigma(i)})$. As $d(x)$ relies on the coefficients of $f(x)$, it is important to establish that $d(x)$ is correctly formed.

\begin{itemize}
    \item Common knowledge: $c_f, c_p, \sigma$ -- commitment to $f(x)$, commitment to $p(x)$, and permutation of coefficients.
    \item Secret knowledge for Prover: $f(x), p(x) \in \mathbb{F}_p$.
    \item Prover computes $n = \hat{f}(q^{d^2})$ and sends $c_n = g^n$ to Verifier.
    \item Prover and Verifier run an inner product protocol between $c_n$ and $(q^{di})_{i=0}^d$, and again between the result and $(q^i)_{i=0}^d$. This establishes that $n$ has the same coefficients as $c_f$ but spaced differently.
    \item Prover and Verifier run an inner product protocol between $c_n$ and $(q^{(i(d+1) + \sigma(0)} - q^{\sigma(i)})_{i=0}^d$ to compute $c_d$, the commitment to $d(x)$ that is well-formed wrt. $f(x)$.
    \item Verifier chooses a random point $z \xleftarrow{\$} \mathbb{F}_p$.
    \item Prover and Verifier engage in proofs of correct evaluation for $f(z), p(z), d(z)$.
    \item Verifier checks that $p(z) = z^{\sigma(0)} f(z^{d+1}) - d(z)$.
\end{itemize}


\end{document}
