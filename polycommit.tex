\documentclass{article}
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics]{cryptocode}
\usepackage{notations}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsmath,amsthm}
\usepackage[colorinlistoftodos]{todonotes}

%Theorems
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{fact}{Fact}
\newtheorem{corollary}{Corollary}

\newif\ifcomments
\commentstrue


\ifcomments
	\newcommand{\benedikt}[1]{{\textcolor{red}{[Benedikt: #1]}}}
	\newcommand{\alan}[1]{{\todo[color=blue!40!white]{Alan: #1}}}
	\newcommand{\alaninline}[1]{{\todo[color=blue!20!white, inline]{Alan: #1}}}
	\else
	\newcommand{\benedikt}[1]{}
	\newcommand{\alan}[1]{}
	\newcommand{\alaninline}[1]{}
	\fi

\begin{document}
\title{DARK Proof Systems}
\maketitle

\section*{Notes for Writing}
\begin{table}
    \caption{Notation}
    \label{tab:notation}
    \centering
    \begin{tabular}{l|l}
        symbol & meaning   \\ \hline \hline
        {\bf polynomials} & \\ \hline
        $f \in \mathbb{F}_p[x]$ & polynomial modulo $p$ \\
        $f_{(0)}, f_{(1)} \in \mathbb{F}_p[x]$ & first and second half of $f(x)$ \\
        $f_0, f_1, f_i \in \mathbb{F}_p$ & coefficients \emph{s.t.} $f(x) = \sum_{i=0}^d f_ix^i$ \\
        $\hat{f}(x) \in \mathbb{Z}[x]$ & polynomial with integer coefficients, typically in $\{0,\ldots,p-1\}$ \\ 
        $\hat{f}(q) \in \mathbb{Z}$ & integer encoding of a polynomial \\ \hline
        {\bf group elements} & (proposal by Alan) \\ \hline
        $\mathsf{g} \in \mathbb{G}$ & designated base element (the term ``generator'' is misleading) \\
        $\mathsf{c}, \mathsf{c}_0, \mathsf{c}_1 \in \mathbb{G}$ & commitments \\
        $\mathsf{c}_0^a \times \mathsf{c}_1^b, \, a, b \in \mathbb{Z}$ & multiplicative notation \\ \hline
        {\bf schemes} & (proposal by Alan) {actually, I don't really like this anymore} \\ \hline
        $\mathbf{Commit}_{\mathbb{A}} : \mathbb{A} \rightarrow \mathbb{G}$ & commit to an element from algebra $\mathbb{A}$. \\
         & This notation allows stacking algebras, $\emph{e.g.}$, $\mathbf{Commit}_{(\mathbb{F}_p[x]_{\leq d})^n}$ \\
        $\mathbf{Open}_\mathbb{A} : \{0,1\}^* \times \mathbb{G} \rightarrow \mathbb{A} \cup \{\bot\}$ & open a commitment by providing the decommitment information \\
         & (in the basic scheme: an integer) and the commitment; if the pro- \\
         & vided input is invalid, the function outputs $\bot$.\\
    \end{tabular}
\end{table}

\subsection*{Structure:}
\begin{itemize}
    \item introduction
    \item tools
    \begin{itemize}
        \item syntax of poly/vector commitment
        \item construction: poly/vector commitment
        \item eval (log / const size)
        \item coeff extract (log / const size)
        \item inner product (log/ const size)
        \item permutations: flip, rotate, generic
    \end{itemize}
    \item illustration: simple QAP
    \item proof systems
    \begin{itemize}
        \item short paragraph for each of:
        \item sonic
        \item spartan
        \item bulletproof
        \item stark
        \item other?
        \item[+] comparison
    \end{itemize}
\end{itemize}

\clearpage

\section{Introduction}

A polynomial commitment scheme enables a prover to bind himself to a polynomial in much less bandwidth than transmitting all coefficients would require. A skeptical verifier can subsequently test the commitment for certain algebraic relations as though he were in possession of the polynomial's full description, except at a much smaller work cost. Indeed, polynomial commitments lie at the heart of a host of efficiently verifiable interactive proof systems.

Of particular interest to this paper are proof systems whereby the prover establishes the correct performance of an arbitrary computation (that may or may not involve secret information) in such a way that the communication or verification complexity scales asymptotically better than performing the computation na√Øvely. Without exception, these proof systems rely on a technique called \emph{arithmetization}: characterizing the computation in question as a collection of arithmetic operations over a finite field. The utility of polynomial commitments stems from their capacity to succinctly capture a canonical representation of such collections while retaining the algebraic properties that make arithmetization work in the first place.

The literature on proof systems for arbitrary computations focuses on two techniques to achieve polynomial commitments. First: Merkle trees --- here every leaf represents the polynomial's evaluation in a given point, and the Merkle root represents the commitment to the polynomial. The verifier operates by opening selected points, which can be done in logarithmic space and time (as a function of the number of points). Second: groups equipped with bilinear maps --- in this case a structured reference (SRS)\footnote{Previously known as \emph{common reference string}, CRS.} string provides the values of all monomials up to a given degree when evaluated in an unknown point. By computing a weighted sum of these monomial values, the prover obtains the evaluation of his polynomial in the unknown point. The verifier performs the pairing operation to verify that multiplicative relations hold between committed polynomials.

This paper provides a third option for generating polynomial commitment schemes, namely by relying on groups of unknown order --- such as the group of integers with multiplication modulo an RSA modulus of unknown factorization, or the ideal class group of an order of an imaginary quadratic number field. These groups have seen relatively little adoption or even attention from the cryptographic community because the only known constructions thereof have subexponential attack algorithms. As a result, for a practical security level, elements of groups of unknown order typically require several hundreds of bytes to represent, in contrast to the tens of bytes needed for elements of elliptic curves for which no subexponential algorithms exist. 

Nevertheless, groups of unknown order provide a property that groups of known order, such as elliptic curve groups, cannot match: they enable homomorphic  commitments to an \emph{infinite} domain, namely the integers. Indeed, if the prover were capable of reducing a large integer to a smaller one without sacrificing the homomorphic properties, then he must know the group's order. The power of integer commitments was already noted by Lipmaa~\cite{} who characterizes proof systems arising therefrom as \emph{Diophantine} --- a reference to the family of languages for which such proof systems establish. Specifically, a set $S \subset \mathbb{Z}^n$ is called \emph{Diophantine} if it is the projection onto the first $n \leq m$ coordinates of the set of roots to a polynomial $P(x_1, \ldots, x_m) \in \mathbb{Z}[x_1, \ldots, x_m]$. Much more recently, Wesolowski produced a conceptually simple verifiable delay function (VDF) which builds on a proof of correct exponentiation in groups of unknown order. Boneh \emph{et al.} developed accumulators and vector commitments (with batch openings) from groups of unknown order and a variant of Wesolowski's proof of correct exponentiation~\cite{}.


Our contribution:

 - polynomial commitments with groups of unknown order
 - efficiently verifiable evaluation proofs
 - interactive proofs for arbitrary computation based on SONIC
 -- constant-size SRS
 -- no trusted setup (class group)
 -- trusted setup independent of circuit (RSA)

Related work:
	
	-Kate et al.
	-Sonic
\section{Preliminaries}
\paragraph{Notation}
\begin{itemize}
\item Let $f(x) \in \mathbb{F}_p[x]$ be a polynomial of degree at most $N-1$ where $N$ is a power of two. The coefficients of $f(x)$ are denoted by $f_i$ such that $f(x) \stackrel{\triangle}{=} \sum_{i=0}^{N-1} f_i x^i$.
\item $p$ is a prime.
\item We work in a group $\mathbb{G}$ of unknown order (\emph{e.g.} an ideal class group) with a designated base element $g \in \mathbb{G}$ with unknown order. (It might be tempting refer to this element as the \emph{generator} but that terminology would imply that $\mathbb{G}$ is cyclic, which is not necessarily true.) We use multiplicative notation.
\item Let $q \in \mathbb{N}$ be an integer with $q \gg p$.
\item $\textbf{Protocol}_{A,B}(x;w)$ denotes an interactive public coin protocol with common input $x$ and B's private input $w$
\end{itemize}

\subsection{Assumptions}
The security of the scheme relies on the fractional root assumption which is a generalization of the strong RSA assumption. The assumption\alaninline{``this assumption'' is the strong RSA assumption or the fractional root assumption?} states that an adversary cannot compute fractional roots of random group elements. B\"unz, Boneh and Fisch \cite{journals/iacr/BonehBF18a} show that this assumption is satisfied in the generic group model.  
\begin{assumption}[Pseudo root assumption]
\label{assum:fracroot}
The pseudo root assumption holds for $\ggen$ if for any efficient adversary $\adv$:
\[        
                \Pr\left[y^\beta = g^{\alpha} \wedge  \beta \not\vert~ \alpha   : 
                \begin{array}{l} 
                      \GG \sample \ggen(\lambda) \\ 
                      g \sample \GG \\
                      (\alpha, \beta, y) \sample \adv(\GG, g) \\
                      \quad \textnormal{where} \, \alpha, \beta \in \ZZ \, \textnormal{and} \, y \in \GG 
                \end{array} 
        \right] \leq \negl.
\]
\end{assumption}
We now define a security games for polynomial commitments

\subsection{Polynomial Commitments}

\alaninline{Kate \emph{et al.} define a polynomial commitment scheme as a tuple of 6 algorithms $(\mathsf{Setup},\mathsf{Commit},\mathsf{Open},\mathsf{VerifyPoly},\mathsf{CreateWitness},\mathsf{VerifyEval})$. There is a difference between verifying a commitment and opening it. The proof-of-correct-evaluation is a ``witness''. Proving and verifying are given by non-interactive algorithms.}
\alaninline{Sonic defines a polynomial commitment scheme as a tuple $(\mathsf{Commit}, \mathsf{Open}, \mathsf{pvC})$. The generation of the public parameters is not part of the polynomial commitment scheme. There is no special decommitment information; the $\mathsf{Commit}$ function takes a polynomial $f(x)$ and $\mathsf{Open}$ takes \emph{the same} polynomial. The algorithm $\mathsf{Open}$ outputs the evaluation $f(z)$ along with a proof; this proof is verified by $\mathsf{pcV}$.}

\begin{definition}[Polynomial Commitment see \cite{AC:KatZavGol10} ]
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocols $\open$ and $\eval$ is secure interactive if it satisfies the following properties:
\paragraph{Correctness}
For an honest prover $\prover$ and a public coin honest verifier $\verifier$, is correct if for all polynomials $f(x)\in \ZZ_p[X]$ with degree polynomial in $\lambda$ and evaluation points $z\in \FF_p$:
	\[        
                \Pr\left[\begin{array}{c}\open_{\prover,\verifier}(\crs,f(x),C)=\text{"accept"}\\
                \eval_{\prover,\verifier}(\crs,C,z,y;f(x))=\text{"accept"}
                \end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, \deg(p(x)) \\
                      C\gets \commit(\crs,f(x))]\\
               z\sample \FF_p\\
                      y\gets f(z) \in \FF_p
                \end{array} 
        \right] =1.
\]
\benedikt{ok to mesh them together?}
\paragraph{Opening Binding}
\alaninline{This property is called ``polynomial binding'' in Kate \emph{et al.}}
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocol $\open$, is opening binding if for all polynomial degrees $d=\poly\in \NN$ and for any efficient adversary $\adv$ and honest verifier $\verifier$:

	\[        
                \Pr\left[\begin{array}{c}\open_{\adv,\verifier}(\crs,C,f(x))=\text{"accept"}\\
                \wedge\\
           \open_{\adv,\verifier}(\crs,C,g(x))=\text{"accept"}\\
                \wedge\\
                f(x)\neq g(x) \vee \deg(f(x))\neq d\end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      (C,z,f(x),g(x))\sample \adv(\crs)]
                \end{array} 
        \right] \leq \negl.
\]
\paragraph{Evaluation Binding}
	\[        
                \Pr\left[\begin{array}{c}\eval_{\adv,\verifier}(\crs,z,y_0,C)=\text{"accept"}\\
                \wedge\\
                \eval_{\adv,\verifier}(\crs,z,y_1,C)=\text{"accept"}\\
                \wedge\\
                y_0\neq y_1\end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      (C,z,y_0,y_1)\sample \adv(\crs)]
                \end{array} 
        \right] \leq \negl.
\]
\end{definition}
Note that technically a complete $\eval$ protocol suffices as one can always open a polynomial by evaluating it at $\deg(f(x))+1$ points.

We additionally require a stronger extraction property that had in different variations been defined by \cite{SP:ZGKPP17} and \cite{EPRINT:MBKM19}.
\begin{definition}[PolyCommit extraction]
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocol $\eval$, is extractable if there exists a rewinding \benedikt{Define more properly}extractor $\extractor$ such that for all polynomial degrees $d=\poly\in \NN$ and for any efficient adversary $\adv$:
	\[        
                \Pr\left[\begin{array}{c}\eval_{\adv,\verifier}(\crs,C,z,y)=\text{"accept"}\\
                \wedge\\
                f(x)\gets\extractor^{<\eval_{\adv,\verifier}(\crs,C,z,y)>}(\crs,C)\in \FF_p[X]\\
                \wedge\\
               \commit(f(x))\neq C\vee f(z)\neq y \vee \deg(f)\neq d
                 \end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      \tau \sample (0,1)^\lambda\\
                      (C,z,y)\sample \adv_1(\crs,\tau)]
                      
                \end{array} 
        \right] \leq \negl.
\]
\end{definition}
\begin{lemma}[Extraction soundness]
	A polynomial commitment scheme that satisfies opening binding as well as extraction also satisfies evaluation binding.
\end{lemma}
\begin{proof}
	(SKETCH) Assume an adversary $\adv_{\eval}$ can break the evaluation binding property with non negligible probability $\gamma$. Using the extractor $\extractor$ we will construct an adversary $\adv_\open$ that will break the opening binding property with non-negligible probability. Run $\adv_\eval$ to get $(C,z,y_1,y_2)$. Now using $\ext$ we extract polynomials $f(x)$ and $g(x)$ of degree $d$ with all but negligible probability. Note that $f(z)=y_1$ and $g(z)=y_2$. This means $f(x)\neq g(x)$ but since $C=\commit(f(x))=\commit(g(x))$ we have a break of the opening binding property.
\end{proof}


\subsection{Proofs of Exponentiation}
Wesolowski \cite{EC:Wesolowski19} in his work on efficient verifiable delay functions introduced a simple yet powerful proof of exponentiation in groups of unknown order. A prover can efficiently convince a verifier that a large exponentiation in a group of unknown order was done correctly. The verifier needs to do little more than read the exponent. If the exponent is smooth then the protocol takes constant space/time in the security parameter.
\benedikt{Describe PoE protocol}
Boneh et al. \cite{journals/iacr/BonehBF18a} built on top of PoE to also develop PoKEs. \benedikt{Finish this section}
\section{Protocol}
\label{sec:protocol}

\subsection{Polynomial Encoding}

	Consider the set $P_q\subset \ZZ[X]$ of integer polynomials with coefficients whose absolute value is less than $q/2$. $p(q) \in \ZZ$ for $p(x)\in P_q$ is a unique encoding of the polynomial:
\begin{itemize}
	\item Domain $P_q \subset \ZZ[X]$, Alphabet: $\ZZ$
	\item $\enc(p(x) \in X): p(q)$
	\item $\dec(y \in \ZZ): p_i=\frac{y \mod q^{i+1}-y \mod q^{i}}{q^i} \forall i \in [0,\lfloor\log_q(y)\rfloor]$\\
	$p(x)=\sum_{i=0}^{\lfloor\log_q(y)\rfloor} p_i x^i$
\end{itemize}

\begin{fact}
	The polynomial encoding scheme is uniquely decodable.
\end{fact}

Note that the encoding has limited homomorphic properties. $\enc(g(x))+\enc(h(x))=\enc(g(x)+h(x))$ if $g(x)+h(x)\in P_q$, i,.e. all its coefficients are less than $q/2$ in absolute value. This is ensured if for example the coefficients of $g$ and $h$ are less than $q/4$. Additionally $\enc(g(x))\cdot \enc(h(x))=\enc(g(x)\cdot h(x))$ if $g(x)\cdot h(x)\in P_q$.
\subsection{Polynomial Commitment}
 For now we assume that the degree $d$ is always a power of two. We describe the commitment scheme for integer polynomials with coefficients bounded in absolute value by $p$. The scheme naturally extends for polynomials in $\FF_p$.

\begin{mdframed}[userdefinedwidth=0.8\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	\setup(\secpar,p,d):
		\begin{enumerate}[nolistsep]
			\item $ \GG \sample \ggen(\secpar)$
			\item $ g \sample \GG$
			\item $q\gets 2^k \text{s.t.} q>(d+1) \cdot 2\cdot p^{\log_2(d+1)+1} $
			\item $\pcreturn \crs=\{\secpar,p,\GG,g,q\}$
		\end{enumerate}
		$\commit(\crs,f(x)\in \ZZ[X])$ \pccomment{$f(x)$'s coefficients are \textcolor{blue}{in $\{0,\ldots,p-1\}$}} 
		\begin{enumerate}[nolistsep]
			\item 	$f(q)\gets \enc(f(x)) \in \ZZ$
			\item \textcolor{blue}{$C \gets g^{f(q)}$}
			\item $\pcreturn \textcolor{blue}{C},\deg(f)$ \textcolor{blue}{Alan: why is including the degree necessary?}
		\end{enumerate}
		$\open(\crs,\textcolor{blue}{C},f(x)\in \ZZ[X])$ \pccomment{\textcolor{blue}{$f(x)$'s coefficients are in $\{0,\ldots,q-1\}$}} 
		\begin{enumerate}[nolistsep]
			\item $f(q)\gets \enc(f(x)) \in \ZZ$
			\item Prover sends $f(q),f(x)$ to verifier.
			\item Verifier checks that $\dec(f(q)) \mod p=f(x)$
			\item If $C=g^{f(q)}$ the verifier accepts.
		\end{enumerate}
	\end{flushleft}
	
\end{minipage}
\end{mdframed}
\begin{small}
 \begin{minipage}{1.1\textwidth}
\begin{mdframed}[userdefinedwidth=1\textwidth]  \label{prot:Opening}
	\noindent \underline{\textsf{Protocol \eval} (Polynomial evaluation)}\\
\noindent Params: $\crs=\{\secpar,p,\GG,g,d_{\max},q\}$;\ \
Inputs: $C\in \GG,z,y\in \FF_p,d \in \NN $\\
Witness: $f(x) \in \ZZ[X]$ of degree at most $d$ and with coefficients bounded by $p$ \textcolor{blue}{Alan: if it is bounded by $p$ then you cannot recurse, because the coefficients grow every step.}\footnote{We describe the protocol using an integer polynomial with bounded coefficient. This generalizes the case where the polynomial is in $\FF_p[X]$};\\ 
Claim: $C=g^{f(q)},\deg(f)\leq d$ and $y=f(z) \mod p$

\begin{enumerate}[nolistsep]
\item \pcif $d=0$:
\item \pcind[1] Prover sends $f(x)$ to the verifier, $f(x)$ is a constant. 
\item \pcind[1] Verifier checks that $0\leq f(q)< (\log_2(d+1)+1)\cdot p$ \textcolor{blue}{Alan: not in the exponent of $p$?},  $f(z) \bmod p=y$ and $g^{f(q)}=C$, or rejects otherwise
\item \pcelse: 
\item \pcind[1] $d'\gets \frac{d+1}{2}-1$
\item \pcind[1] Prover computes $f_0(x)\gets\sum_{i=0}^{d'} f_i x^i\in \ZZ\textcolor{blue}{[x]}$ and $f_1(x)\gets\sum_{i=0}^{d'} f_{d'+1+i} x^{i}\in \ZZ\textcolor{blue}{[x]}$
\item \pcind[1] $y_0\gets f_0(z) \bmod p$, $y_1\gets f_1(z)\bmod p$, $C_0\gets g^{f_0(q)}$,$C_1\gets g^{f_1(q)}$
\item \pcind[1] Prover sends $y_0,y_1,C_0,C_1$ to the Verifier
\item \pcind[1] Verifier checks that $y_0+z^{d'+1} y_1=y\in \FF_p$ 
\item \pcind[1] Prover and Verifier engage in $\textsf{PoE}(C_1,C/C_0,q^{d'+1})$ to show that $C_0C_1^{(q^{d'+1})}=C$
\item \pcind[1] Verifier samples $\alpha \sample \FF_p$ and sends it to the prover
\item \pcind[1] Prover and Verifier compute $y'\gets\alpha y_0 +y_1 \bmod p$, $C'\gets C_0^{\alpha}C_1 \in \GG$. 
\item \pcind[1] Prover also computes $f'(x)\gets\alpha  \cdot f_0(x)+f_1(x) \in \ZZ[x]$ 
\item \pcind[1] Prover and Verifier run $\eval(C',z,y',d';f'(x))$
\end{enumerate}
\end{mdframed}
\end{minipage}
\end{small}

\subsection{Discussion and Optimizations}
\begin{enumerate}
	\item Precompute $g^{q^i}$ to use parallelism etc.
	\item SNARK without falsifiable assumptions
	\item First polynomial commitment scheme with constant size parameters
	\item Instead of sending $C_0$ and $C_1$ the prover can simply send $C_0$ and compute $C_1=C/(C_0^{q^{\frac{d}{2}}})$. Using a non-interactive PoE this means that $C_1=C/(Q^{\ell}g^r)$
\end{enumerate}

\subsection{Multivariate Commitment}
  
\subsection{Fix coefficients and negative degrees}
\begin{itemize}
	\item Several ways to do this.
\end{itemize}

\subsection{Range Proofs}

\section{Security}

\begin{lemma}
	The pseudo root assumption holds in the generic group model.
\end{lemma}
\begin{lemma}
	The polynomial commitment scheme satisfies the opening binding property
\end{lemma}
\begin{proof}
	Assume $f(x)$ and $g(x)$ are integer encodings of two distinct polynomials $f(x),p(x) \in \FF_p[X]$. Then $\hat{h}(x)=\hat{f}(x)-\hat{g}(x) \in \ZZ[X]$ is a polynomial of degree at most $d$. Since $g^{\hat{g}(q)}=g^{\hat{f}(q)}=C$ we have that $g^{\hat{h}(q)}=1$\benedikt{Change generator base name}. Note that the coefficients of $g(x)$ and $h(x)$ are all less than $q/2$ in absolute value. By triangle inequality we have that $\hat{h}(x)$ are less than $q$. $\hat{h}$ is by assumption not the zero polynomial. This implies that $\hat{h}(q)\neq 0$ is a multiple of the order of $g\in \GG$. This however can directly be used to break the pseudo root assumption (Assumption \ref{assum:fracroot}) by taking the inverse of an integer mod $h(q)$.
\end{proof}

\begin{theorem}
	The polynomial commitment scheme from Section \ref{sec:protocol} satisfies extraction under the Pseudo Root Assumption and the Order assumption. We show that we can either extract a pseudo root of $g$ or a witness \benedikt{Formally we should define witness extended emulation }
\end{theorem}
\begin{proof}
(SKETCH)
We prove the statement by showing that we can recursively either extract the encoding of an integer polynomial $f(x) \in \ZZ[X]$ of degree $d$ with bounded coefficients or a break of the pseudo root assumption for element $g$ or a non trivial element of known (random) order in $\GG$. We recurse over degree $\hat{d}$ up to the final degree $d$.
In each round the extracted witness is an integer $\hat{y}$ such that $\hat{y}=\enc(f(x))$ where the coefficients of $f(x)$ are less than $B$ in absolute value and the degree is at most $\hat{d}$ and such that $g^{\hat{y}}=C$. Also $f(z) \equiv y \mod p$.
If $\hat{d}=0$ then we can directly extract $f(x)=\hat{y}$ such that $\vert \hat{y} \vert < p^{\log_2(d+1)+1}$, $y=\hat{y}\mod p$, $f(x)=y\in \FF_p[X]$ and $g^{\hat{y}}=C$ as the witness. We proceed with $d=1$.
For $d>0$ we have $g^{\hat{y}}=C=C_0^{\alpha}C_1$. Rewinding once we get 
 $C=C_0^{\alpha}C_1=g^{\hat{y}}$ and $C'=C_0^{\alpha'}C_1=g^{\hat{y}'}$ for distinct $\alpha$ and $\alpha'$. 
 This gives us $C_0^{\alpha-\alpha'}=g^{\hat{y}-\hat{y}'}$. 
 Either $\alpha-\alpha' \not|~ \hat{y}-\hat{y}' $ which would directly break the pseudo root assumption or we can compute $D=g^{\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}}$. Either $D=C_0$ or $(D/C_0)^{\alpha-\alpha'}=1$, i.e. $D/C_0$ is an element of known order. In either of the cases the extraction succeeds and is completed. (Invoke order assumption).
 
 If $D=C_0$ then we have $\hat{y}_0=\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}$ and
 $g^{\hat{y}_0}=C_0$. In that case $C_1=g^{\hat{y}_1}=g^{\hat{y}-\alpha\hat{y}_0}$. The extractor has now successfully obtained $\hat{y}_0$ and $\hat{y}_1$
 
 If $|y|=|y'|<B$ then $|y_0|<  2 \cdot B$ and $|y_1|<|\hat{y}-\hat{y}+\alpha\hat{y}'|=|\alpha \hat{y}'|<\lambda \cdot B$. 
 We define $f(x)=\dec(y_0+x^{d} \cdot y_1)$ and with coefficients less than $2B$ in absolute value. 
 Note that $y_0=\hat{y}_0 \mod p=\dec(y_0)(z)$ and $y_1=\hat{y}_1 \mod p=\dec(y_1)(z)$. Since $y=\dec(\hat{y})(z)=\alpha \cdot \dec(\hat{y}_0)(z)+\dec(\hat{y}_1)(z)$ and $f(x)=\dec(y_0+x^{\hat{d}} \cdot y_1)$ we have that $y=y_0 +z^{\hat{d}/2}y_1 \mod p=f(z) \mod p$.
 Additionally $C=C_0^{\alpha}C_1=\commit(f(x))$ or we get a break of the adaptive root assumption.\benedikt{So this is technically a bit difficult because it's not actually a witeness}.
 
 The extractor recuses with the encoding of $f(x)$ and degree $\hat{d}'=\hat{d}\cdot 2$.
 
 Repeating this $\log_2(d+1)$ times we get a polynomial $f(x)$ of degree $d$ that has coefficients that are bounded by $(d+1) \cdot p^{\log_2(d+1)+1} <q/2$. 
 


\end{proof}

\begin{corollary}
	If $q<bla$ there exists an efficient adversary that can break the evaluation binding property of the polynomial commitment.
\end{corollary}
\benedikt{Figure out at what q we can attack the scheme. Probably needs to use negative coefficients and such.}

  \bibliography{references,cryptobib/abbrev0,cryptobib/crypto}

\section{Zero knowledge polynomial commitment} 
This section sketches how to make the polynomial commitment scheme zero knowledge. 

\paragraph{Commit} Let $g_1 \sample \GG$ be a random base distinct from $g$. 
The hiding polynomial commitment is $C \leftarrow g^{f(q)}g_1^r$ for $r \sample [-2^\lambda, 2^\lambda]$. 

\paragraph{Open} The opening of the entire polynomial is the same, but additionally gives the blinding factor $r$. 

\paragraph{Eval}

\begin{itemize}
\item In each recursive step we commit to polynomials $f_0$ and $f_1$ using the same hiding commitment scheme, where $f_0 + f_1 q^{d/2} = f$ as integer polynomials. 

\item Note that if $C_0 = g^{f_0(q)}g_1^{r_0}$ and $C_1 = g^{f_1(q)} g_1^{r_1}$ then $C_0 \cdot C_1^{q^{d/2}} = C \cdot g_1^{r'}$ where $r' = r_0 + q^{d/2} r_1$. The prover can give a non-interactive zk proof of this relation to the verifier using a sigma protocol. E.g., the prover provides $C_1' = C_1^{q^{d/2}}$ with a PoE, and then a zk-PoKE of $r'$ such that $g_1^{r'} = C_0 C_1' / C$. 

\item We could then recurse on $C_0^\alpha C_1$ which commits to $\alpha f_0 + f_1$ with the blinding factor $\alpha r_0 + r_1$. BUT we are not done yet, see next bullet point... 

\item The remaining problem is that the evaluation protocol opens $y_0 = f_0(z) \bmod p$ and $y_1 = f_1(z) \bmod p$, which is not zero knowledge. We need $y_0, y_1$ to be independently distributed subject to the constraint $y_0 + z^{d/2} y_1 = y \bmod p$, which the verifier checks. 

A solution is to modify $f_0$ and $f_1$ by adding constant terms $\alpha, \beta$ to each that cancel, i.e. $\alpha + z^{d/2} \beta = 0 \bmod p$, where $\alpha$ is uniformly distributed in $\ZZ_p$. This way the polynomials $f_0' = f_0 + \alpha$ and $f_1' = f_1 + \beta$ satisfy the relation $f_0'(z) + z^{d/2}f_1'(z) = f(z) \bmod p$. We end up revealing $y_0' = y_0 + \alpha \bmod p$ and $y_1' = y_1 + \beta \bmod p$, which is uniformly distributed in $\ZZ_p$ subject to $y_0' + y_1' = y \bmod p$. 

Finally, the prover needs to convince the verifier that it modified the $C_0$ and $C_1$ commitments appropriately. (It could not simply choose $f_0'$ and $f_1'$ in the first step because $f_0' + q^{d/2} f_1' \neq f$ as integer polynomials). 

However, the solution is still simple. The prover creates hiding commitments $C_\alpha$ to $\alpha$ and $C_\beta$ to $\beta$ and provides a zero-knowledge proof that $C_\alpha C_\beta ^{z^{d/2}}$ is a commitment to an integer multiple of $p$. This can be done efficiently through a combination of PoE and a PoKE. (Given $g^a$, to prove that $a = 0 \bmod p$ it suffices to provide $Q$ such that $Q^p = g^a$ and a PoKE for $Q$ base g. This can be made zero knowledge w/ the standard tricks). 

The protocol then proceeds on modified commitments $C_0' = C_0 C_\alpha$ and $C_1' = C_1 C_\beta$.

\end{itemize}

\section{Vector Commitment}


\subsection{Commitment Scheme}

In the following we denote by $(a_i)_{i=0}^{d-1} \in \mathbb{F}_p^{d}$ a vector of prime field elements. The vector commitment scheme is given by the following algorithms.
\begin{itemize}
\item $\mathsf{vcom} : \mathbb{F}_p^d \rightarrow \mathbb{G} \, , \quad (a_i)_{i=0}^{d-1} \mapsto g^{\sum_{i=0}^{d-1} a_iq^i} \enspace .$
\item $\mathsf{vopen} : \mathbb{G} \times \mathbb{Z} \rightarrow \mathbb{F}_p^d \cup \{\bot\} \, , $
\item[] $\phantom{\mathsf{vopen} :} (C, z = \sum_{i=0}^{d-1} z_iq^i) \mapsto \left\lbrace \begin{array}{ll}
(z_i \, \mathsf{mod} \, p)_{i=0}^{d-1} & \textnormal{\bf if } g^z = C \\
\quad \textnormal{where all } z_i \in \{0,\ldots,q-1\} & \\
\bot & \textnormal{\bf otherwise.}
\end{array} \right.$ 
\end{itemize}

Note: somewhat homomorphic properties: multiplication by constant, additivity. As long as coefficients don't overflow.

\subsection{Coordinate Extraction}

The following protocol enables the prover to extract a commitment to the $i$th component of the vector. Both Prover and Verifier know $i, g, C$. Only the prover knows an integer $z$ such that $g^z = C$ and corresponding to a vector $(a_j)_{j=0}^{d-1}$.
\begin{itemize}
\item Prover computes (or already knows) the $q$-ary expansion of $z$, \emph{i.e.}, $(z_j)_{j=0}^{d-1}$ such that $\sum_{j=0}^{d-1} z_j q^j = z$ and all $z_j \in \{0,\ldots, q-1\}$. He then sends to Verifier:
\begin{itemize}
\item $C_l = g^{\sum_{j=0}^{i-1} z_jq^j}, C_i = g^{z_i}, C_r = g^{\sum_{j=i+1}^{d-1} z_j q^{j-i-1}}$
\item $C_i^{q^i}, C_r^{q^{i+1}}$
\end{itemize}
\item Prover and Verifier run a proof of correct exponentiation to establish that $C_m^{q^i}, C_r^{q^{i+1}}$ were computed correctly.
\item Verifier checks that $C_l \times C_i^{q^i} \times C_r^{q^{i+1}} \stackrel{?}{=} C$ and aborts if false.
\item Prover and Verifier run a range proof to establish that the discrete logarithm of $C_l$ base $g$ is within the range $\{0, \ldots, q^i-1\}$.
\end{itemize}

Correctness, soundness, etc. (todo)

\subsection{Inner Product}
\label{section:inner_product}

The following protocol enables the prover to extract a commitment to the inner product $\mathbf{a}^\mathsf{T} \mathbf{s}$, where $\mathbf{a} = (a_i)_{i=0}^{d-1}$ is the vector to which $C$ is a commitment. The vector $\mathbf{s} \in \mathbb{F}_p^d$ is known to the verifier in the basic protocol, but later on we show how to hide this vector and simultaneously reduce the verifier's running time.
\begin{itemize}
\item Prover and Verifier flip $\mathbf{s}$ to obtain $\bar{\mathbf{s}} = (s_{d-1-i})_{i=0}^{d-1}$ and the matching integer encoding $z_{\bar{\mathbf{s}}} = \sum_{i=0}^{d-1} s_{d-1-i} q^i$.
\item Prover computes $C^{z_{\bar{\mathbf{s}}}}$ and sends this value to the verifier.
\item Prover and Verifier engage in a proof of correct exponentiation.
\item Prover and Verifier extract a commitment to coordinate $d$, which is exactly $\sum_{i=0}^{d-1} a_is_i$ modulo $p$.
\end{itemize}

Correctness, soundness, etc. (todo) Special attention for coefficient size.

Note that the Verifier must process all of $z_{\bar{\mathbf{s}}}$ in order to verify the exponentiation, which in particular is linear in $d$. However, it is possible to reduce this complexity and simultaneously hide the value of $z_{\bar{\mathbf{s}}}$. To do this, the prover must have committed to $z_{\bar{\mathbf{s}}}$ by sending $g^{z_{\bar{\mathbf{s}}}}$ (possibly with respect to a different base). At this point, a batched proof of knowledge of exponent establishes that the discrete logarithms of $C^{z_{\bar{\mathbf{s}}}}$ base $C$ and of $g^{z_{\bar{\mathbf{s}}}}$ base $g$ are equal.

\subsection{Protocols for Proving Permutations}


\subsubsection{Flip}

The following protocol establishes that two commitments, $c_a$ and $c_b$ represent polynomials $f_a, f_b \in \mathbb{F}_p$ (or vectors, for that matter) whose coefficients are flipped. Specifically, that $f_a = \sum_{i=0}^{d}f_i x^i$ for some coefficients $f_i$, and $f_b = \sum_{i=0}^df_ix^{d-i}$ for the same coefficients $f_i$.
Protocol:
\begin{itemize}
    \item Common knowledge: $c_a, c_b \in \mathbb{G}$.
    \item Verifier chooses $z \xleftarrow{\$} \mathbb{F}_p \backslash \{0\}$ and sends it to Prover.
    \item Prover and Verifier engage in proofs of correct evaluation producing $f_a(z)$ and $f_b(z^{-1})$, matching $c_a$ and $c_b$, respectively.
    \item Verifier checks that $f_a(z) \stackrel{?}{=} z^d f_b(z^{-1})$.
\end{itemize}

To see why it works, observe that $f_a(x) = x^df_b(x^{-1})$ and we can test this equation probabilistically by choosing a random $z \in \mathbb{F}_p \backslash \{0\}$ to evaluate $f_a$ and $f_b$ in. If $f_a$ is indeed the flipping of $f_b$ then the polynomial $F = f_a(x) - x^df_b(x^{-1})$ is identically zero; but otherwise it has at most $d$ zeros, and so the inequality will be exposed with overwhelming probability $(p-1-d)/(p-1)$.

\subsubsection{Rotation}

A similar observation gives rise to a proof of correct rotation. If $f(x) = \sum_{i=0}^d f_i x^i \in \mathbb{F}_p$ and $p(x) = \sum_{i=0}^d f_{i+r \, \mathsf{mod} \, d+1} x^i \in \mathbb{F}_p$ are polynomials consisting of the same coefficients but rotated by $r$ positions, then $p(x) = x^r f(x) \, \mathsf{mod} \, x^r - 1$ in all points. More explicitly, $p(x) = x^r f(x) + k(x) (x^r - 1)$ for some $k(x) \in \mathbb{F}_p$. The verifier can test this relation probabilistically.

\begin{itemize}
    \item Common knowledge: $c_f, c_p \in \mathbb{G}$ --- commitments to $f(x)$ and $p(x)$, respectively. Secret knowledge for the prover $f(x), p(x)$.
    \item Prover computes $k(x) = (p(x) - x^r f(x)) / x^r - 1$ and sends the commitment $c_k = g^{\hat{k}(q)}$ to it to Verifier.
    \item Verifier chooses a random point $z \xleftarrow{\$} \mathbb{F}_p$ and sends it to Prover.
    \item Prover and Verifier engage in proofs of correct evaluation for $f(z)$, $p(z)$, and $k(z)$.
    \item Verifier checks that $z^r f(z) + k(z) (z^r-1) = p(z)$.
\end{itemize}

\subsubsection{Generic Permutation}

The following protocol establishes that two polynomial commitments have the same coefficients but permuted according to a known permutation $\sigma : \{0,\ldots,d\} \rightarrow \{0,\ldots,d\}$. Specifically, $c_f$ is a commitment to $f(x) = \sum_{i=0}^d f_i x^i$ and $c_p$ is a commitment to $p(x) = \sum_{i=0}^d f_{\sigma(i)} x^i$. The proof makes use of the relation $p(x) = x^{\sigma(0)} f(x^{d+1}) - d(x)$ where $d(x) = \sum_{i=1}^d f_i (x^{i(d+1) + \sigma(0)} - x^{\sigma(i)})$. As $d(x)$ relies on the coefficients of $f(x)$, it is important to establish that $d(x)$ is correctly formed.

\begin{itemize}
    \item Common knowledge: $c_f, c_p, \sigma$ -- commitment to $f(x)$, commitment to $p(x)$, and permutation of coefficients.
    \item Secret knowledge for Prover: $f(x), p(x) \in \mathbb{F}_p$.
    \item Prover computes $n = \hat{f}(q^{d^2})$ and sends $c_n = g^n$ to Verifier.
    \item Prover and Verifier run an inner product protocol between $c_n$ and $(q^{di})_{i=0}^d$, and again between the result and $(q^i)_{i=0}^d$. This establishes that $n$ has the same coefficients as $c_f$ but spaced differently.
    \item Prover and Verifier run an inner product protocol between $c_n$ and $(q^{(i(d+1) + \sigma(0)} - q^{\sigma(i)})_{i=0}^d$ to compute $c_d$, the commitment to $d(x)$ that is well-formed wrt. $f(x)$.
    \item Verifier chooses a random point $z \xleftarrow{\$} \mathbb{F}_p$.
    \item Prover and Verifier engage in proofs of correct evaluation for $f(z), p(z), d(z)$.
    \item Verifier checks that $p(z) = z^{\sigma(0)} f(z^{d+1}) - d(z)$.
\end{itemize}

\section{Illustration: QAP-based SNARK}

The next protocol describes an efficiently verifiable proof system for rank-one constraint satisfaction problems. Specifically, we start from a list of $m$ constraints of the form
\begin{equation} \label{equation:r1cs}
    \mathbf{a_i}^\mathsf{T} \mathbf{s} \times \mathbf{b}_i^\mathsf{T} \mathbf{s} = \mathbf{c_i}^\mathsf{T} \mathbf{s} \enspace ,
\end{equation}
where $\mathbf{s} \in \mathbb{F}_p^n$ is the secret witness and the $m$ triples $(\mathbf{a_i}, \mathbf{b_i}, \mathbf{c_i})_{i=0}^{m-1} \in \mathbb{F}_p^{3 \times m \times n}$ are the known parameters that define the constraints. Furthermore, $s_0 = 1$.

Translate this to a quadratic arithmetic program (QAP) by selecting $m$ arbitrary but different elements $\{e_0, \ldots, e_{m-1}\} \subset \mathbb{F}_p$ and defining $\mathbf{a}(x) \in \mathbb{F}^n[x]$ such that $\mathbf{a}(e_i) = \mathbf{a_i}$, and similarly for $\mathbf{b}(x)$ and $\mathbf{c}(x)$. Furthermore, set $h(x) = \prod_{i=0}^{m-1} (x-e_i)$. Then Equation~\ref{equation:r1cs} becomes
\begin{equation} \label{equation:qap_modular}
    \mathbf{a}(x)^\mathsf{T}\mathbf{s} \times \mathbf{b}(x)^\mathsf{T}\mathbf{s} \equiv \mathbf{c}(x)^\mathsf{T}\mathbf{s} \,\, \mathsf{mod} \,\, h(x) \enspace .
\end{equation}
Moreover, a prover knowledgeable of $\mathbf{s}$ can produce another polynomial $t(x)$ such that
\begin{equation} \label{equation:qap_explicit}
    \mathbf{a}(x)^\mathsf{T}\mathbf{s} \times \mathbf{b}(x)^\mathsf{T}\mathbf{s} = \mathbf{c}(x)^\mathsf{T}\mathbf{s} + t(x) \times h(x) \enspace .
\end{equation}

The proof establishes that the prover knows a vector $\mathbf{s}$ and a polynomial $h(x)$ such that Equation~\ref{equation:qap_explicit} is satisfied. Specifically:
\begin{itemize}
    \item Common input to Prover and Verifier: $A = \mathsf{vcom}(\mathbf{a}(x))$, $B = \mathsf{vcom}(\mathbf{b}(x))$, $C = \mathsf{vcom}(\mathbf{c}(x))$, $H = \mathsf{com}(h(x))$, and $D = \mathsf{vcom}((1 \, 0 \, \cdots \, 0)^\mathsf{T})$.
    \item Prover produces commitments $A_\mathbf{s} = \mathsf{com}(\mathbf{a}(x)^\mathsf{T} \mathbf{s})$, and similarly for $B_\mathbf{s}, C_\mathbf{s}$ with the inner product protocol of Section~\ref{section:inner_product}. Additionally, $D_\mathbf{s}$ is computed. All four inner product protocols are performed simultaneously, thereby establishing that the $\mathbf{s}$ used is the same in all four cases.
    \item Prover opens $D_\mathbf{s}$ to $1$, showing that $s_0$ is $1$.
    \item Prover multiplies $t(x)$ into $H$, thereby obtaining $H_t = \mathsf{com}(t(x) \times h(x))$.
    \item Prover and Verifier run a proof of knowledge of exponent.
    \item Prover multiplies $\mathbf{b}(x)^\mathsf{T} \mathbf{s}$ into $A_\mathbf{s}$, thereby obtaining $A_{\mathbf{s}B\mathbf{s}} = \mathsf{com}(\mathbf{a}(x)^\mathsf{T} \mathbf{s} \times \mathbf{b}(x)^\mathsf{T} \mathbf{s})$.
    \item Prover and Verifier run a proof of equal discrete logarithms showing that $A_{\mathbf{s}B\mathbf{s}}$ is to $A_\mathbf{s}$ as $B$ is to $g$.
    \item Verifier selects a random point, $z \xleftarrow{\$} \mathbb{F}_p$ and sends it to the prover.
    \item Prover and Verifier compute the weighted commitment $K = A_{\mathbf{s}B\mathbf{s}} \times C^{-1} \times H_T^{-1} = \mathsf{com}(\mathbf{a}(x)^\mathsf{T} \mathsf{s} \times \mathbf{b}(x)^\mathsf{T} \mathbf{s} - \mathbf{c}(x)^\mathsf{T} \mathbf{s} - h(x) \times t(x)) = \mathsf{com}(k(x))$
    \item Prover and Verifier run an evaluation proof establishing that $k(z) = 0$.
\end{itemize}

Note: we need to pay special attention to the size of the coefficients of $\mathbf{s}$ and of $t(x)$ are not too big. It is possible that the random selection of $z$ makes the prover who cheats by choosing larger coefficients overwhelmingly unlikely to succeed. Alternatively, we can devise a proof of small coefficients or something like that.

\section{Applications to Other Proof Systems}

\subsection{DARK-Sonic}

\subsection{DARK-Spartan}

\subsection{DARK-Bulletproofs}

\subsection{DARK-STARK}

\subsection{Comparison}

\end{document}
