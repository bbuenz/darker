\documentclass{article}
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics]{cryptocode}
\usepackage{notations}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsmath,amsthm}

%Theorems
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{fact}{Fact}
\newtheorem{corollary}{Corollary}

\newif\ifcomments
\commentstrue


\ifcomments
	\newcommand{\benedikt}[1]{{\textcolor{red}{[Benedikt: #1]}}}
		\newcommand{\alan}[1]{{\textcolor{blue}{[Alan: #1]}}}

	\else
	\newcommand{\benedikt}[1]{}
	\newcommand{\alan}[1]{}
	\fi

\begin{document}
\title{RSA-based Polynomial Commitment}
\maketitle

\section{Introduction}

interactive proof systems for arbitrary computation

 - zero-knowledge proofs
 - arithmetization
 - polynomial relations
 
circuit model: QAP and Groth16 NILP

 - construction
 - used algebra
 - advantages and disadvantages
 
Turing model: STARK

 - construction
 - used algebra
 - advantages and disadvantages

Class group

 - groups of unknown order
 - vdfs / accumulators

Our contribution:

 - polynomial commitments with groups of unknown order
 - efficiently verifiable evaluation proofs
 - interactive proofs for arbitrary computation

Related work:
	
	-Kate et al.
	-Sonic
\section{Preliminaries}
\paragraph{Notation}
\begin{itemize}
\item Let $f(x) \in \mathbb{F}_p[x]$ be a polynomial of degree at most $N-1$ where $N$ is a power of two. The coefficients of $f(x)$ are denoted by $f_i$ such that $f(x) \stackrel{\triangle}{=} \sum_{i=0}^{N-1} f_i x^i$.
\item In general elements with a hat e.g. $\hat{y}$ denote integers and elements without it denote elements in prime field $\FF_p$ or the corresponding polynomial rings.
\item $p$ is a prime.
\item We work in a group $\mathbb{G}$ of unknown order (\emph{e.g.} an ideal class group) with a designated base element $g \in \mathbb{G}$ with unknown order. (It might be tempting refer to this element as the \emph{generator} but that terminology would imply that $\mathbb{G}$ is cyclic, which is not necessarily true.) We use multiplicative notation.
\item Let $q \in \mathbb{N}$ be an integer with $q \gg p$.
\item $\textbf{Protocol}_{A,B}(x;w)$ denotes an interactive public coin protocol with common input $x$ and B's private input $w$
\end{itemize}

\subsection{Assumptions}
The security of the scheme relies on the fractional root assumption which is a generalization of the strong RSA assumption. The assumption states that an adversary cannot compute fractional roots of random group elements. B\"unz, Boneh and Fisch \cite{journals/iacr/BonehBF18a} show that this assumption is satisfied in the generic group model.  
\begin{assumption}[Pseudo root assumption]
\label{assum:fracroot}
The pseudo root assumption holds for $\ggen$ if for any efficient adversary $\adv$:
\[        
                \Pr\left[y^\beta = g^{\alpha} \wedge  \beta \not\vert~ \alpha   : 
                \begin{array}{l} 
                      \GG \sample \ggen(\lambda) \\ 
                      g \sample \GG \\
                      \alpha, \beta \in \ZZ,y\in \GG \sample \adv(\GG, g) 
                \end{array} 
        \right] \leq \negl.
\]
\end{assumption}
We now define a security games for polynomial commitments

\subsection{Polynomial Commitments}
\begin{definition}[Polynomial Commitment see \cite{AC:KatZavGol10} ]
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocols $\open$ and $\eval$ is secure interactive if it satisfies the following properties:
\paragraph{Correctness}
For an honest prover $\prover$ and a public coin honest verifier $\verifier$, is correct if for all polynomials $f(x)\in \ZZ_p[X]$ with degree polynomial in $\lambda$ and evaluation points $z\in \FF_p$:
	\[        
                \Pr\left[\begin{array}{c}\open_{\prover,\verifier}(\crs,f(x),C)=\text{"accept"}\\
                \eval_{\prover,\verifier}(\crs,C,z,y;f(x))=\text{"accept"}
                \end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, \deg(p(x)) \\
                      C\gets \commit(\crs,f(x))]\\
               z\sample \FF_p\\
                      y\gets f(z) \in \FF_p
                \end{array} 
        \right] =1.
\]
\benedikt{ok to mesh them together?}
\paragraph{Opening Binding}
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocol $\open$, is opening binding if for all polynomial degrees $d=\poly\in \NN$ and for any efficient adversary $\adv$ and honest verifier $\verifier$:

	\[        
                \Pr\left[\begin{array}{c}\open_{\adv,\verifier}(\crs,C,f(x))=\text{"accept"}\\
                \wedge\\
           \open_{\adv,\verifier}(\crs,C,g(x))=\text{"accept"}\\
                \wedge\\
                f(x)\neq g(x) \vee \deg(f(x))\neq d\end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      (C,z,f(x),g(x))\sample \adv(\crs)]
                \end{array} 
        \right] \leq \negl.
\]
\paragraph{Evaluation Binding}
	\[        
                \Pr\left[\begin{array}{c}\eval_{\adv,\verifier}(\crs,z,y_0,C)=\text{"accept"}\\
                \wedge\\
                \eval_{\adv,\verifier}(\crs,z,y_1,C)=\text{"accept"}\\
                \wedge\\
                y_0\neq y_1\end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      (C,z,y_0,y_1)\sample \adv(\crs)]
                \end{array} 
        \right] \leq \negl.
\]
\end{definition}
Note that technically a complete $\eval$ protocol suffices as one can always open a polynomial by evaluating it at $\deg(f(x))+1$ points.

We additionally require a stronger extraction property that had in different variations been defined by \cite{SP:ZGKPP17} and \cite{EPRINT:MBKM19}.
\begin{definition}[PolyCommit extraction]
We say a polynomial commitment scheme, consisting of algorithms $(\setup,\commit)$ and the interactive protocol $\eval$, is extractable if there exists a rewinding \benedikt{Define more properly}extractor $\extractor$ such that for all polynomial degrees $d=\poly\in \NN$ and for any efficient adversary $\adv$:
	\[        
                \Pr\left[\begin{array}{c}\eval_{\adv,\verifier}(\crs,C,z,y)=\text{"accept"}\\
                \wedge\\
                f(x)\gets\extractor^{<\eval_{\adv,\verifier}(\crs,C,z,y)>}(\crs,C)\in \FF_p[X]\\
                \wedge\\
               \commit(f(x))\neq C\vee f(z)\neq y \vee \deg(f)\neq d
                 \end{array}  : 
                \begin{array}{l} 
                      \crs \sample \setup(\lambda, d) \\
                      \tau \sample (0,1)^\lambda\\
                      (C,z,y)\sample \adv_1(\crs,\tau)]
                      
                \end{array} 
        \right] \leq \negl.
\]
\end{definition}
\begin{lemma}[Extraction soundness]
	A polynomial commitment scheme that satisfies opening binding as well as extraction also satisfies evaluation binding.
\end{lemma}
\begin{proof}
	(SKETCH) Assume an adversary $\adv_{\eval}$ can break the evaluation binding property with non negligible probability $\gamma$. Using the extractor $\extractor$ we will construct an adversary $\adv_\open$ that will break the opening binding property with non-negligible probability. Run $\adv_\eval$ to get $(C,z,y_1,y_2)$. Now using $\ext$ we extract polynomials $f(x)$ and $g(x)$ of degree $d$ with all but negligible probability. Note that $f(z)=y_1$ and $g(z)=y_2$. This means $f(x)\neq g(x)$ but since $C=\commit(p(x))=\commit(g(x))$ we have a break of the opening binding property.
\end{proof}
\section{Protocol}
\label{sec:protocol}

\subsection{Polynomial Encoding}

	Consider the set $P_q\subset \ZZ[X]$ of integer polynomials with coefficients whose absolute value is less than $q/2$. $p(q) \in \ZZ$ for $p(x)\in P_q$ is a unique encoding of the polynomial:
\begin{itemize}
	\item Domain $P_q \subset \ZZ[X]$, Alphabet: $\ZZ$
	\item $\enc(p(x) \in X): p(q)$
	\item $\dec(y \in \ZZ): p_i=\frac{y \mod q^{i+1}-y \mod q^{i}}{q^i} \forall i \in [0,\lfloor\log_q(y)\rfloor]$\\
	$p(x)=\sum_{i=0}^{\lfloor\log_q(y)\rfloor} p_i x^i$
\end{itemize}

\begin{fact}
	The polynomial encoding scheme is uniquely decodable.
\end{fact}

Note that the encoding has limited homomorphic properties. $\enc(g(x))+\enc(h(x))=\enc(g(x)+h(x))$ if $g(x)+h(x)\in P_q$, i,.e. all its coefficients are less than $q/2$ in absolute value. This is ensured if for example the coefficients of $g$ and $h$ are less than $q/4$. Additionally $\enc(g(x))\cdot \enc(h(x))=\enc(g(x)\cdot h(x))$ if $g(x)\cdot h(x)\in P_q$.
\subsection{Polynomial Commitment}
 For now we assume that the degree $d$ is always a power of two

\begin{mdframed}[userdefinedwidth=0.8\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	\setup(\secpar,p,d):
		\begin{enumerate}[nolistsep]
			\item $ \GG \sample \ggen(\secpar)$
			\item $ g \sample \GG$
			\item $q\gets 2^k \text{s.t.} q>(d+1) \cdot 2\cdot p^{\log_2(d+1)+1} $
			\item $\pcreturn \crs=\{\secpar,p,\GG,g,q\}$
		\end{enumerate}
		$\commit(\crs,p(x)\in \FF_p[X])$
		\begin{enumerate}[nolistsep]
			\item 	$\hat{f}(x)\gets f(x) \in \ZZ[X]$
			\item $y\gets \hat{f}(q)$
			\item $\pcreturn g^y,\deg(f)$
		\end{enumerate}
		$\open(\crs,p(x)\in \FF_p[X])$
		\begin{enumerate}[nolistsep]
			\item Prover computes the integer encoding of $p$ $\hat{f}(x)\gets p(x) \in \ZZ[X]$
			\item Prover sends $\hat{p}(x),p(x)$ to verifier.
			\item Verifier checks that $\hat{f}(x) \mod p=f(x)$
			\item Verifier checks that $\deg(f(x))=d$ and that for each coefficient $f_i$, $|f_i|< q/2$
			\item If $C=g^{f(q)}$ the verifier accepts.
		\end{enumerate}
	\end{flushleft}
	
\end{minipage}
\end{mdframed}
\begin{small}
 \begin{minipage}{1.1\textwidth}
\begin{mdframed}[userdefinedwidth=1\textwidth]  \label{prot:Opening}
$\eval(\crs,C,d,z,y;f(x))$\\
Evaluation protocol $\eval$ at point $y=f(z)\in \FF_p$. Degree $d$ Commitment $C$. $f(x)=\sum_{i=0}^{d} f_i x^{i}$
\begin{enumerate}[nolistsep]
\item \pcif $d=0$:
\item \pcind[1] Prover computes $\hat{y}=\hat{f} \in \ZZ$, i.e. $\hat{f}(x)$ is a constant. 
\item \pcind[1] Prover sends $\hat{y}$ to the verifier.
\item \pcind[1] Verifier checks that $0\leq\hat{y}< (\log_2(d+1)+1)\cdot p$,  $\hat{y} \bmod p=y$ and $g^{\hat{y}}=C$ otherwise rejects
\item \pcelse: \benedikt{Doesn't quite work for $d=1$}
\item \pcind[1] Prover computes $f_0(x)=\sum_{i=0}^{d/2-1} f_i x^i\in \ZZ$ and $f_1(x)=\sum_{i=0}^{d/2-1} f_{d/2+i} x^{i}\in \ZZ$
\item \pcind[1] $y_0=f_0(z) \bmod p$, $y_1=f_1(z)\bmod p$, $C_0\gets\commit(f_0)$,$C_1\gets\commit(f_1)$
\item \pcind[1] Prover sends $y_0,y_1,C_0,C_1$ to the Verifier
\item \pcind[1] Verifier checks that $y_0+z^{d/2} y_1=y\in \FF_p$ and that $C_0C_1^{q^{d/2}}=C$\footnote{Using $\textsf{PoE}(C_1,C/C_0,q^{d/2})$}
\item \pcind[1] Verifier samples $\alpha \sample \FF_p$ and sends it to the prover
\item \pcind[1] Prover and Verifier compute $y'\gets\alpha y_0 +y_1 \bmod p$, $C'\gets C_0^{\alpha}C_1 \in \GG$. \\Prover also computs $f'(x)\gets\alpha  \cdot \hat{f}_0(x)+\hat{f}_1(x) \in \ZZ[X]$ 
\item \pcind[1] Prover and Verifier run $\eval(y',C',d/2,z,y';f'(x))$
\end{enumerate}
\end{mdframed}
\end{minipage}
\end{small}

\section{Security}


\begin{lemma}
	The pseudo root assumption holds in the generic group model.
\end{lemma}
\begin{lemma}
	The polynomial commitment scheme satisfies the opening binding property
\end{lemma}
\begin{proof}
	Assume $\hat{f}(x)$ and $\hat{g}(x)$ are integer encodings of two distinct polynomials $f(x),p(x) \in \FF_p[X]$. Then $\hat{h}(x)=\hat{f}(x)-\hat{g}(x) \in \ZZ[X]$ is a polynomial of degree at most $d$. Since $g^{\hat{g}(q)}=g^{\hat{f}(q)}=C$ we have that $g^{\hat{h}(q)}=1$\benedikt{Change generator base name}. Note that the coefficients of $g(x)$ and $h(x)$ are all less than $q/2$ in absolute value. By triangle inequality we have that $\hat{h}(x)$ are less than $q$. $\hat{h}$ is by assumption not the zero polynomial. This implies that $\hat{h}(q)\neq 0$ is a multiple of the order of $g\in \GG$. This however can directly be used to break the pseudo root assumption (Assumption \ref{assum:fracroot}) by taking the inverse of an integer mod $h(q)$.
\end{proof}

\begin{theorem}
	The polynomial commitment scheme from Section \ref{sec:protocol} satisfies extraction under the Pseudo Root Assumption and the Order assumption. We show that we can either extract a pseudo root of $g$ or a witness \benedikt{Formally we should define witness extended emulation }
\end{theorem}
\begin{proof}
(SKETCH)
We prove the statement by showing that we can recursively either extract the encoding of an integer polynomial $f(x) \in \ZZ[X]$ of degree $d$ with bounded coefficients or a break of the pseudo root assumption for element $g$ or a non trivial element of known (random) order in $\GG$. We recurse over degree $\hat{d}$ up to the final degree $d$.
In each round the extracted witness is an integer $\hat{y}$ such that $\hat{y}=\enc(f(x))$ where the coefficients of $f(x)$ are less than $B$ in absolute value and the degree is at most $\hat{d}$ and such that $g^{\hat{y}}=C$. Also $f(z) \equiv y \mod p$.
If $\hat{d}=0$ then we can directly extract $f(x)=\hat{y}$ such that $\vert \hat{y} \vert < p^{\log_2(d+1)+1}$, $y=\hat{y}\mod p$, $f(x)=y\in \FF_p[X]$ and $g^{\hat{y}}=C$ as the witness. We proceed with $d=1$.
For $d>0$ we have $g^{\hat{y}}=C=C_0^{\alpha}C_1$. Rewinding once we get 
 $C=C_0^{\alpha}C_1=g^{\hat{y}}$ and $C'=C_0^{\alpha'}C_1=g^{\hat{y}'}$ for distinct $\alpha$ and $\alpha'$. 
 This gives us $C_0^{\alpha-\alpha'}=g^{\hat{y}-\hat{y}'}$. 
 Either $\alpha-\alpha' \not|~ \hat{y}-\hat{y}' $ which would directly break the pseudo root assumption or we can compute $D=g^{\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}}$. Either $D=C_0$ or $(D/C_0)^{\alpha-\alpha'}=1$, i.e. $D/C_0$ is an element of known random order. In either of the cases the extraction succeeds and is completed.
 If $D=C_0$ then we have $\hat{y}_0=\frac{\hat{y}-\hat{y}'}{\alpha-\alpha'}$ and
 $g^{\hat{y}_0}=C_0$. In that case $C_1=g^{\hat{y}_1}=g^{\hat{y}-\hat{y}_0}$. If $|y|=|y'|<B$ then $|y_0|<  2 \cdot B$ and $|y_1|<|\hat{y}-\hat{y}+\hat{y}'|=|\hat{y}'|<B$. 
 We define $f(x)=\dec(y_0+x^{d} \cdot y_1)$ and with coefficients less than $2B$ in absolute value. 
 Note that $y_0=\hat{y}_0 \mod p=\dec{y_0}(z)$ and $y_1=\hat{y}_1 \mod p=\dec{y_1}(z)$. Since $y=\dec{\hat{y}}(z)=\alpha \cdot \dec{\hat{y}_0(z)}+\dec{\hat{y}_1(z)}$ and $f(x)=\dec(y_0+x^{\hat{d}} \cdot y_1)$ we have that $y=y_0 +z^{\hat{d}/2}y_1 \mod p=f(z) \mod p$.
 Additionally $C=C_0^{\alpha}C_1=\commit(f(x))$ or we get a break of the adaptive root assumption.\benedikt{So this is technically a bit difficult because it's not actually a witeness}.
 
 The extractor recuses with the encoding of $f(x)$ and degree $\hat{d}'=\hat{d}\cdot 2$.
 
 Repeating this $\log_2(d+1)$ times we get a polynomial $f(x)$ of degree $d$ that has coefficients that are bounded by $(d+1) \cdot p^{\log_2(d+1)+1} <q/2$. 
 


\end{proof}

\begin{corollary}
	If $q<bla$ there exists an efficient adversary that can break the evaluation binding property of the polynomial commitment.
\end{corollary}
\benedikt{Figure out at what q we can attack the scheme. Probably needs to use negative coefficients and such.}
\section{Supersonic: A SNARK with trustless, constant size CRS}
We build \emph{supersonic} by instantiating the Sonic SNARK using our trustless setup polynomial commitment scheme.
  \bibliography{references,cryptobib/abbrev0,cryptobib/crypto}

\end{document}
