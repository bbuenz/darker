\documentclass[11pt]{article}
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics,advantage]{cryptocode}
\usepackage{notations}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsmath,amsthm,amssymb}
\usepackage[utf8x]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{xspace}
\usepackage[normalem]{ulem}
\usepackage{comment}
\usepackage{hyperref}
\usepackage[legalpaper, margin=1.5in]{geometry}

%Theorems
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{fact}{Fact}
\newtheorem{corollary}{Corollary}

\newif\ifcomments
\commentstrue


\ifcomments
	\newcommand{\benedikt}[1]{{\textcolor{red}{[Benedikt: #1]}}}
	\newcommand{\ben}[1]{{\textcolor{green}{[Ben: #1]}}}
	\newcommand{\alan}[1]{{\todo[color=blue!40!white]{Alan: #1}}}
	\newcommand{\alaninline}[1]{{\todo[color=blue!20!white, inline]{Alan: #1}}}
		\newcommand{\ignore}[1]{}

	\else
	\newcommand{\benedikt}[1]{}
	\newcommand{\ben}[1]{}
	\newcommand{\alan}[1]{}
	\newcommand{\alaninline}[1]{}
	\fi

\date{}

\begin{document}
\title{Transparent SNARKs from DARK Arguments}
\maketitle

\begin{abstract} 
We construct a new polynomial commitment scheme for multivariate polynomials over finite fields, with public-coin evaluation proofs that have logarithmic communication in the degree of the polynomial. The techniques are reminiscent of \emph{Diophantine Arguments of Knowledge} (Lipmaa, Asiacrypt'03), leveraging integer representations of polynomials and groups of unknown order. Security is shown from falsifiable assumptions that hold in generic groups. Moreover, the scheme does not require a trusted setup if instantiated with class groups. We apply this new cryptographic compiler to algebraic linear IOPs in order to obtain doubly-efficient public-coin IPs with succinct communication and witness-extended emulation for any NP relation. Allowing for linear preprocessing, the online verifier's work is logarithmic in the circuit complexity of the relation.

Concretely, compiling a QAP-based IOP results in quadratic prover time, but we obtain quasi-linear prover time when compiling instead the IOP employed in Sonic (Maller \emph{et. al.}, CCS 2019) based on bivariate Laurent polynomials. Applying the Fiat-Shamir transform in the random oracle model results in a transparent preprocessing zk-SNARK system with quasi-linear prover time, logarithmic proof size, and logarithmic verification time for arbitrary circuits, which we call \textsf{\textbf{Supersonic}}. This is the first zk-SNARK without trusted setup with only logarithmic proof sizes and verification time.\alan{The STARK proof system also qualifies for that description, as do the CS proofs of Micali and Lai-Malavolta.} 

\end{abstract} 

\section{Introduction}

A polynomial commitment scheme enables a prover to bind himself to a polynomial in much less bandwidth than transmitting all coefficients would require. A skeptical verifier can subsequently test the commitment for certain algebraic relations as though he were in possession of the polynomial's full description, except at a much smaller work cost. Indeed, polynomial commitments lie at the heart of a host of efficiently verifiable interactive proof systems.

Of particular interest to this paper are proof systems whereby the prover establishes the correct performance of an arbitrary computation (that may or may not involve secret information) in such a way that the communication or verification complexity scales asymptotically better than performing the computation naïvely. Without exception, these proof systems rely on a technique called \emph{arithmetization}: characterizing the computation in question as a collection of arithmetic operations over a finite field. The utility of polynomial commitments stems from their capacity to succinctly capture a canonical representation of such collections while retaining the algebraic properties that make arithmetization work in the first place.

The literature on proof systems for arbitrary computations focuses on two techniques to achieve polynomial commitments. First: Merkle trees --- here every leaf represents the polynomial's evaluation in a given point, and the Merkle root represents the commitment to the polynomial. The verifier needs to verify the authentication paths of selected points, which can be done in logarithmic space and time (as a function of the number of points). Second: groups equipped with bilinear maps --- in this case a structured reference string (SRS)\footnote{Previously known as \emph{common reference string}, CRS.} provides the values of all monomials up to a given degree when evaluated in an unknown point. By computing a weighted sum of these monomial values, the prover obtains the evaluation of his polynomial in the unknown point. The verifier performs the pairing operation to verify that multiplicative relations hold between committed polynomials.

This paper provides a third option for generating polynomial commitment schemes, namely by relying on groups of unknown order --- such as the group of integers with multiplication modulo an RSA modulus of unknown factorization, or the ideal class group of an order of an imaginary quadratic number field. These groups have seen relatively little adoption or even attention from the cryptographic community because the only known constructions thereof have subexponential attack algorithms. As a result, for a practical security level, elements of groups of unknown order typically require several hundreds of bytes to represent, in contrast to the tens of bytes needed for elements of elliptic curves for which no subexponential algorithms exist. 

Nevertheless, groups of unknown order provide a property that groups of known order, such as elliptic curve groups, cannot match: they enable homomorphic  commitments to an \emph{infinite} domain, namely the integers. Indeed, if the prover were capable of reducing a large integer to a smaller one without sacrificing the homomorphic properties, then he must know the group's order. The power of integer commitments was already noted by Lipmaa~\cite{AC:Lipmaa03b} who characterizes proof systems arising therefrom as \emph{Diophantine} --- a reference to the family of languages for which such proof systems establish. Specifically, a set $S \subset \mathbb{Z}^n$ is called \emph{Diophantine} if it is the projection onto the first $n \leq m$ coordinates of the set of roots to a polynomial $P(X_1, \ldots, X_m) \in \mathbb{Z}[X_1, \ldots, X_m]$.% Much more recently, Wesolowski produced a conceptually simple verifiable delay function (VDF) which builds on a proof of correct exponentiation in groups of unknown order. Building on this result, Boneh \emph{et al.} developed accumulators and vector commitments (with batch openings) from groups of unknown order~\cite{}. 

\alaninline{Todo: \\
 - applications (trustless snarks etc) \\
 - implications (no unfalsifiable assumptions) \\
 - overview of techniques \\
 - related work}

\vspace{0.25cm}
\textsc{Contributions.} The contributions of this paper are divisible into three rubrics:
\begin{itemize}
    \item[] \textbf{Tools.} We start with an encoding scheme that represents polynomials over a prime field $\mathbb{F}_p$ as integers, by encoding the polynomial's coefficients into the integer's base-$q$ expansion. Adjoined with a group of unknown order and a designated base element $g \in \mathbb{G}$, this encoding scheme naturally gives rise to a polynomial commitment scheme that inherits its somewhat homomorphic properties. Next, we provide protocols for proving the correct evaluation of a committed polynomial, and showing that two polynomials have the same coefficients but flipped or rotated. We also present a protocol for extracting the $i$th coefficient, thereby promoting the commitment scheme to one that also provides vector commitment functionality. Building on this observation, we provide another protocol for showing that a commitment represents the inner product between two vectors of which at least one is represented by its vector commitment. Another protocol establishes that two vector commitments represent the same vector up to an arbitrary but known permutation of the coefficients.
    \item[] All the proof systems mentioned so far have logarithmic communication complexity and logarithmic verification time. Moreover, with the exception of the inner product proof and the permutation proof, the prover's complexity is quasi-linear. If one is willing to sacrifice this scalability for the prover, we also provide counterparts to all the above proofs with constant communication and verification complexity.
    \item[] \textbf{Applications.} To illustrate the usefulness and the versatility of the enumerated tools, we join them straightforwardly to construct a simple succinct non-interactive argument of knowledge (SNARK) based on quadratic arithmetic programs (QAPs). To the best of our knowledge, this is the first SNARK for circuits without trusted setup (when instantiated with the class group) or with an SRS whose size is independent of the circuit (when instantiated with the RSA group).\footnote{This classification takes note of the STARK proof system of Ben Sasson \emph{et al.}~\cite{C:BBHR19} whose verification time is polylogarithmic but as a function of the \emph{running time} of some program and not of any circuit; as well as of Hyrax~\cite{SP:WTTW17} and Spartan~\cite{eprint:Setty19}, which do apply to circuits but whose verification times are not polylogarithmic and thus fail to satisfy the definition of SNARKs as set forth in the paper that coined the term~\cite{JC:BCCGLRT17}.}
    \item[] \alan{deprecated} We follow up this conceptually simple QAP-based proof system with a survey of popular communication-efficient proof systems for arbitrary computations, in which we replace their constituent components with tools developed earlier in this paper. In this light we analyze Sonic, Spartan, Hyrax, Bulletproofs, and STARK. In all cases we find that using our techniques leads to different trade-offs; improving on some metrics while degrading others.
\end{itemize}

\subsection{Related Work}

\ben{Need to discuss related work on SNARKs, not just technical tools with groups of unknown order... } 
\paragraph{SNARKs} 
\paragraph{Transparent polynomial commitments} 
Discuss Hyrax, DEEP-FRI 

\paragraph{Arguments with hidden order groups} 
Homomorphic integer commitment schemes based on the RSA group were first proposed by Fujisaki and Okamoto~\cite{C:FujOka97}, who also provide a protocol to prove that a list of committed integers satisfy a polynomial equation modulo an arbitrary positive integer as well as one for opening a commitment bit by bit. Damgård and Fujisaki~\cite{AC:DamFuj02} fix an issue with the soundness proof of that protocol and are the first to suggest using class groups of an imaginary quadratic order as a candidate group of unknown order. Around the same time, Lipmaa draws the link between zero-knowledge proofs constructed from integer commitment schemes and Diophantine complexity~\cite{AC:Lipmaa03b}. Much later, Couteau~\emph{et al.} study protocols derived from integer commitments specifically in the RSA group in order to lift their security proofs so as to require weaker assumptions; in the process they develop proofs for polynomial evaluation modulo a prime $\pi$ that is not initially known to the verifier, in addition to a proof showing that an integer $X$ lies in the range $\{a, \ldots, b\}$ by showing that $1+4(X-a)(b-X)$ decomposes as the sum of 3 squares~\cite{EC:CouPetPoi17}.

Pietrzak~\cite{ITCS:Pietrzak18} developed an efficient proof of repeated squaring, i.e. proving that $x^{2^T} = y$ with $O(\log T)$ proof size and verification time in order to build a conceptually simple verifiable delay function~\cite{C:BBBF18} based on the RSW time-lock puzzle~\cite{RivShaWag96}. Wesolowski~\cite{EC:Wesolowski19} improves on this result by proposing a single-round protocol to prove correct repeated squaring in groups of unknown order with a constant size proof. Boneh~\emph{et al.} observe that this protocol generalizes to arbitrary exponents (PoE) and developed a proof of knowledge of an integer exponent (PoKE), as well as a zero-knowledge variant. They apply both PoE and PoKE to constructing efficient accumulators and vector commitment schemes~\cite{C:BonBunFis19}.

\section{Preliminaries}

\subsection{Assumptions}

The cryptographic compilers make extensive use of groups of unknown order, \emph{i.e.}, groups for which the order cannot be computed efficiently.
Concretely, we require groups for which two specific hardness assumptions hold.
First the Strong RSA Assumption~\cite{CCS:CraSho99} which roughly states that it is hard to take \emph{arbitrary} roots of \emph{random} elements. Secondly, the much newer Adaptive Root Assumption\cite{EC:Wesolowski19} which is the dual of the Strong RSA Assumption and states that it is hard to take \emph{random} roots of \emph{arbitrary} group elements. 
Both of these assumption hold in generic groups of unknown order~\cite{genericunknown,C:BonBunFis19}, i.e. there are no efficient algorithms that only have black-box access to the group but are able to break these assumptions. 
It is an open research problem to show whether one of these assumption implies the other.

\begin{assumption}[Strong RSA Assumption]


\label{assum:strongRSA}
The \defn{Strong RSA Assumption} sates that no efficient adversary can compute any root of a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
\[
    \Pr\left[\gr{u}^\ell = \gr{g} \,\wedge \ell>1:
    \begin{array}{l}
         \GG \leftarrow \ggen(\lambda)  \\
         \gr{g} \sample \GG \\
         (\gr{u}, \ell) \in \mathbb{G} \times \mathbb{N} \leftarrow \adv(\mathbb{G}, \gr{g}) \\
    \end{array}\right] \leq \negl \enspace .
\]
\end{assumption} 
We note that some definitions of the Strong RSA Assumption additionally require that $\ell$ be an odd prime~\cite{EC:BarPfi97}. Our definition is stronger and says that all roots are difficult.
\begin{assumption}[Adaptive Root Assumption]
\label{assum:adaptiveroot}
We say that the \defn{Adaptive Root Assumption} holds for $\ggen$ if 
there is no efficient adversary $(\adv_0,\adv_1)$ that succeeds 
in the following task.
First, $\adv_0$ outputs an element $\gr{w} \in \GG$ and some $\state$.
Then, a random prime $\ell$ in $\primes$ is chosen
and $\adv_1(\ell,\state)$ outputs $\gr{w}^{1/\ell} \in \GG$.
More precisely, for all efficient $(\adv_0,\adv_1)$:
\[           \advantage{AR}{(\adv_0,\adv_1)}\deq 
                \Pr\left[\gr{u}^\ell = \gr{w} \neq 1 \ : \ 
                \begin{array}{l}
                      \GG \sample \ggen(\lambda) \\ 
                      (\gr{w},\state) \sample \adv_0(\GG) \\
                      \ell \sample \primes \\ 
                      \gr{u} \gets \adv_1(\ell, \state)
                \end{array} 
        \right] \leq \negl.
\]
\end{assumption}







We additionally use two more assumptions, however both of them reduce to the Strong RSA and the Adaptive Root Assumptions.

The first assumption states that computing the order for \emph{any} element is hard. It reduces to the Adaptive Root Assumption. Interestingly, it doesn't necessarily hold for all candidate groups of unknown order as we explain below. In particular it is important to exclude elements of known order such as $-1$ from the candidate unknown order group $\ZZ_n$.
%As explained below this assumption does not hold in 
%In $\ZZ_n$ for composite $n$, the element $-1\in \ZZ_n$ has known order $2$. For other candidate groups such as class groups with fundamental discriminants or $\ZZ_n/\{-1,1\}$ we have no efficient algorithms for computing elements of known order. We note that if $n=p\cdot q$ for strong primes $p$ and $q$ and we operate in the group of quadratic residues of $\ZZ_n$ then the Order Assumption reduces to the Strong RSA Assumption.\benedikt{Suitable citation}
\begin{assumption}[Order Assumption]
\label{assum:order}
	The Order Assumption holds for $\ggen$ if for any efficient adversary $\adv$:
\[        
                \Pr\left[\gr{w}\neq 1 \wedge \gr{w}^{\alpha}= 1: 
                \begin{array}{l} 
                      \GG \sample \ggen(\lambda) \\ 
                      (\gr{w},\alpha) \sample \adv(\GG) \\
                      \text{where } |\alpha|<2^{\poly{}}\in \ZZ\\
                      \text{and } \gr{w}\in \GG
                \end{array} 
        \right] \leq \negl \enspace .
\]
\end{assumption}
\begin{lemma}
\label{lem:ordertoadaptive}
	The Adaptive Root Assumption implies the Order Assumption.
\end{lemma}
\begin{proof}
	We show that given an adversary $\adv_{\textsf{Ord}}$ that breaks the Order Assumption we can construct with overwhelming probability $\adv_{\textsf{AR}}$ that breaks the Adaptive Root Assumption. We run $\adv_{\textsf{Ord}}$ to get a $\gr{w}\neq 1\in \GG$ and $\alpha \in \ZZ$ such that $\gr{w}^{\alpha}=1$. To construct $\adv_{\textsf{AR}}$, $\adv_{\textsf{AR},0}$ outputs $(\gr{w},\alpha)$. The challenger generates a random challenge $\ell$. If $\gcd(\ell,\alpha)=1$ then $\adv_{\textsf{AR},1}$ can compute $\beta\gets \ell^{-1} \bmod \alpha$ and output $\gr{u}\gets\gr{w}^{\beta}$. By construction $\gr{u}^{\ell}=\gr{w}$. The probability that $\gcd(\ell,\alpha)=1$ is overwhelming because $\gcd(\ell,\alpha)\neq 1 \implies \ell \not\vert \alpha$. This happens with negligible probability as $\ell$ is picked from a set of $2^\lambda$ primes and at most $\poly$ distinct primes can divide $\alpha$.
	\end{proof}
	
	
In addition to the previous assumptions, we define the Fractional Root Assumption, which states that for random group elements $\gr{g}$ it is hard to find a tuple $(\gr{u}\in \GG,\alpha\in \ZZ,\beta\in \ZZ)$ such that $\gr{u}^{\beta}=\gr{g}^{\alpha}$, unless $\frac{\alpha}{\beta}$ is an dyadic rational, \emph{i.e.}, a rational whose denominator is a power of $2$. In RSA groups the assumption is also conjectured to hold if $\frac{\alpha}{\beta}$ is restricted to be an integer. We say that $(\gr{u},\alpha,\beta)$ is a \emph{fractional root} of $\gr{g}$.
%Shoup\cite{CCS:CraSho99} showed that for the unknown order group of quadratic residues in $\ZZ_n$, where $n$ is the composite of two strong primes, that the Fractional Root Assumption reduces to just the Strong RSA Assumption.

\begin{assumption}[Fractional Root Assumption]
\label{assum:fracroot}
The Fractional Root Assumption holds for $\ggen$ if for any efficient adversary $\adv$:
\[        
                \Pr\left[\gr{u}^\beta = \gr{g}^{\alpha} \wedge \frac{\beta}{\gcd(\alpha,\beta)}\neq 2^k,  k \in \NN   : 
                \begin{array}{l} 
                      \GG \sample \ggen(\lambda) \\ 
                      \gr{g} \sample \GG \\
                      (\alpha, \beta, \gr{u}) \sample \adv(\GG, \gr{g}) \\
                      \quad \textnormal{where} \, |\alpha|<2^{\poly}, \\
                      \quad |\beta|<2^{\poly} \in \ZZ, \\
                      \quad \textnormal{and} \, \gr{u} \in \GG 
                \end{array} 
        \right] \leq \negl \enspace .
\]
\end{assumption}
The Fractional Root Assumption reduces to the Order Assumption (and therefore to the Adaptive Root Assumption) and the Strong RSA Assumption.
\begin{lemma}
\label{lem:strongtofractional}
	The Adaptive Root Assumption and the Strong RSA Assumption imply the Fractional Root Assumption.
\end{lemma}
\begin{proof}
	Given an adversary $\adv_{\textsf{FR}}$ that succeeds in breaking the Fractional Root Assumption for $\ggen$ we can construct either an adversary $\adv_{RSA}$ for the Strong RSA Assumption or an adversary $\adv_{\textsf{Ord}}$ that breaks the Order Assumption for $\ggen$. As shown in Lemma \ref{lem:ordertoadaptive} the Order Assumption reduces to the Adaptive Root Assumption with overwhelming probability. 
	We first generate a group of unknown order $\GG \sample \ggen(\lambda)$.
	Then we sample $\gr{g}\sample \GG$ as done in the strong \textsf{RSA} security definition.
	
	We now run the $\adv_{\textsf{FR}}$ on input $\GG$ and $\gr{g}$ to generate a tuple $(\alpha,\beta,\gr{u})$ such that $\gr{u}^{\beta}=\gr{g}^{\alpha}$. Let $\gamma=\gcd(\alpha,\beta)$ and $\alpha'=\frac{\alpha}{\gamma}\in \ZZ$ and  $\beta'=\frac{\beta}{\gamma}$. Now either $\gr{g}^{\alpha'}=\gr{u}^{\beta'}$ or $\gr{g}^{\alpha'}/\gr{u}^{\beta'}$ is a non trivial element of order $\gamma$ which would directly break the Order Assumption. In that case we constructed $\adv_{\textsf{Ord}}$ that outputs $(\gr{g}^{\alpha'}/\gr{u}^{\beta'},\gamma)$.
	
	Now assume otherwise, i.e. $\gr{g}^{\alpha'}=\gr{u}^{\beta'}$. By construction $\gcd(\alpha',\beta')=1$ and we can efficiently compute integers $a,b$ such that $a \alpha'+b \beta'=1$. By assumption on $\adv_{\textsf{FR}}$ $\beta'$ is not $1$. Now let $\gr{w}\gets \gr{u}^{a}\gr{g}^{b}$. Note that $\gr{w}^{\alpha'\beta'}=\gr{g}^{\alpha'}$. So either $\gr{w}^{\beta'}=\gr{g}$ or $\gr{w}^{\beta'}/\gr{g}$ is a non-trivial element of order $\alpha'$. The first case breaks the Strong RSA Assumption, as we can construct $\adv_{\textsf{RSA}}$ that outputs $(\gr{w},\beta)$, and the second breaks the Order Assumption.
\end{proof}

\paragraph{Groups of unknown order.}
We consider three candidate groups of unknown order. Each has its own upsides and downsides.

\textit{RSA Group.} In the multiplicative group $\ZZ_n^*$ of integers modulo a product $n=p\cdot q$ of large primes $p$ and $q$, computing the order of the group is as hard as factoring $n$. The Order Assumption does not hold for $\ZZ_n^*$ because $-1 \in \ZZ_n^*$ can be easily computed and has order two. This can be resolved though by working instead in the quotient group $\ZZ_n^* / \langle-1\rangle \cong \mathrm{QR}_n$. %Additionally if $n$ is the product of strong primes, \emph{i.e.}, $\frac{p-1}{2}$ and $\frac{q-1}{2}$ are primes, then $\mathrm{QR}_n$ does not contain elements of low order\cite{JC:FisSch00,C:HofKil09}. In this group, the Order Assumption and the Strong RSA Assumption are equivalent to the hardness of factoring $n$.\alan{citation needed}
The downside of using an RSA group, or more precisely, the group of quadratic residues modulo an RSA modulus, is that this modulus cannot be generated from public coins without exposing the order, and therefore has to come from a trusted setup.

\textit{UFO Group.} An alternative to RSA groups that still uses similar arithmetic is the multiplicative group of integers $\ZZ_n^*$ modulo a large random modulus $n$, called an \emph{UnFactorizable Object (UFO)}~\cite{conf/icics/Sander99}. This modulus is chosen to be so large so that with overwhelming probability its factorization contains two primes large enough to guarantee the targeted security level. As a result, elements of this group are hundreds of thousands of bits in size for reasonable security levels, compared to just thousands of bits for RSA group elements. The upside though is that the unfactorizable object $n$ can be sampled with public randomness, and therefore requires no trusted setup.

\textit{Class Group.} The class group of an imaginary quadratic order is defined as the quotient group of fractional ideals by principal ideals of an order of a number field $\mathbb{Q}(\sqrt{\Delta})$, with ideal multiplication. A class group $\mathcal{C}\ell(\Delta)$ is fully defined by its discriminant $\Delta$, which needs to satisfy only public constraints such as $\Delta \equiv 1 \bmod 4$ and $-\Delta$ must be prime. As a result, $\Delta$ can be generated from public coins, thus obviating the need for a trusted setup. A group element can be represented by two integers strictly smaller (in absolute value) than $-\Delta$, which in turn is on the same order of magnitude as RSA group elements for a similar security level.  We refer the reader to Buchmann and Hamdy's survey~\cite{PKC/BucHam01} or to Michael Straka's accessible blog post~\cite{web/Stra19} for more details.

Working in $\mathcal{C}\ell(\Delta)$ does present an important difficulty: there is an efficient algorithm due to Gauss to compute square roots of arbitrary elements~\cite{jtn/BosSte96}, and by repetition, arbitrary power of two roots. As a result, class groups cannot be used to commit to integers but rather to \emph{dyadic rationals}, which are rational numbers whose denominator is a power of two.
Additionally, both the Strong RSA Assumption and the Fractional Root Assumption are broken if computing square roots is easy. We therefore change these assumptions to ones which are believed to still hold even if computing square roots is easy.
\paragraph{Assumptions for groups with efficient square roots}
We modify and weaken that the Strong RSA Assumption such that it explicitly allows an adversary to take square roots (and higher power of $2$ roots).
\begin{assumption}[Dyadic Strong RSA Assumption]
\label{assum:dyadicstrongRSA}
The \defn{Dyadic Strong RSA Assumption} sates that no efficient adversary can compute any non power of $2$ root of a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
\[
    \Pr\left[\gr{u}^\ell = \gr{g} \, \wedge \, \ell\neq 2^k, k \in \NN:
    \begin{array}{l}
         \GG \leftarrow \ggen(\lambda)  \\
         \gr{g} \sample \GG \\
         (\gr{u}, \ell) \in \mathbb{G} \times \mathbb{N} \leftarrow \adv(\mathbb{G}, \gr{g}) \\
    \end{array}\right] \leq \negl \enspace .
\]
\end{assumption} 

We also state a weakened version of the fraction root assumption which again allows an adversary to compute power of two roots.
\begin{assumption}[Dyadic Rational Root Assumption]
\label{assum:dyadicfracroot}
The \defn{Dyadic Rational Root Assumption} holds for $\ggen$ if for any efficient adversary $\adv$:
\[        
                \Pr\left[\gr{u}^\beta = \gr{g}^{\alpha} \wedge \frac{\beta}{\gcd(\alpha,\beta)}\neq 2^k,  k \in \NN   : 
                \begin{array}{l} 
                      \GG \sample \ggen(\lambda) \\ 
                      \gr{g} \sample \GG \\
                      (\alpha, \beta, \gr{u}) \sample \adv(\GG, \gr{g}) \\
                      \quad \textnormal{where} \, |\alpha|<2^{\poly}, \\
                      \quad |\beta|<2^{\poly} \in \ZZ \\
                      \quad \textnormal{and} \, \gr{u} \in \GG 
                \end{array} 
        \right] \leq \negl \enspace .
\]
\end{assumption}

\begin{lemma}
	The Adaptive Root Assumption and the dyadic Strong RSA Assumption imply the dyadic rational root assumption.
\end{lemma}
The proof of the Lemma is nearly identical to the proof of Lemma \ref{lem:strongtofractional}. The only difference is that the computed root of $\gr{g}$ is not a power of $2$ and thus breaks the dyadic Strong RSA Assumption.

\subsection{Interactive Arguments of Knowledge}
Interactive arguments are \emph{interactive proofs}~\cite{GolMicRac89} in which security holds only against a computationally bounded prover. In an interactive argument for a relation $\mathcal{R}$, the prover convinces the verifier that it ``knows" a witness $w$ for a statement $x$ such that $(x, w) \in \mathcal{R}$. The standard definition of \emph{proofs of knowledge} (PoK) by Bellare and Goldreich~\cite{C:BelGol92} is based on the existence of an extractor machine $E$ that has oracle access to a malicious prover $P^*$, and if $P^*$ would cause the verifier to accept on input $X$ with high probability then $E$ outputs $w$ such that $(X, w) \in \mathcal{R}$ (with overwhelming probability). $E$ runs in expected polynomial time. This definition quantifies the success of $E$ over all inputs $x$, which unfortunately is problematic in the case of interactive  \emph{arguments},.

To illustrate one issue, if the interactive argument relies on a \emph{common reference string} (CRS) setup with secret trapdoor information (e.g. the factorization of an RSA modulus) then one of the inputs $x^*$ could leak the trapdoor to the prover. Any extractor should clearly fail on input $x^*$ while $P^*$ may succeed, hence the definition cannot be satisfied. This particular problem is fixed by requiring the adversary $P^*$ to generate the input $x$. If the trapdoor is exponentially hard to compute the polynomial time adversary will not be able to embed the trapdoor in $x$ except with negligible probability. (See Damg\r{a}rd and Fujisaki~\cite{AC:DamFuj02} for a broader discussion of the issues that arise when applying the standard PoK definition to interactive arguments).

\emph{Witness-extended emulation}~\cite{EC:Lindell03} strengthens the PoK notion so that the extractor outputs not only a witness but also a simulated transcript of the messages between the prover and verifier. This property is helpful for security analysis when a PoK is used as a subprotocol within a larger protocol (e.g. a PoK of a commitment opening within a NIZK for arbitrary circuits), in particularly in order to construct a simulator that needs to both obtain the adverssary's witness as well as simulate its view in the sub-protocol. Groth and Ishai~\cite{EC:GroIsh08} adapt Lindell's definition for interactive arguments of knowledge (AoK) in the CRS model. This is the AoK definition we will use in the present work.

\begin{definition} [Interactive Argument]\label{def:argument}
Let $(P, V)$ denote a pair of PPT interactive algorithms and $\textsf{Setup}$ denote a non-interactive setup algorithm that outputs public parameters $\params$ given a security parameter. Both $P$ and $V$ have access to $\params$. Let $\langle P(pp, x, w), V(pp, x) \rangle$ denote the output of $V$ on input $x$ after its interaction with $P$, who has witness $w$. The triple $(\textsf{Setup}, P, V)$ is called an argument for relation $\mathcal{R}$ if for all non-uniform PPT adversaries $\mathcal{A}$ the following properties hold: 

\begin{itemize}
\item \underline{Perfect Completeness}. 
\[
\Pr \left[
\begin{array}{c}
        (x, w) \not \in  \mathcal{R} \ \text{or} \\
         \ \langle P(\params, x, w), V(\params, x) \rangle = 1 \\
\end{array}
:
\begin{array}{c}
             \params \leftarrow \textsf{Setup}(1^\lambda) \\
             (x, w) \leftarrow \mathcal{A}(\params) \\
\end{array} 
\right]  = 1 
 \]

\item \underline{Computational soundness}. 
\[
\Pr \left[
\begin{array}{c}
        \forall w \ (x, w) \not\in  \mathcal{R} \ \text{and} \\ 
         \langle \mathcal{A}(\params, x, \st), V(\params, x) \rangle = 1 
\end{array}
:
\begin{array}{c}
             \params \leftarrow \textsf{Setup}(1^\lambda) \\
             (x, \st) \leftarrow \mathcal{A}(\params) \\
\end{array}
        \right] \leq \negl
\]
\end{itemize} 
\end{definition} 

The interactive argument is called \textbf{public-coin} if all the verifier's messages are uniformly random values, independent of all prior messages and the setup parameters $\params$. 
We next recall the definition of witness-extended emulation for interactive arguments, which is a form of knowledge extraction.  

\alan{I would drop the $\textsf{Setup}$ algorithm from the following definition as it is not part of the argument system $(\prover, \verifier)$.}
\begin{definition}[Witness-extended emulation~\cite{EC:GroIsh08}]\label{def:wee}
Given a public-coin interactive argument tuple $(\textsf{Setup}, P, V)$ and arbitrary prover algorithm $P^*$, let $\textsf{Record}(P^*, \params, x, \st)$ denote the message transcript between $P^*$ and $V$ on shared input $x$, initial prover state $\st$, and $\params$ generated by $\textsf{Setup}$. Furthermore, let $E^{\textsf{Record}(P^*, \params, x, \st)}$ denote an machine $E$ with a transcript oracle for this interaction that can be rewound to any round and run again on fresh verifier randomness. The tuple $(\textsf{Setup}, P, V)$ has witness-extended emulation if for every deterministic polynomial time $P^*$ there exists an expected polynomial time emulator $E$ such that for all non-uniform polynomial time adversaries $\mathcal{A}$ the following condition holds: 
\[
\Pr \left[
\mathcal{A}(\textsf{tr}) = 1
:
\begin{array}{c}
             \params \leftarrow \textsf{Setup}(1^\lambda) \\
             (x, \st) \leftarrow \mathcal{A}(\params) \\
             \tr \leftarrow \textsf{Record}(P^*, \params, x, \st)
\end{array} 
\right] \approx
\]
\[
\Pr \left[
\begin{array}{c} 
\mathcal{A}(\textsf{tr}) = 1 \ \text{and} \\ 
\text{\tr~accepting} \Rightarrow \ (x, w) \in \mathcal{R}
\end{array} 
:
\begin{array}{c}
             \params \leftarrow \textsf{Setup}(1^\lambda) \\
             (x, \st) \leftarrow \mathcal{A}(\params) \\
(\textsf{tr}, w) \leftarrow E^{\textsf{Record}(P^*, \params, x, \st)}(\params, x)
\end{array}
\right]
\]

\end{definition}

%\alaninline{About the above definition: after reading [GI08] I think the adversary outputs a claim $X$ and a \emph{state} $\st$ (which may or may not be a witness). Otherwise you aren't considering adversaries that try to prove a claim without knowing a witness. I marked my proposed changes in blue because I'm not sure.}

\paragraph{Generalized special soundness} The following lemma was proven by Bootle~\emph{et al.}~\cite{EC:BCCGP16} as a helpful tool for showing that an interactive argument has witness-extended emulation. It reduces the analysis to a generalized version of special soundness. 

Consider a public-coin interactive argument with $r$ rounds and verifier challenges sampled from an exponentially large message space. An \textbf{$\mathbf{(n_1,...,n_r)}$-tree of accepting transcripts} for the interactive argument on input $x$ is defined as follows. The root of the tree is labelled with the statement $x$. The tree has $r$ depth. Each node at depth $i < r$ has $n_i$ children, and each child is labelled with a distinct value for the $i$th challenge. An edge from a parent node to a child node is labelled with a message from prover to verifier. Every path from the root to a leaf corresponds to an accepting transcript, hence there are $\prod_{i=1}^r n_i$ distinct accepting transcripts overall. 

%\begin{lemma}[Forking lemma~\cite{EC:BCCGP16}] 
%\label{lem:forking}
%Let $(\textsf{Setup}, P, V)$ be an $r$-round public-coin interactive protocol for $\mathcal{R}$. Let $\mathcal{X}$ be a PPT algorithm that given any $(n_1,...,n_r)$-tree of accepting transcripts for the statement $x$, with $n_i \geq 1$ for all $i$, outputs $w$ such that $(x, w) \in \mathcal{R}$ in expected polynomial time. Assuming $\prod_{i=1}^r n_i \leq \poly$, the interactive argument $(\textsf{Setup}, P, V)$ has witness-extended emulation. 
%\end{lemma}
\begin{lemma}[Generalized Forking Lemma~\cite{EC:BCCGP16}] \label{lemma:GFL}
Let $(\prover, \verifier)$ be an $r$-round public-coin interactive argument system for a relation $\mathcal{R}$. Let $\mathcal{T}$ be a tree-finder algorithm that, given access to a $\pro{Record}(\cdots)$ oracle with rewinding capability, runs in polynomial time and outputs an $({n_1}, \ldots, {n_r})$-tree of accepting transcripts with overwhelming probability. Let $\mathcal{X}$ be an extractor algorithm that, given access to $\mathcal{T}$'s output, runs in polynomial time and outputs a witness $w$ for the statement $x$ with overwhelming probability. Then $(\prover, \verifier)$ has witness-extended emulation.
\end{lemma}

We note that our phrasing of the Generalized Forking Lemma differs from that of Bootle~\emph{et al.}, which does not mention a tree-finder $\mathcal{T}$ and requires that the extractor $\mathcal{X}$ have success probability one. Nevertheless, the present statement, while weaker, follows directly from the proof of Bootle~\emph{et al.}

\paragraph{Zero knowledge} We recall the definition of \emph{honest verifier zero-knowledge} (HVZK) for interactive proofs. HVZK only considers simulating the view of a verifier that follows the protocol honestly. The Fiat-Shamir transform compiles public-coin proofs that have HVZK into non-interactive proofs that have statistical zero-knowledge (for malicious verifiers). \ben{TODO: cite appropriate works, Bellare-Rogaway, more recent for more than constant round} 

\begin{definition}[HVZK for interactive arguments]
Let $\textsf{View}_{\langle P(x, w), V(x) \rangle}$ denote the view of the verifier in an interactive protocol described in Definition~\ref{def:argument} on common input $x$ and prover witness input $w$. The interactive protocol has $\delta$-statistical honest verifier zero-knowledge if there exists a probabilistic polynomial time algorithm $S$ such that for every $(x, w) \in \mathcal{R}$, the distribution $S(x)$ is $\delta$-close to $\textsf{View}_{\langle P(x, w), V(x) \rangle}$ (as distributions over the randomness of $P$ and $V$).
\end{definition}

\subsection{Commitment Schemes}

In defining the syntax of the various protocols, we use the following convention with respect to public values (known to both the prover and the verifier) and secret ones (known only to the prover). In any list of arguments or returned tuple $(a, b, c; d, e)$ those variables listed before the semicolon are public, and those variables listed after it are secret. When there is no secret information, the semicolon is omitted.

\begin{definition}[Commitment scheme]
A commitment scheme $\Gamma$ is a tuple $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open})$ of PPT algorithms where:
\begin{itemize}
    \item $\pro{Setup}(1^\lambda) \rightarrow \params$ generates public parameters $\params$;
    \item $\pro{Commit}(\params; x) \rightarrow (c; r)$ takes a secret message $x$ and outputs a public commitment $c$ and (optionally) a secret opening hint $r$ (which might or might not be the randomness used in the computation).
    \item $\pro{Open}(\params, c, x, r) \rightarrow b \in \{0, 1\}$ verifies the opening of commitment $c$ to the message $x$ provided with the opening hint $r$. 
\end{itemize}

A commitment scheme $\Gamma$ is \defn{binding} if for all PPT adversaries $\adv$:
\[
    \Pr\left[
        b_0 = b_1 \neq 0 \, \wedge \, x_0 \neq x_1 \ : \
        \begin{array}{l}
             \params \gets \pro{Setup}(1^\lambda) \\
             (c, x_0, x_1, r_0, r_1) \gets \adv(\params) \\
             b_0 \gets \pro{Open}(\params, c, x_0, r_0) \\
             b_1 \gets \pro{Open}(\params, c, x_1, r_1) \\
        \end{array}
    \right] \leq \negl \enspace 
\]

%\ben{We don't use the hiding property so why present?} \alan{For the ZK Eval protocol, maybe. Not sure yet.}
\begin{comment}
A commitment scheme $\Gamma$ is \defn{hiding} if for all probabilistic polynomial time adversaries $\adv=(\adv_0,\adv_1)$,
\[
    \left|
        1 - 2\Pr\left[
            \hat{b} = b \ : \
        \begin{array}{l}
             \params \gets \pro{Setup}(1^\lambda) \\
             (\state, x_0, x_1) \gets \adv_0(\params) \\
             b \sample \{0,1\} \\
             (\gr{C}; *) \gets \pro{Commit}(\params; x_b) \\
             \hat{b} \gets \adv_1(\state, \gr{C})
        \end{array}
        \right]
    \right| \leq \negl \enspace .
\]
\end{comment}
\end{definition}

We now extend the syntax to polynomial commitment schemes. The following definition generalizes that of Kate~\emph{et. al.}~\cite{AC:KatZavGol10} to allow interactive evaluation proofs. It also stipulates that the polynomial's degree be an argument to the protocol, contrary to Kate~\emph{et al.} where the degree is known and fixed.

\begin{definition} (Polynomial commitment) 
A polynomial commitment scheme is a tuple of protocols $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open}, \pro{Eval})$ where $(\pro{Setup},$ $\pro{Commit}, \pro{Open})$ is a binding commitment scheme for a message space $R[X]$ of polynomials over some ring $R$: 

\begin{itemize}
    \item $\pro{Eval}(\params, c, z, y, d[, \mu]; f(X)) \rightarrow b \in \{0, 1\}$ is an interactive public-coin protocol between a PPT prover $\prover$ and verifier $\verifier$. Both $\prover$ and $\verifier$ have as input a commitment $c$, points $z, y \in R$ for the claimed input/output, and an integer $d$ for the degree. The prover additionally knows the opening of $c$ to a secret polynomial $f(X) \in R[X]$ with $\deg(f(X)) \leq d$. The protocol convinces the verifier that $f(z) = y$. \emph{In a multivariate extension of polynomial commitments, the input $\mu$ indicates the number of variables in the committed polynomial}.
   
\end{itemize}

A polynomial commitment scheme is \defn{correct} if an honest committer can successfully convince the verifier of any evaluation. Specifically, if the prover is honest then for all polynomials $f(X) \in R[X]$ and all points $z \in R$,
\[
    \Pr\left[b = 1 \ : \ \begin{array}{l}
        \params \gets \setup(1^\lambda) \\
        (c; r) \gets \pro{Commit}(\params, f(X)) \\
        y \gets f(z) \\
        d \gets \deg(f(X)) \\
        b \gets \pro{Eval}(\params, c, z, y, d; f(X), r) \\
    \end{array} \right] = 1 \enspace .
\]

A polynomial commitment scheme is \defn{evaluation binding} if no efficient adversary can convince the verifier that the committed polynomial $f(X)$ evaluates to different values $y_0 \neq y_1 \in R$ in the same point $z \in R$. Let $b \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \verifier\rangle}(c, z, y, d, \st)$ denote the verifier's output in an execution of this protocol with adversarial prover $\adv_1$ on public inputs $c, z, y, d$ and private adversary state $\st$. (The adversary may or may not know a witness polynomial $f(X)$). Evaluation binding requires that for all probabilistic polynomial-time adversaries $\adv = (\adv_0, \adv_1)$,
\[
    \Pr\left[
         b_0 = b_1 \neq 0 \, \wedge \, y_0 \neq y_1 \ 
         : \
       \begin{array}{l}
            \params \gets \pro{Setup}(1^\lambda) \\
            (c, z, y_0, y_1, d_0, d_1, \st_0, \st_1) \gets \adv_0(\params) \\
            b_0 \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \verifier} \rangle(\params, c, z, y_0, d_0; \st_0) \\
            b_1 \gets \pro{Eval}_{\langle \adv_1 \leftrightarrow \verifier} \rangle(\params, c, z, y_1, d_1; \st_1) \\
        \end{array}
    \right] \leq \negl \enspace .
\]
\end{definition}

The syntax generalizes naturally to multivariate polynomial commitment schemes. Specifically, one obtains the syntax for an $\mu$-variate polynomial commitment scheme by replacing all occurrences of $X$ and $z$ by their $\mu$-dimensional vector counterparts, $\mathbf{X}$ and $\mathbf{z}$.

\paragraph{Knowledge of coefficients} In our application of polynomial commitments to the construction of arguments of knowledge, we also require the polynomial commitment to satisfy a \emph{knowledge} property. Informally, we require that any successful prover in the $\eval$ protocol must \emph{know} a polynomial $f(X)$ such that $f(z) = y$ and $c$ is a commitment to $f(X)$. More formally, since $\eval$ is a public-coin interactive argument we define this knowledge property as a special case of witness-extended emulation (Definition~\ref{def:wee}). 

Define the following NP relation given $\params \leftarrow \pro{Setup}(1^\lambda)$: 

\[ 
\mathcal{R_\textsf{Eval}}(\params) = \left\{
\langle (c, z, y, d), (f(X), r) \rangle
: 
\begin{array}{l} 
f \in R[X] \ \text{and} \ \deg(f(X)) \leq d \ \text{and} \ f(z) = y \\ 
 \text{and} \ \pro{Open}(\params, c, f(X), r) = 1 \\
\end{array}
\right\}
\] 

The correctness definition above implies that if $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open}, \pro{Eval})$ is \emph{correct} then $\eval$ is a correct interactive argument for $\mathcal{R_\textsf{Eval}}(\params)$, with overwhelming probability over the randomness of $\pro{Setup}$. We say that $\Gamma$ has \textbf{witness-extended emulation} if $\eval$ has witness-extended emulation as an interactive argument for $\mathcal{R_\textsf{Eval}}(\params)$. 

It is easy to see that witness-extended emulation implies evaluation binding when $(\pro{Setup}, \pro{Commit}, \pro{Open})$ is a binding commitment scheme. If the adversary succeeds in $\eval$ on both $(c, z, y_0, d_0)$ and $(c, z, y_1, d_1)$ for $y_0 \neq y_1$ or $d_0 \neq d_1$ then the emulator obtains two distinct witnesses $f(X) \neq f'(X)$ and such that $c$ is a valid commitment to both. This would contradict the binding property of the commitment scheme. 

\paragraph{Opening individual coefficients} The coefficients of a committed polynomial can be revealed and checked all at once using $\pro{Open}$, however, in some cases it is useful to reveal an individual coefficient more efficiently (e.g. with sublinear communication). 
There is a generic one-round protocol for this that uses $\pro{Eval}$ as a black-box, and inherits the efficiency properties of $\pro{Eval}$. We present this in Section~\ref{sec:opencoefficient}. 

\paragraph{Inner product argument} Another helpful feature for polynomial commitment schemes is an inner product argument that shows for commitments $(c_1, c_2)$ to degree $d$ polynomials $(f_1, f_2)$ the inner product of their coefficient vectors $a = \langle f_1, f_2 \rangle$. We similarly show that this can be realized in one-round using polynomial commitments with black-box calls to $\pro{Eval}$. We present this in  Section~\ref{sec:innerproduct}. 

\subsection{Proofs of Exponentiation}
Wesolowski \cite{EC:Wesolowski19} introduced a simple yet powerful proof of correct exponentiation (``PoE'') in groups of unknown order. A prover can efficiently convince a verifier that a large exponentiation in such a group was done correctly. For instance, the prover wishes to convince the verifier that $\gr{w} = \gr{u}^x$ for known group elements $\gr{u}, \gr{w} \in \mathbb{G}$ and exponent $x \in \mathbb{Z}$, and the verifier wants to verify this with much less work than performing the exponentiation. To do this, the verifier samples a large enough prime $\ell$ at random and the prover provides him with $\gr{Q} \gets \gr{u}^q$ where $q = \lfloor \frac{x}{\ell} \rfloor$. The verifier then simply computes the remainder $r \gets (x \mod \ell)$ and checks that $\gr{Q}^\ell\gr{u}^r = \gr{w}$. The protocol is an argument for the relation $\mathcal{R}_\mathsf{PoE} = \left\{ \langle(\gr{u}, \gr{w}, x), \varnothing\rangle \ : \ \gr{u}^x = \gr{w} \right\}$.

%Boneh~\emph{et al.}~\cite{C:BonBunFis19} add zero-knowledge to this protocol. Specifically, this extension enables the prover to prove that he knows an $x$ such that $\gr{w} = \gr{u}^x$ even while keeping $x$ secret. In the language of arguments and relations, it is an argument of knowledge for the relation $\mathcal{R}_\mathsf{PoKE} = \left\{ \langle(\gr{u}, \gr{w}), x\rangle \ : \ \gr{u}^x = \gr{w} \right\}$. We cover only the more efficient variant, PoKE2. While PoE has a security reduction to the Adaptive Root Assumption, PoKE2 is only provably secure in the generic group model.
\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{PoE}(\gr{u}, \gr{w}, x):$
	\begin{enumerate}[nolistsep]
		    \item \verifier samples $\ell \sample \primes$ and sends $\ell$ to \prover
		    \item \prover computes quotient $q$ and remainder $r$ such that $x = q\ell + r$ and $r \in \{0, \ldots, \ell-1\}$
		    \item \prover computes $\gr{Q} \gets \gr{u}^q$ and sends it to \verifier
		    \item \verifier computes $r \gets (x \mod \ell)$ and checks that $\gr{Q}^\ell\gr{u}^r = \gr{w}$
		    \item \pcif{}check passes \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}
Wesolowski showed that an adversary that succeeds in the $\textsf{PoE}$ protocol for statements not in $\mathcal{R}_{\textsf{PoE}}$ can compute adaptive roots in the group of unknown order $\GG$.

\begin{lemma}[\textsf{PoE} soundness~\cite{EC:Wesolowski19}]
\label{lem:poe}
\textsf{PoE} is an argument system for  Relation $\mathcal{R}_\textsf{PoE}$ with negligible soundness error,
assuming the Adaptive Root Assumption (Assumption \ref{assum:adaptiveroot}) holds for~$\ggen$.
\end{lemma}

\section{Polynomial Commitments from Groups of Unknown Order}
\label{sec:protocol}

\subsection{Polynomial Encoding}
\label{sec:encoding}
At the heart of our protocol is an encoding of integer polynomials with bounded coefficients as integers with useful homomorphic properties. To extend the encoding to polynomials over an odd prime field $\mathbb{F}_p$, we first lift them to the ring of polynomials over the integers by selecting representatives from $\{-\frac{p-1}{2}, \ldots, \frac{p-1}{2}\}$ for each coefficient. The lifted polynomial has bounded integer coefficients and can hence be mapped into the integers.

the set $B_{b}:=\{x \in \ZZ \, | \, \vert x \vert  \leq b\}$ of integers with absolute value less than or equal to $b$. In a slight abuse of notation we write $B_{b}[X]\subset \mathbb{Z}[X]$ as the set of integer polynomials with bounded coefficients. 

\paragraph{Encoding}
For a ``large'' integer $q$, the map $\mathsf{Enc} : \mathbb{Z}[X] \rightarrow \mathbb{Z}, \, p(X) \mapsto p(q)$ is a unique encoding of polynomials with coefficients bounded by $b<q/2$ in absolute value. Specifically, this map is injective for the domain $B_{b<q/2}[X]$, and it maps to the alphabet $\mathbb{Z}$. 
\paragraph{Decoding}
Decoding works as follows. Define the partial sum $S_k := \sum_{i=0}^k f_i q^i$ with $S_{-1} := 0$ and observe that when $(S_k \bmod q^{k+1}) > q^{k+1}/2$ then $S_k < 0$ whereas when $(S_k \bmod q^{k+1}) < q^{k+1}/2$ then $S_k \geq 0$. 
So when decoding $y \in \mathbb{Z}$, we can get $S_k$ for any $k$ by setting $S_k$ to $y \bmod q^{k+1}$ if $y \bmod q^{k+1}$ is less than $\frac{q^{k+1}}{2}$ or to $q^{k+1}- (y \bmod q^{k+1})$ otherwise.
Two consecutive partial sums yield a coefficient of $f(X)$: $f_k = \frac{S_{k} - S_{k-1}}{q^{k}} \in B_{b}$. These operations give rise to the following algorithm.\\
\begin{minipage}{\textwidth}
\begin{mdframed}
\begin{flushleft}
	$\pro{Dec}(y \in \mathbb{Z}):$
	\begin{enumerate}[nolistsep]
	    \item \textbf{for each} $k$ \textbf{in} $[0, \, \lfloor \log_q(|y|)\rfloor]$ \textbf{do:}\\
		\item \pcind[1] $S_{k-1} \gets (y \bmod q^{k})$
		\item \pcind[1] \pcif{$S_{k-1} > q^{k}/2$} \textbf{then} $S_{k-1} \gets q^{k}-S_{k-1}$ \textbf{end if}
		\item \pcind[1] $S_k \gets (y \bmod q^{k+1})$
		\item \pcind[1] \pcif{$S_{k} > q^{k+1}/2$} \textbf{then} $S_{k} \gets q^{k+1}-S_{k}$ \textbf{end if}
		\item \pcind[1] $f_k \gets (S_{k} - S_{k-1}) / q^k$
		\item \pcreturn $f(X) = \sum_{i=0}^{\lfloor \log_q(|y|)\rfloor} f_i X^i$
	\end{enumerate} 
\end{flushleft}
\end{mdframed}
\end{minipage}

\begin{fact}
	The encoding scheme is uniquely decodable for polynomials in $B_{b}[X]$ if $b<q/2$.
\end{fact}
The fact follows from $f(q)\in \ZZ$ being a unique integer representation of polynomials with coefficients bounded in absolute value by $b$ such that $b<q/2$. In particular for any partial sum $S_i$ we have $|S_i|<\frac{q^{i+1}}{2}$. From this it follows that $S_i-S_{k-i}=f_i \cdot q^i$.  

Note that the encoding has limited homomorphic properties: $\enc(g(X))+\enc(h(X))=\enc(g(X)+h(X))$ if $g(X)+h(X)\in B_{b}$, \emph{i.e.}, if all its coefficients are less than $q/2$ in absolute value. This constraint is satisfied for example if the coefficients of $g$ and $h$ are less than $q/4$ in magnitude. Additionally, $\enc(g(X))\cdot \enc(h(X))=\enc(g(X)\cdot h(X))$ if $g(X)\cdot h(X)\in B_{b}$.

\paragraph{Encoding of dyadic rational polynomials.}
In class groups there exists an algorithm to compute square roots of any element originally described by Gauß (modern description by Bosma and Stevenhagen~\cite{jtn/BosSte96}). As a result, in class groups an adversary can also commit to \defn{dyadic rationals} $\mathbb{D}:=\{\frac{x}{2^k} : \ x \in \ZZ \wedge k \in \NN\}$, in addition to integers. When using class groups we therefore need to extend the encoding scheme accordingly. 

The encoding map is identical, except lifted to the dyadic rationals: $\mathsf{Enc} : \mathbb{D}[X] \rightarrow \mathbb{D}, \, g(X) \mapsto g(q)$. The main difference with respect to the integer encoding scheme will be that decoding works for dyadic rationals where \emph{both the numerator and the denominator are bounded}. Let $N \in \NN$ be a bound on the absolute value of the numerator and $2^D\in \NN$ be a bound on the value of the denominator, and let $Q(N, D) :=\{\frac{x}{2^a} \in \mathbb{D} : \ |x|\leq N \wedge a \leq D\}$ denote the set of such bounded dyadic rationals. The encoding scheme is uniquely decodable if $N \cdot 2^a < q/2$.
 
Note that denominator of $g(q)$ is bounded by $2^D$. To decode such a dyadic rational, compute the integer $y \gets g(q) \cdot 2^{D}\in \ZZ$  and use the decoding algorithm described above to decode a polynomial $f(X)$ in $B_{q/2}[X]$. From $f(X)$ one derives the polynomial  $g(X) \gets \frac{f(X)}{2^D} \in Q(N, \frac{q}{2^D})[X]$ through division. If the integer polynomial encoding is uniquely decodable, then so is the scheme for dyadic rational polynomials. If $q$ is a power of $2$, then an adversary can encode Laurent polynomials, \emph{i.e.}, polynomials where some terms have negative powers. In order to disallow negative powers, $q$ must be odd.

\subsection{Polynomial Commitment}

We now present our main technical contribution: a polynomial commitment scheme with an efficient evaluation protocol based on a group of unknown order $\GG$. For polynomials of degree $d=\poly$ the evaluation protocol uses $1+\lceil\log_2(d+1)\rceil$ rounds and $O(\log(d))$ communication and verifier work.

Exponentiation in groups of unknown order is a succinct and homomorphic cryptographic commitments to an integer.
Using the integer encoding of polynomials, or their encoding as dyadic rationals, above we can simply commit to a polynomial $f(X)$ with bounded coefficients by computing $\gr{g}^{f(q)} \in \GG$. Every polynomial in $\ZZ_p[X]$ naturally maps to an integer polynomial with coefficients in $B_{\frac{p-1}{2}}$. The commitment scheme, therefore, supports committing to polynomials in $\ZZ_p[X]$ for $p \leq q$. Interestingly, neither $p$ nor the degree $d$ need to be specified in the setup. As long as $q$ and ``big enough'' they can be freely chosen.\alan{Todo: make this observation elsewhere.} %In class groups there is an efficient algorithm to compute square roots, and as a result, a prover can also commit to dyadic rationals. Since every dyadic rational corresponds to a unique element in $\ZZ_p$ we can simply extend the encoding to work for polynomials with bounded dyadic rational coefficients. The only difference is that we require $q$ to be odd such that the prover cannot commit to polynomials with negative powers. We will discuss the relationship between $p$, $d$ and $q$ in more detail later but first we describe the setup, commitment and opening algorithms:


\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{Setup}(1^\secpar):$
		\begin{enumerate}[nolistsep]
			\item $ \GG \sample \ggen(\secpar)$
			\item $ \gr{g} \sample \GG$
			%\item $q \gets 2^k$ such that $q > (d+1) \cdot 2\cdot p^{\log_2(d+1)+1} $
			\item Pick a prime $p\in \NN$ such that $\lceil\log_2(p)\rceil=\lambda$.
			\item Pick a sufficiently large and odd $q\in \NN$ (See discussion above)
			\item $\pcreturn \params = (\secpar,\GG,\gr{g},p,q)$
		\end{enumerate}
	$\pro{Commit}(\crs;f(X) \in B_{p}[X]):$ \pccomment{$f(X)\equiv \bar{f}(X) \mod p$ for  $\bar{f}(X)\in \ZZ_p[X]$}
		\begin{enumerate}[nolistsep]
			\item $\gr{C} \gets \gr{g}^{f(q)}$
			\item $\pcreturn (\gr{C};f(X))$
		\end{enumerate}
	$\pro{Open}(\crs,\gr{C}f(X)):$ \pccomment{$f(X) \in B_{b}[X]\subset\mathbb{Z}[X]$ for $b<q/2$}
		\begin{enumerate}[nolistsep]
		    \item \prover sends $f(X)$ to \verifier.
		   % 				\item \verifier checks that $\bar{f}(X) = f(X) \mod p$
		    \item \verifier checks that $f(X)\in B_{b}[X]$ and $b<q/2$
			\item \verifier checks that $\gr{g}^{f(q)} = \gr{C}$ \pccomment{Can be outsourced using $\textsf{PoE}(\gr{g},\gr{C},f(q))$}
			\item \pcif all checks pass \textbf{then} \pcreturn $1$ \textbf{else} \pcreturn $0$
		\end{enumerate}
		\end{flushleft}
\end{minipage}
\end{mdframed}
%Opening the commitment can be simply done by rerunning the commitment algorithm. Additionally a proof of exponentiation (PoE) can be used to increase verifier efficiency.
The commitment inherits the homomorphic properties of the integer encoding. Assume that we are committing to representations of polynomials in $\ZZ_p[X]$, \emph{i.e.}, polynomials with coefficients bounded by $p$. Then the commitment scheme supports up to $\frac{q}{p}$ homomorphic additions. Equivalently, when raising a commitment to a weight $\alpha$, the size of the coefficients grows by at most a factor of $|\alpha|$. We use this property to build an efficient $\eval$ protocol. 

The core idea of the $\eval$ protocol is to reduce the statement from one about a polynomial $f(X)$ of degree $d$ to one about a polynomial of degree $d'=\frac{d+1}{2}-1$. For simplicity assume that $d+1$ is a power of $2$.
The prover splits $f(X)$ into $f_L(X)$ and $f_R(X)$ such that $f(X) = f_L(X)+X^{d'+1} f_R(X)$ and such that both polynomials have degree at most $d'$. Then he proves that $f'(X)=\alpha \cdot f_L(X) + f_R(X)$ has degree $d'$ for a random challenge $\alpha\in [-\frac{p-1}{2},\frac{p-1}{2}]$. 

If the prover wants to show, in addition to the previous, that $f(z)=y\bmod p$, then he can simply provide $y_L=f_L(z)\bmod p$ and $y_R=f_R(z)\bmod p$ and show that $y_L + z^{d'+1} \cdot y_R \bmod p=y$. Note that the verifier can compute $y' = f'(z) = \alpha \cdot y_L + y_R \bmod p$ from $y_L$ and $y_R$.

The proof recursively repeats this reduction by using $f'(X),z,y'$ and $d'$ as the input. In the final step, the prover simply sends the constant polynomial $f$ and the verifier can check that $f \equiv y \bmod p$. Note that $|f|< (\frac{p}{2})^{\log_2(d+1)+1}$ so an integer encoding of $f_0$ requires at most $\lceil \log_2(d+1) \cdot \log_2(p)\rceil$ bits.

Using the integer encoding (with a sufficiently large $q=O(p^{\log(d)})$) and exponentiation in groups of unknown order as the commitments to these integers, we can derive an efficient $\eval$ protocol with logarithmic communication. To achieve verifier efficiency we need to build an efficient check that $f(X) = f_L(X) + X^{d'+1} f_R(X)$ given committed $f(X), f_L(X)$ and $f_R(X)$. Concretely, the verifier checks that $\gr{C} = \gr{C}_L \gr{C}_R^{q^{d'+1}}$ for $\gr{C}=\gr{g}^{f(q)}$, $\gr{C}_L=\gr{g}^{f_L(q)}$ and $\gr{C}_R=\gr{g}^{f_R(q)}$.

The issue here is the derivation of $\gr{C}_R^{q^{d'+1}}$ from $\gr{C}_R$, because $q^{d'+1}$ is large and the verifier's work for verifying this exponentiation naïvely is linear in $d'$.
Fortunately, Wesolowski~\cite{EC:Wesolowski19} and Pietrzak~\cite{EPRINT:Pietrzak18b} provide efficient proofs of exponentiations (\textsf{PoE}) to solve a similar problem in the context of verifiable delay functions~\cite{C:BBBF18}. Specifically, the prover provides the verifier with both the input and the output of the exponentiation, and using interaction the verifier only needs to perform exponentiations with small exponents, to verify the statement's correctness. Wesolowski's \textsf{PoE} is public coin, has constant communication and verification time, and is thus particularly well-suited here.

We now present the full $\eval$ protocol below. $\eval$ uses as a subroutine \pro{EvalBounded} which additionally allows the specification of a bound on the size of the coefficients (other than $p$).  This can be particularly useful if commitments were homomorphically combined prior to the execution of $\pro{EvalBounded}$. Recall that any homomorphic operation increases the bound on the size of the coefficients.

%This intuitive description omits special care afforded to the case where the degree of the polynomial is not one less than a power of two. To take care of this, the left polynomial is guaranteed to have odd degree (unless in the last step when it is zero), and the right half polynomial $f_R(X)$ is shifted to the right by one digit whenever its degree is even. The evaluation $y_R$ and commitment $\gr{C}_R$ are adapted accordingly.
\begin{mdframed}
Informal information theoretic $\eval$ protocol: $\prover$ and $\verifier$ have homomorphic oracle access to an integer $f(q)$ denoted by $[[f(q)]]$. $\prover$  has a degree $d$ polynomial $f(X)$ as a witness. Statement: $f(z)\bmod p=y$
	\begin{itemize}[nolistsep]
		\item Prover computes degree $d'=\frac{d+1}{2}-1$ polynomial $f_L(X)$ and $f_R(X)$ such that $f_L(X)+C^{d'+1}f_R(X)$
		\item Prover sends $[[f_L(q)]]$ and $[[f_R(q)]]$ as well as $y_L\gets f_L(z)\bmod p$ and $y_R\gets f_R(z)\bmod p$.
		\item Verifier checks $[[f_L(q)]]+q^{d'+1}[[f_R(q)]]=[[f(q)]]$ and $y_L+z^{d'+1} y_R =y$.
		\item Prover and Verifier recurse on $[[f'(q)]]=\alpha [[f_L(q)]]+[[f_R(q)]]$ for the statement $f'(z)=\alpha y_L +y_R \bmod p$ for a random challenge $\alpha$.
		\item When the degree $d=0$ the $\prover$ sends the constant $f$ to $\verifier$
		\item $\verifier$ checks that $f$ is a small constant and that $f$ is equivalent to the oracle value. Additionally it checks that $f\bmod p =y$
	\end{itemize}
\end{mdframed}

\begin{mdframed}
\begin{minipage}{\textwidth}
			$\pro{Eval}(\crs, \gr{C}\in \GG, z\in \ZZ_p, y\in \ZZ_p, d \in \NN; \bar{f}(X)\in \ZZ_p[X]) :$ \pccomment{$\bar{f}(X) = \sum_{i=0}^d \bar{f}_i X^i$}
			\begin{enumerate}[nolistsep]
			\item \prover computes $f_i \in [-\frac{p-1}{2},\frac{p-1}{2}]$ such that $f_i\equiv \bar{f}_i\bmod p$ for all $i\in[0,d]$.
			\item \prover computes $f(X)\gets \sum_{i=0}^d f_i \cdot X^{i}\in B_p[X]\subset \ZZ[X]$
			\item \prover and \verifier run $\pro{EvalBounded}(\params,\gr{C},z,y,d,p;f(X))$
		    \end{enumerate}
		    		\vspace{1em}
		$\pro{EvalBounded}(\crs,\gr{C}\in \GG,z\in \ZZ_p,y\in \ZZ_p,d\in \NN,b\in \ZZ;f(X)\in B_{b}[X])$		
	    \begin{enumerate}[nolistsep]
        \item \pcif $d=0$:
        \item \label{line:basestart}\pcind[1] \prover sends $f(X)\in \ZZ$ to the verifier. \pccomment{$f=f(X)$ is a constant}
        \item \pcind[1] \verifier checks that $b\cdot \mu_{p,d} < q$\pccomment{$\mu_{p,d}=O(p^{\log(d)})$ is a constant}
        %q/(2^{\lceil \log_2(d+1) \rceil+1} p^{2 \lceil \log_2(d+1) \rceil+1})$
        \item \pcind[1] \verifier checks that $|f|\leq b$
          \item \pcind[1] \verifier checks that $f\equiv y \bmod p$
                \item \label{line:baseend}\pcind[1] \verifier checks that $\gr{g}^{f}=\gr{C}$
\item \pcind[1] \verifier outputs $1$ \pcif all checks pass, $0$ otherwise.
          \item \pcif{$d+1$ is odd}
         \item \pcind[1]  $d'\gets d+1, \gr{C}'\gets \gr{C}^q$, $y'\gets y\cdot z \bmod p$ and $f'(X)\gets X \cdot f(X)$.
         \item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\crs,\gr{C}',z,y',d',bd;f'(X))$

        \item \pcelse: \pccomment{$d \geq 1$ and $d+1$ is even}
       
        \item \pcind[1] \prover and \verifier compute $d' \gets \frac{d+1}{2} - 1$
        \item \pcind[1] \prover computes $f_L(X) \gets \sum\limits_{i=0}^{d'} f_i \cdot X^i$ and $f_R(X)\gets\sum\limits_{i=0}^{d'} f_{d'+1+i}\cdot X^{i}$
        \item \pcind[1] \prover computes $y_L\gets f_L(z) \bmod p$ and $y_R\gets f_R(z)\bmod p$
        \item \pcind[1] \prover computes $\gr{C}_L \gets \gr{g}^{f_L(q)}$ and $\gr{C}_R \gets \gr{g}^{f_R(q)}$
        \item \pcind[1] \prover sends $y_L,y_R, \gr{C}_L, \gr{C}_R$ to \verifier. \pccomment{See Section \ref{subsec:optimiztion} for an optimization}
        \item \pcind[1] \verifier checks that $y=y_L+z^{d'+1}\cdot y_R \bmod p$, outputs $0$ if check fails.
        \item \pcind[1] \label{line:PoE} \prover and \verifier run $\pro{PoE}(\gr{C}_R, \gr{C}/\gr{C}_L, q^{d'+1})$\pccomment{Showing that $\gr{C}_L\gr{C}_R^{(q^{d'+1})}=\gr{C}$}
        \item \pcind[1] \verifier samples $\alpha \sample [-\frac{p-1}{2},\frac{p-1}{2}]$ and sends it to \prover
        \item \pcind[1] \prover and \verifier compute $y'\gets\alpha  y_L +y_R \bmod p$, $\gr{C}' \gets \gr{C}_L^\alpha  \gr{C}_R$, $b'\gets b \frac{p+1}{2}$. 
        \item \pcind[1] \prover computes $f'(X) \gets \alpha \cdot f_L(X) + f_R(X) \in \ZZ[X]$ \pccomment{$\deg(f'(X))=d'$}
        \item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}', z, y', d',b' ; f'(X))$
               \end{enumerate}
      \end{minipage}
\end{mdframed}

\paragraph{Hiding and Zero-knowledge.} Turning the polynomial commitment into a hiding scheme is easy by replacing $g^{\bar{f}(q)}$ with a Pedersen commitment to $\bar{f}(q)$ over $\GG$. The setup parameters must contain two independent generators $g, h$ for which the discrete logarithm between $g$ and $h$ is unknown. (Previously, in the non-hiding scheme, any generator would suffice). A commitment to $f \in \FF_p$ is then $g^{\bar{f}(q)} h^r$ for random $r \sample [0, 2^\lambda)$. If a trusted (or MPC) setup is acceptable then $g, h$ can be chosen such that $\langle g \rangle = \langle h \rangle$ generate the same subgroup (e.g. set $h = g^\alpha$ for large random $\alpha$). In this case the commitment is statistically hiding~\cite{AC:DamFuj02}. 

The setup can be made publicly verifiable using a hash function onto the group $\GG$, i.e. a collision-resistant function $H: \{0,1\}^* \rightarrow \GG$ that behaves as a random oracle. In this case the commitment is computationally hiding under a \emph{subgroup indistinguishability assumption}, as formulated by Brakerski and Goldwasser~\cite{C:BraGol10}. A subgroup $\GG' \subseteq \GG$ is computationally indistinguishable from $\GG$ if $g' \sample \GG'$ is computationally indistinguishable from $g \sample \GG$. A sufficient assumption that would imply Pedersen commitments with the random oracle setup are computationally hiding is that for $h \sample \GG$, the subgroup $\langle h \rangle$ is indistinguishable from $\GG$. This basic subgroup indistinguishability assumption holds in generic groups of unknown order. 

In class groups we need to be careful applying this subgroup indistinguishability assumption because Gauss's square root algorithm may be used to test quadratic residuosity efficiently, i.e. it is possible to distinguish the subgroup of quadratic residues from non-quadratic residues. However, the class group can be constructed such that the order is guaranteed to be odd~\cite{PKC/BucHam01}, in which case every element has a $2^n$ root for any $n \geq 0$.% For class groups, we assume the subgroup indistinguishability assumption applies in $NQR$, the subgroup of non-quadratic residues. It is easy to convert the deterministic $H$ into a PPT hash function onto $NQR$ by iterating until hitting the first quadratic non-residue (succeeding in an expected constant number of iterations). 

It is also possible to transform the interactive $\eval$ scheme into one with HVZK. We sketch one way to do this in Appendix~\ref{apx:zeroknowledge}. This transformation impacts performance as it requires sending several extra group elements per level of recursion resulting in a multiplicative increase in proof size. It also requires a stronger security assumption due to a reliance on a \emph{proof of knowledge of exponent} (PoKE) by Boneh et. al.~\cite{C:BonBunFis19}. The PoKE protocol has been proven secure in the generic group model, but does not reduce to any concrete falsifiable assumption. 


\subsection{Analysis of polynomial commitment scheme} 

\begin{lemma}
\label{lem:correctness}
	The polynomial commitment scheme is correct for polynomials in $\ZZ_p[X]$ of degree at most $d$ if $q> (p-1) (\frac{p+1}{2})^{\lceil \log_2(d+1)\rceil}$.
\end{lemma}
\begin{proof}
In order to ensure correctness we must ensure that $b< q/2$ and that $|f|\leq b$. To show this we show that in each recursion step the honest prover's witness polynomial has coefficients bounded by $b$ and has degree $d$. 
We argue inductively that for each recursive call of $\pro{EvalBounded}$ the following constraints on the inputs are satisfied: The degree of $f(X)$ is bounded by $d$. $\gr{C}$ encodes the polynomial, \emph{i.e.}, $\gr{C}=\gr{g}^{f(q)}$ and $f(X)\in B_b$. Also $f(z) = y\bmod p$.

Initially, during the execution of $\eval$, the prover maps the coefficients of a polynomial $\bar{f}(X)\in \ZZ_p$ to an integer polynomial $f(X)$ with coefficients in $B_{\frac{p+1}{2}}$ and degree at most $d$ such that $\gr{C}=\gr{g}^{f(q)}$. Additionally $f(z)\bmod p=\bar{f}(z)=y$.

 In a recursion steps where $d+1$ is odd, $f'(X)=X\cdot f(X)$ is a polynomial of degree $d+1$ such that $\gr{C}'=\gr{C}^q=\gr{g}^{q\cdot f(q)}=\gr{g}^{f'(X)}$ and the bound $b$ is unchanged as are the coefficients. Also, $f'(z)\bmod p = z \cdot f(z) \bmod p=z\cdot y\bmod p = y' \bmod p$. If $d+1$ is odd, then in the next step $d+1$ must be even.
 
 If $d+1$ is even then, $\prover$ computes $f_L(X)$ and $f_R(X)$ such that $f_L(X)+X^{\frac{d+1}{2}} f_R(X)=f(X)$. Consequently $f(z) \bmod p=f_L(z)+ z^{\frac{d+1}{2}} f_R(z)\bmod p=y_L+z^{\frac{d+1}{2}}  y_R\bmod p =y$. The \textsf{PoE} protocol has perfect correctness so $\gr{g}^{f_L(q)+q^{\frac{d+1}{2}} f_R(X)}=\gr{C}_L\gr{C}_R^{(q^{\frac{d+1}{2}})}=\gr{C}$.
 Finally $f'(X)=\alpha f_L(X) + f_R(X)\in B_{\frac{p+1}{2}\cdot b}$ is a degree $d$ polynomial with coefficients bounded in absolute value by $(\frac{p+1}{2})\cdot b$. This is precisely the value of $b'$ the input to the next call of $\pro{EvalBounded}$. The value $y'$ is also correct:
$f'(z)\bmod p=\alpha f_L(z) +f_R(z) \bmod p= \alpha y_L +y_R\bmod p=y'$
 
 There are exactly $\lceil\log_2(d+1)\rceil$ recursion steps with even $d+1$. In the final recursion step we therefore have $b=\frac{p-1}{2}(\frac{p+1}{2})^{\lceil\log_2(d+1)\rceil}$ and as such the requirement that $q/2>\frac{p-1}{2}(\frac{p+1}{2})^{\lceil\log_2(d+1)\rceil}$. 
 So if $q>(p-1) (\frac{p+1}{2})^{\lceil \log_2(d+1)\rceil}$ then all verifier checks pass and the verifier outputs $1$.
\end{proof} 
 
\begin{lemma}
	The polynomial commitment scheme is binding for polynomials in $B_b[X]$ for $b<q/2$ if either the Order Assumption or the Strong RSA Assumption hold.
\end{lemma}
\begin{proof}
    Assume that there is an adversary that breaks the binding property of the scheme. Specifically, assume that some probabilistic polynomial time algorithm $\adv$ takes as input $\params$ and outputs $\gr{C} \in \GG, f(X) \in B_{b}[X], f'(X)\in B_{b}[X]$ such that with non-negligble probability $\pro{Open}(\params, \gr{C}, \bar{f}(X), f(X)) = \pro{Open}(\params, \gr{C}, \bar{f'}(X), f'(X)) = 1$ and $\bar{f}(X) \neq \bar{f'}(X)$. We proceed to show that this implies a violation of the Order Assumption~(Assumption \ref{assum:order}) and the Strong RSA Assumption~(Assumption \ref{assum:strongRSA}). The assumptions are incomparable so we show that either suffices to achieve the binding property of the commitment scheme.
    
	If $f(X)\neq f'(X)$ and $q/2>b$ then $f(q)\neq f'(q)\in \ZZ$. Since $\gr{g}^{f(q)}=\gr{g}^{f'(q)}=\gr{C}$ we have that $\gr{g}^{f(q)-f'(q)}=1$. This directly breaks the Order Assumption and we can also create an adversary $\adv_{RSA}$ that breaks the Strong RSA Assumption. To do so the $\adv_{RSA}$ picks an odd prime $\ell$ that is co-prime with $f(q)-f'(q)$ and computes $\gr{u}\gets \gr{g}^{\ell^{-1} \bmod (f(q)-f'(q))}$ as the $\ell$th root of $\gr{g}$.
\end{proof}


We now proceed to the main security theorem, which states that the evaluation protocol has witness-extended emulation. We start with a high-level intuitive overview where we also identify potential obstacles.

\paragraph{Proof idea.} Consider the information theoretic version of the $\eval$ protocol, where the prover sends the integer polynomials $f_L(X)$ and $f_R(X)$ in each round but the verifier does not read them.
In the final round the verifier receives $f$ such that $|f| \leq b$. The goal is to construct an extractor by recursively computing $f_L(X)$ and $f_R(X)$ from $f'(X)$.

In each round the extractor has $f'(X)=\alpha f_L(X)+ f_R(X)$. Using rewinding the extractor can also compute $f''(X)=\alpha' f_L(X)+ f_R(X)$. From $f'(X)$, $f''(X)$, $\alpha$ and $\alpha'$ it is easy to compute $f_L(X)$ and $f_R(X)$. The extractor then computes $f(X)=f_L(X)+x^{d'+1} f_R(X)$.

A careful analysis shows that if the coefficients of $f'(X)$ are bounded by $b$ then $f_L(X)$ and $f_R(X)$ must have coefficients bounded by $b \cdot p$ in absolute value. Using a similar analysis we can show that $f(z)\bmod p=y$ for the extracted polynomial $f(X)$.

This argument shows that there is an extractor capable of extracting the witness $f(X)$ from a binary tree of accepting transcripts. As a result, Bootle~\emph{et al.}'s generalized forking lemma applies and establishes that the protocol has witness-extended emulation.

The full proof takes into account the cryptographic compilation of the protocol using the integer encoding and the commitment scheme based on groups of unknown order. Additionally the full proof will need to support dyadic rationals because taking square roots is easy in class groups.

\paragraph{Security of $\textsf{PoE}$ substitutions}
We first begin by showing that we can safely replace all of the $\textsf{PoE}$ evaluations with direct verification checks. Concretely, under the Adaptive Root Assumption, the $\eval$ protocol is as secure as the protocol $\eval'$ in which all $\textsf{PoE}$s are replaced by direct checks. We show that the witness-extended emulation for $\eval'$ implies the same property for $\eval$. This is useful because we will later show how to can build an extractor for $\eval'$, thereby showing that it has witness-extended emulation.
\begin{lemma} \label{lemma:poe_security}
Let $\eval'$ be the protocol that is identical to $\eval$ but in line \ref{line:PoE} of $\pro{EvalBounded}$ $\verifier$ directly checks $\gr{C}_L\gr{C}_R^{q^{d'+1}}=\gr{C}$ instead of using a $\textsf{PoE}$. If the Adaptive Root Assumption holds for $\ggen$, and $\eval'$ has witness-extended emulation for polynomials of degree $d=\poly$, then so does $\eval$.
\end{lemma}
\begin{proof}
We show that if an extractor $E'$, as defined in Definition~\ref{def:wee}, exists for the protocol $\eval'$ then we can construct an extractor $E$ for the protocol $\eval$. Specifically, $E$ simulates $E'$ and presents it with a $\pro{Record}'(\cdots)$ oracle, while extracting the witness from its own $\pro{Record}(\cdots)$ oracle.

Whenever $E'$ queries the $\pro{Record}'$ oracle, $E$ queries its $\pro{Record}$ oracle and relays the response after dropping those portions of the transcript that correspond to the $\mathsf{PoE}$ proofs. Whenever $E'$ rewinds its prover, so does $E$ rewind its prover. When $E'$ terminates by outputting a transcript-and-witness pair $(\mathsf{tr}', f(X))$, $E$ adds $\mathsf{PoE}$s into this transcript to obtain $\mathsf{tr}$ and outputs $(\mathsf{tr}, f(X))$.

For each PPT adversary $(\adv,P^*)$, $E$ will receive a polynomial number of transcripts from its $\pro{Record}$ oracle. Any transcript $\tr$ of $\eval$ such that $\adv(\tr)=1$ and $\tr$ is accepting contains exactly $\lceil \log(d+1)\rceil$ $\textsf{PoE}s$ transcripts. 
So in total $E$ sees only a polynomial number of $\textsf{PoE}$ transcripts generated by a probabilistic polynomial-time prover and verifier. By Lemma~\ref{lem:poe} under the Adaptive Root Assumption, the probability that a polynomial time adversary can break the soundness of $\textsf{PoE}$, \emph{i.e.}, convince a verifier on a $\textsf{PoE}$ instance $(\gr{C}_R,\gr{C}/\gr{C}_{L},q^{d'+1})$, where $(\gr{C}_R,\gr{C}/\gr{C}_{L},q^{d'+1})\not\in\mathcal{R}_{\textsf{PoE}}$, is negligible. 
Consequently, the probability that the adversary can break $\textsf{PoE}$ on \emph{any} of the polynomial number of executions of $\mathsf{PoE}$ is still negligible.

This means that with overwhelming probability all transcripts are equivalent to having the verifier directly check $(\gr{C}_R,\gr{C}/\gr{C}_{L},q^{d'+1})\in\mathcal{R}_{\textsf{PoE}}$. By assumption, the witness-candidate $f(X)$ that $E'$ outputs is a valid witness if the transcript $\mathsf{tr}'$ that $E'$ also outputs is accepting. There is only one way to add $\mathsf{PoE}$ transcripts to $\mathsf{tr}'$ and this addition preserves the transcript's validity. So $\mathsf{tr}$ is an accepting transcript for $\pro{Eval}$ if and only if $\mathsf{tr}'$ is an accepting transcript for $\pro{Eval}'$. Therefore, $E'$ outputs a valid witness $f(X)$ whenever $E$ outputs a valid witness. This suffices to show that $\pro{Eval}$ has witness-extended emulation if $\pro{Eval}'$ has, and if the Adaptive Root Assumption holds for $\ggen$.
\end{proof}

\paragraph{Combining statements.} The $\eval$ protocol combines two statements into one by using a random linear combination of group elements, \emph{i.e.}, $\gr{C}'\gets \gr{C}_L^{\alpha}\gr{C}_R$. We now show that this step is sound and that given the discrete logarithm for $\gr{C}'$ we can extract the discrete logarithm for $\gr{C}_L$ and $\gr{C}_R$ we also show that the we can bound the size of the discrete logarithm. We show that this statement holds in two settings. First we consider a group $\GG$ were the standard Strong RSA Assumption holds and group elements are encodings of integers. 
%Move next part to after lemma?
Then we will show that in groups in which taking square roots is easy we can extract dyadic rationals using the Dyadic Strong RSA Assumption.
 %For $\GG \gets \ggen(\lambda)$, and $\gr{g}\sample \GG$. Let $(\gr{C}_L\in \GG,\gr{C}_R\in \GG,\alpha\in [0,p-1],f\in [0,b];\gr{g}^{f}=\gr{C}_L^{\alpha}\gr{C}_R)$ and  $(\gr{C}_L,\gr{C}_R,\alpha'\in [0,p-1],f'\in [0,b];\gr{g}^{f'}=\gr{C}_L^{\alpha'}\gr{C}_R)$  be two transcripts for $\alpha\neq \alpha'$.
\begin{lemma}[Combining for integer witnesses]
\label{lem:intrandomcombine}
	For $\GG \gets \ggen(\lambda)$, and $\gr{g}\sample \GG$. 
	Let $(z,\gr{C}_L,\gr{C}_R,y_L,y_R,\alpha,f,y)$ and  $(z,\gr{C}_L,\gr{C}_R,y_L,y_R,\alpha',f',y')$ be two transcripts such that $\gr{g}^{f}=\gr{C}_L^{\alpha}\gr{C}_R$ and $\gr{g}^{f'}=\gr{C}_L^{\alpha'}\gr{C}_R$ for group elements $\gr{C}_L,\gr{C}_R \in \GG$, and integers $\alpha,\alpha' \in  [-\frac{p-1}{2},\frac{p-1}{2}]$, $\alpha\neq \alpha'$. Further let $f,f'\in \ZZ$ be such that $f(X)\gets\dec(f)$ and $f'(X)\gets\dec(f')$ are degree $d$ bounded polynomials with coefficients bounded by $b$, \emph{i.e.}, $f(X),f'(X)\in B_{b}[X]\subset \ZZ[X]$. And finally let $y=f(z)\bmod p$ and $y'=f'(z)\bmod p$.
	 Then there exists a PPT algorithm $\mathcal{X}$ that given these transcripts computes either (1) $y_L,y_R\in \ZZ_p,f_L(X),f_R(X)\in B_{(p-1) \cdot b}[X]$  such that $f_L(z)=y_L\bmod p$ and $f_R(z)=y_R \bmod p$ or (2) an element in $\GG$ of known order or (3) a fractional root of $\gr{g}$.
\end{lemma}
\begin{proof}
	Using the transcripts we $\Delta_\alpha\gets\alpha-\alpha'$ and $\Delta_f\gets f-f'$ such that $\gr{C}_{L}^{\Delta_\alpha}=\gr{g}^{\Delta_f}$. 
 If $\frac{\Delta_f}{\Delta_\alpha}$ is not an integer then this gives us a fractional root of $\gr{g}$, that is the tuple $(\Delta_f,\Delta_\alpha,\gr{C}_{L})$.  
 If $\frac{\Delta_f}{\Delta_\alpha}$ on the other hand is an integer then we can compute $\gr{D}\gets\gr{g}^{\frac{\Delta_f}{\Delta_\alpha}}$. Either $\gr{D}=\gr{C}_{L}$ or $(\gr{D}/\gr{C}_{L})^{\Delta_\alpha}=1$, \emph{i.e.} $\gr{D}/\gr{C}_{L}$ is an element of known order.
   
  Otherwise $\gr{D} = \gr{C}_L$ and we have $\gr{C}_{L}=\gr{g}^{f_L}$ where $f_L=\frac{\Delta_f}{\Delta_\alpha}$ is an integer.
Additionally $\gr{C}_R=\gr{g}^{f_R}$ for $f_R\gets f-\alpha \cdot f_L$.

We now compute the corresponding polynomials $f_L(X)\gets \dec(f_L)$ and $f_R(X)\gets \dec(f_R)$.
Now if the coefficients $f_i$ and $f'_i\in [-b,b]$ and $\alpha,\alpha' \in [-\frac{p-1}{2},\frac{p-1}{2}]$ then by the triangle inequality we have that for the $i$th coefficient of $f_L(X)$, $f_{L,i}\in [-2b,2b]$. Additionally we have $f_{R,i}=\frac{f_i'\alpha-f_i \alpha'}{\Delta_\alpha}$. Using the triangle inequality again we have that $f_{R,i} \in [-(p-1) \cdot b, (p-1) \cdot b]$. For an odd prime $p$, $(p-1)\cdot p\geq 2b$. This gives us $f_L(X),f_R(X)\in B_{(p-1) \cdot b}$

Let $y_L=\frac{y-y'}{\Delta_\alpha} \bmod p=\frac{f(z)-f'(z)}{\Delta \alpha} \bmod p$ and $y_R= y-\alpha\frac{y-y'}{\Delta_\alpha} \bmod p$. Since $f_L(X)=\frac{f(X)-f'(X)}{\Delta \alpha}$ this shows that $y_L=f_L(z)\bmod p$ and $y_R=f_R(z)\bmod p$.
%The actual bound on f_{R,i} is b*(p-2)
\end{proof}


%PROOF FOR DYADIC RATIONALS
\begin{lemma}[Forking for dyadic rational witnesses]
	For $\GG \gets \ggen(\lambda)$, and $\gr{g}\sample \GG$. 
	Let $(\gr{C}_L,\gr{C}_R,\alpha,f)$ and  $(\gr{C}_L,\gr{C}_R,\alpha',f')$ be two transcripts such that $\gr{g}^{f}=\gr{C}_L^{\alpha}\gr{C}_R$ and $\gr{g}^{f'}=\gr{C}_L^{\alpha'}\gr{C}_R$ for group elements $\gr{C}_L,\gr{C}_R \in \GG$, and integers $\alpha,\alpha' \in  [-\frac{p-1}{2},\frac{p-1}{2}]$, $\alpha\neq \alpha'$. Further let $f,f'\in \mathbb{D}$ be such that $f(X)\gets\dec(f)$ and $f'(X)\gets\dec(f')$ are degree $d$ bounded polynomials with dyadic rational coefficients bounded by $N$ in the numerator and $2^D$ in the denominator, \emph{i.e.}, $f(X),f'(X)\in Q(N, D)[X]\subset \mathbb{D}[X]$.
	 There exists a PPT algorithm $\mathcal{X}$ that given these transcripts computes either $f_L(X),f_R(X)\in Q(N, (p-1)D)[X]$ or an element in $\GG$ of known order, or an $\ell$th root of $\gr{g}$ for some $\ell$ containing an odd factor.
\end{lemma}
\begin{proof}
\benedikt{write proof (Very similar to Lemma \ref{lem:intrandomcombine}, perhaps move lemma}
	
\end{proof}

We are now in a position to prove the main security statement.

%%%OLD THEOREM
\begin{theorem}~\label{thm:polycommitsecurity} 
	The polynomial commitment scheme for polynomials in $\ZZ_p[X]$ of degree at most $d=\poly$, instantiated using $q>(p-1)(\frac{p^2-1}{2})^{\lceil \log_2(d+1)\rceil}=O(p^{2\log(d)})$ and $\ggen$, has witness extended emulation (Definition \ref{def:wee}) if the Adaptive Root Assumption and the Strong RSA Assumption hold for $\ggen$.
\end{theorem}

\begin{proof}
We will prove security by showing that given a polynomial time adversary $\adv_{\eval}$ that succeeds in convincing an honest verifier in the $\eval$ protocol on any public input with non-negligible probability we can either (1) construct an adaptive root adversary $\adv_{\textsf{AR}}$, (2) extract an element of known order, and hence break the Order Assumption, (3) extract a fractional root of $\gr{g}\in \GG$ or (4) extract the polynomial $f(X)\in \ZZ[X]$ such that $f(X)$ has degree at most $d$ and the coefficients of $f(X)$ are integers bounded by $q/2$, such that $f(q)$ is a unique encoding of $f(X)$. Additionally $\gr{g}^{f(q)}=\gr{C}$ and $f(z) \bmod p=y$. The proof will use the general forking lemma (Lemma \ref{lem:forking}) to show that the polynomial commitment scheme has witness-extended emulation.

In particular we construct an extractor $\mathcal{X}$ that given transcripts with $2$ distinct challenges per round, \emph{i.e.}, $2^{\lceil\log_2(d+1)\rceil}<2 (d+1)$ transcripts in total, can compute either an opening to the commitment scheme, an element of known order, or a fractional root of $\gr{g}\in\GG$ as encoded in the public parameters $\params$.

Using Lemma \ref{lemma:poe_security} and under the Adaptive Root Assumption, it suffices to consider an extractor $\mathcal{X}$ that works on transcripts of $\eval'$ were all $\textsf{PoE}$s prove true statements. That is $\gr{C}_L\gr{C}_R^{q^{d'+1}}=\gr{C}$ on all transcripts.

%Now consider the case where $\gr{C}_L \gr{C}_R^{(q^{d'+1})}= \gr{C}$ for all executions. 
Given a tree of $\eval'$ transcripts, the extractor $\mathcal{X}$ recursively either extracts the encoding of an integer polynomial $f(X)\in B_b[X]\subset \ZZ[X]$ with bounded coefficients or a break of the Order Assumption or the Fractional Root Assumption. 
In order to break the Order Assumption we instantiate the adversary $\adv_{\textsf{Ord}}$ with the description of the group $\GG$. We also instantiate the fractional root adversary $\adv_{\textsf{FR}}$ with $\GG$ and $\gr{g}$ as encoded in $\params$.

Given the tree of transcripts as specified in the general forking lemma (Lemma \ref{lem:forking})  with branching factor $2$ at each level, \emph{i.e.}, $2$ different challenges, we will extract a witness at each node of the tree given witnesses for both nodes' children. Each level corresponds to a separate invocation to $\pro{EvalBounded}'$. We denote the input to $\pro{Eval}'$ without subscripts, \emph{i.e.}, $\gr{C},z,y,d;f(X)$, and the input to $\pro{EvalBounded}'$ with a subscript indicating the round, \emph{e.g.}, $d_0=d$, $\gr{C}_0=\gr{C}$ and $d_{\lceil \log_2(d)\rceil }=0,\gr{C}_{\lceil \log_2(d+1)\rceil }=\gr{g}^{f}$, \emph{etc}. For the witness polynomials we use superscripts and parentheses, \emph{i.e.}, $f^{(i)}(X)$ to avoid confusion with the notation for coefficients.  
%We let $\alpha$ and $\alpha'$ denote the two distinct challenges at each node of the transcript tree. We use $'$ to denote the proof elements and witnesses corresponding to the $\alpha'$ challenge, \emph{e.g.}, $\gr{C}_i'$.

In each round the extracted witness is an integer polynomial $f^{(i)}(X)\in \ZZ[X]$ such that $\gr{g}^{f^{(i)}(q)}=\gr{C}_i$ and such that the coefficients are bounded, \emph{i.e.}, all $f^{(i)}(X)$ are in $B_{b_i}[X]$. The degree of $f^{(i)}(X)$ is at most $d_i$ and $f(z) \equiv y \bmod p$. Note that for odd primes $p$ and integer $z$, $f(z)\bmod p$ is always defined.

We extract starting from the leafs of the tree, \emph{i.e.}, $d_{\lceil \log_2(d)\rceil}=0$. From the transcript we can directly extract the constant integer polynomial $f(X)=f \in \ZZ$ such that $\vert f \vert \leq(p-1) (\frac{p+1}{2})^{\lceil \log_2(d+1)\rceil}$, $y=f \mod p$, $f(X)=y\in \ZZ_p[X]$ and $\gr{g}^{f}=\gr{C}$ as the witness.

We now show how to compute the witness for $i-1$ given a witnesses for $i$. 
%%%Make into lemma?
If $d_i+1$ is odd then we have $\gr{C}_{i-1}^q=\gr{C}_i$. Since $\gr{C}_{i-1}=\gr{g}^{f^{(i-1)}(q)}$ we either have that $q$ divides $f^{(i-1)}(q)$ or since $q$ is odd we have a fractional root of $\gr{g}$. 
If this is not the case then $f^{(i-1)}(q)=f^{(i)}(q)\cdot q^{-1}$ and $f^{(i)}(X)=\dec(f^{(i)}(q))$ has a zero constant term. Additionally since $y_i=y_{i-1}\cdot z$ and $f^{(i)}(z)\equiv y_i \bmod p$ we have $f^{(i-1)}(z)\equiv y_{i-1} \bmod p$, \emph{i.e.}, $f^{(i-1)}(q)$ is a valid witness and the degree of $f^{(i-1)}(X)=\dec(f^{(i-1)}(q))$ is at most $d_{i-1}=d_i-1$. 

Now if $d_i+1$ is even then we can use Lemma~\ref{lem:intrandomcombine} to either extract a fractional root of $\gr{g}$, an element of known order in $\GG$ or the two bounded polynomials $f_{L}^{(i)}(X),f_{R}^{(i)}(X)$ of degree $\frac{d_i+1}{2}-1$ and $y_L=f_{L}^{(i)}(z)\bmod p$ as well as $y_R=f_{R}^{(i)}(z)\bmod p$. 
This yields $f^{(i)}(X)=f_{L}^{(i)}(X)+X^{\frac{d_i+1}{2}} f_{R}^{(i)}(X)$ a polynomial of degree at most $d_i$ such that $\gr{C}_i=\gr{g}^{f^{(i)}(q)}$ and such that $f^{(i)}(z) \bmod p=y_L+y_R \cdot z^{\frac{d_i+1}{2}}\bmod p=  y_i$.

Note that the application of Lemma~\ref{lem:intrandomcombine} requires that $q/2$ is greater than the magnitude of each of $f^{(i)}$'s coefficient. We will show that this is the case. \alan{How does this translate to the dyadic case?}

The check on $f$ ensures that $|f|\leq b=\frac{(p-1)}{2} (\frac{p+1}{2})^{\lceil \log_2(d+1)\rceil}$. 
Lemma \ref{lem:forking} in each invocation guarantees that the extracted parent polynomial has coefficients at most $(p-1)$ times larger than the coefficients of the children's polynomials. Given that the transcript tree has depth $\lceil \log_2(d+1)\rceil$ we get that the final extracted polynomial $f_0(X)\in B_b[X]$ has coefficients bounded by $b= \frac{p-1}{2}(\frac{p^2-1}{2})^{\lceil \log_2(d+1)\rceil}$.
Therefore, $q$ needs to be large enough such that $f_0(X)$ is uniquely decodable, \emph{i.e.}, $q>2\cdot b=(p-1)(\frac{p^2-1}{2})^{\lceil \log_2(d+1)\rceil}$.

We can successfully extract either a witness or a fractional root or an element of known order from any tree of valid transcripts of $\eval'$.
Under the Fractional Root Assumption and the Order Assumption, the probability that a polynomial time adversary along with a polynomial time extractor $\mathcal{X}$ can produce such a fractional root or an element of known order is negligible. $\eval'$, therefore, has witness extended emulation and under the Adaptive Root Assumption by Lemma \ref{lemma:poe_security} so does $\eval$.
Lemma \ref{lem:ordertoadaptive} and Lemma \ref{lem:strongtofractional} show that we can reduce the hardness assumptions to just the Adaptive Root Assumption and the Strong RSA Assumption.
%\alan{The adversary has unlimited time to produce a nasty tree of transcripts. Computing elements of known order or fractional roots is easy if time is no issue.} 
%This, however, only happens with negligible probability by assumption, where the probability is taken over the randomness of the setup. Finally using the forking lemma (Lemma \ref{lem:forking}) we can show that if the Strong RSA Assumption and the Adaptive Root Assumption (which in turn imply the fractional root and the Order Assumption) hold then $\eval'$ has witness extended emulation.

%This establishes that $\eval'$ has witness-extended emulation. From Lemma~\ref{lemma:poe_security} it follows that $\eval$ has witness-extended emulation also.
 
 
%Note that if $\frac{f^{(i)}(q)-f'^{(i)}(q)}{\alpha-\alpha'}$ is in fact a dyadic rational but not an integer then computing $D$ requires the extractor to take power of two roots. In class groups with discriminants that are prime and $7 \bmod 8$ this is always efficiently possible using an algorithm by Gauß~\cite{bosma1996computation}. In other groups of unknown order, such as $\ZZ_n^*/\{-1,1\}$ for composite $n$, it is not known how to efficiently compute square roots. This is, however, not a problem as the scheme can still be proven secure under a stronger Fractional Root Assumption where any rational root breaks the assumption. Even a dyadic rational $\frac{f^{(i)}(q)-f'^{(i)}(q)}{\alpha-\alpha'}$ would then lead to a break of the assumption.
% Under the Order Assumption finding elements of known, bounded, order happens with negligible probability $\advantage{\textsf{Ord}}{}$.

%Finally, if no bad event occurs and no assumption is broken we have $\gr{C}_{L,i-1}=\gr{g}^{f^{(i-1)}_L(q)}$ where $f^{(i-1)}_L(q)=\frac{f^{(i)}(q)-f'^{(i)}(q)}{\alpha-\alpha'}$ is a dyadic rational.  
 
% In that case $\gr{C}_{R,i-1}=\gr{g}^{f^{(i-1)}_R(q)}=\gr{g}^{f_{i}(q)-\alpha \cdot f^{(i-1)}_L(q)}$. The extractor has now successfully obtained $f^{(i-1)}_L(q)\in \mathbb{D}$ and $f^{(i-1)}_R(q)\in \mathbb{D}$.
 
 %If $f^{(i)}(q)\in C_{b_n,b_d}$ and $f'^{(i)}(q)\in C_{b_n,b_d}$, \emph{i.e.} their numerators are bounded by $b_n$ in absolute value and their denominator is bounded by $2^{b_d}$. The denominator of $f^{(i-1)}_L(q)$ is at most $|\alpha-\alpha'|<p$ times $2^{b_d}$. Since $\lambda=\lceil\log_2(p)\rceil$ we can deduce that $2^{b_d+\lambda}$ is a bound on the size of the denominator of $f^{(i-1)}_L(q)$ and consequently also on $f^{(i-1)}_R(q)$
%By triangle equality we also have that the numerator of $f^{(i-1)}_L(q)$ is at most $2\cdot b_n$. For $f^{(i-1)}_R(q)=f_{i}(q)-\alpha f^{(i-1)}_L(q)$ we get a bound of $(2 p )\cdot  b_n$. 
%For a sufficiently large $q$ we can still decode dyadic rational polynomials $f^{(i-1)}_L(X)=\dec(f^{(i-1)}_L)(q) \in C_{b_n\cdot (p+1),b_d+\lambda}[X]$ and $f^{(i-1)}_R(X)=\dec(f^{(i-1)}_R)(q) \in C_{b_n\cdot (p+1),b_d+\lambda}[X]$. 
%The homomorphic properties of the commitment scheme along with soundness of the $\textsf{PoE}$ ensure that $f^{(i-1)}(X)=f^{(i-1)}_L(X)+X^{d_{i}+1} f^{(i-1)}_R(X)$. 
%Since $ \alpha f^{(i-1)}_L(z)+ f^{(i-1)}_R(z)=f_{i}(z) \equiv y_i \bmod p$ and $ y_i=\alpha y_{L,i-1}+  y_{R,i-1} \bmod p$ we can compute $f^{(i-1)}_L(z)\equiv y_{L,i-1}\bmod p$ and $f^{(i-1)}_R(z)\equiv y_{R,i-1}\bmod p$. This gives us $f^{(i-1)}(z)\equiv y_{i-1}\bmod p$ and $f^{(i-1)}(X)\in C_{b_n\cdot (p+1),b_d+\lambda}[X] $ is a valid witness.  

\end{proof}

%{\it Note 1.} The extractability proof shows that the extractor is successful whenever the coefficients of the prover's polynomial are bounded in absolute value by $2^ip^{\lceil \log_2(d_{\it max} + 1) \rceil+i}$ or, after the final induction step, by $2^{\lceil \log_2(d_{\it max} + 1) \rceil}p^{2\lceil \log_2(d_{\it max} + 1) \rceil}$. In other words, prover who starts with a polynomial with at least one of the coefficients outside of this range, will succeed with negligible probability. However, the proof fails to cover what happens when he selects a polynomial within this range but outside $[0;p-1]$. As per correctness, his success is only guaranteed if all coefficients lie within this last range. Additionally this growing bound supplies in turn a lower bound on $q$. The coefficients that are too large in absolute value should percolate along with the recursion, remaining outside the bounds even after multiplication by a random $\alpha$. The set of possible coefficients must therefore be a factor $2^\lambda$ larger than the bounded interval. And therefore, $q > 2^{\lambda + \lceil \log_2(d_{\it max} + 1) \rceil}p^{2\lceil \log_2(d_{\it max} + 1) \rceil}$. \alan{Is this still relevant? Feel free to drop if not.}
\textit{Note}
The bound on $q$ for correctness (Lemma \ref{lem:correctness}) is $O((\frac{p}{2})^{\log(d)})$ while the bound for soundness is $O((\frac{p}{2})^{2 \log(d)})$. It is not clear whether this gap can be closed. While the soundness analysis is tight for the worst case assumption on challenges it is possible that a probabilistic analysis could give a tighter result.


\subsection{Optimizations and Performance}
\label{subsec:optimiztion}
We present several ideas for optimizing the performance of the $\pro{Eval}$ protocol.

\paragraph{Precomputation.} The prover has to compute powers of $\gr{g}$ as large as $q^d$. While this can be done in linear time, this expense can be shifted to a preprocessing phase in which all elements $\gr{g}^{q^i}, i \in \{1, \ldots, d_{\it max}\}$ are computed. Since for coefficient $|f_i|\leq -\frac{p-1}{2}$ this allows the computation of $g^{f(q)}$ in $O(\lambda d)$ group operations as opposed to $O(\lambda \log(d) d)$.
In addition to reducing the prover's workload, this optimization enables parallelizing it. 
The elements $\gr{g}^{q^i}$ can themselves be accompanied by non-interactive $\mathsf{PoE}$s to establish their correct computation.

The pre-computation also enables the use of multi-exponentiation techniques \cite{pippenger1980evaluation}. Boneh et al. and Wesolowski\cite{EPRINT:BonBunFis18,EC:Wesolowski19} showed how to use these techniques to reduce the complexity of the $\textsf{PoE}$ prover. The largest $\textsf{PoE}$ exponent $q^{\frac{d+1}{2}}$ has $O(\lambda d \log(d))$ bits. Multi-exponentiation can therefore reduce the prover work to $O(\lambda d)$ instead of $O(\lambda d \log(d))$ 

%\paragraph{Batching $\mathsf{PoE}$s.} Instead of running each $\mathsf{PoE}$ separately in the order they occur, it is possible to postpone to the end where they can be aggregated. Boneh~\emph{et al.} provide an extension to $\mathsf{PoE}$ called $\mathsf{PoHP}$ (proof of homomorphism preimage) to accomplish exactly this task~\cite[\S A.1]{C:BonBunFis19}. Instead of transmitting $\lceil \log_2(d + 1)\rceil $ primes $\ell$, this optimization requires the transmission of only one.\benedikt{Not sure that PoHP is applicable here, PoHP has exactly one output. although this indeed a generalization for it.} 

\paragraph{Early termination.} The protocol specifies the recursion ends when $d=0$, but the communication cost might be reduced if it terminates earlier. This reduction holds when the size of the fewer group elements $\gr{C}_L$ and $\gr{C}_R$ outweigh the size of the larger polynomial $f(X)$ instead of the constant $f$.

%\textit{Non-interactivity.} All the challenges of the verifier are public coin. Therefore, the protocol can be made non-interactive in the random oracle model with the Fiat-Shamir heuristic~\cite{C:FiaSha86}. This technique replaces each message of the verifier with the hash of all previous protocol messages, lifted to the appropriate domain.

%Q^{\ell}g^r x mod \ell = r 
%


\paragraph{Two group elements per round.} In each round the verifier has a value $\gr{C}$ and receives $\gr{C}_L$ and $\gr{C}_R$ such that $\gr{C}_L\gr{C}_R^{q'+1}=\gr{C}$. This is redundant. It suffices that the verifier sends $\gr{C}_R$. The verifier could now compute $\gr{C}_L\gets \frac{\gr{C}}{\gr{C}_R^{q'+1}}$ but this is expensive. Instead it can use the $\textsf{PoE}$ to infer $\gr{C}_R^{(q^{d'+1})}$. The \textsf{PoE}s first message is $\gr{Q}$. From this $\ell\in \ZZ$ and $r \in \ZZ$ the verifier computes $\gr{C}_R^{q^{d'+1}}\gets \gr{Q}^{\ell} \gr{C}_R^{r}$ as well as $\gr{C}_L=\gr{C}/\gr{C}_R^{q^{d'+1}}$. The security of $\textsf{PoE}$ does not require that $\gr{C}_R^{q^{d'+1}}$ be sent before the challenge $\ell$ as it is uniquely defined by $\gr{C}_R$ and $q^{d'+1}$.
The same optimization can be applied to the non-interactive variant of the protocol. 

Similarly the verifier can infer $y_L$ as $y_L\gets y-z^{d'+1} y_R$. This reduces the communication to two group elements per round and 1 field element. Additionally the prover sends $f$ which has roughly the size of $\log(d+1)$ field elements, which increases the total communication to roughly $2\log(d)$ elements in $\GG$ and $2\log(d)$ elements in $\ZZ_p$. 

%When the $\mathsf{PoE}$s are made non-interactive, the prover can get away with producing only two group elements instead of three. With a naïve application of the Fiat-Shamir heuristic, the $\mathsf{PoE}$ proof consists of $(\gr{C}_R, \gr{C}_R^\star, \gr{Q})$ where $\gr{Q}$ is determined by $\ell$, which in turn is determined by hashing all previous protocol messages: $\ell \gets \mathsf{H}(\cdot \Vert \gr{C}_R \Vert \gr{C}_R^\star)$. The optimization sends $(\gr{C}_R, \gr{Q}, \ell)$ instead. The verifier can infer $\gr{C}_R^\star = \gr{C}_R^{(q^{d'+1} \bmod \ell)}$ and then test $\mathsf{H}(\cdots \Vert \gr{C}_R \Vert \gr{C}_R^\star) \stackrel{?}{=} \ell$. This optimization is particularly compatible with the previous batching of $\mathsf{PoE}$s optimization, because while there is a unique $\gr{Q}$ for each round, there need only be one $\ell$ for the entire $\eval$ protocol.

\paragraph{Evaluation at multiple points}
The protocol and the security proof extend naturally to the evaluation in a vector of points $\boldsymbol{z}$ resulting in a vector of values $\boldsymbol{y}$, where both are members of $\mathbb{Z}_p^k$. The prover still sends $\gr{C}_L\in \GG$ and $\gr{C}_R\in \GG$ in each round and additionally $\boldsymbol{y}_L,\boldsymbol{y}_R \in \ZZ^k_p$. In the final round the prover only sends a single integer $f$ such that $\gr{g}^{f}=\gr{C}$ and $f \bmod p=y$.

This is significantly more efficient than independent executions of the protocol as the encoding of group elements is usually much larger than the encoding of elements in $\ZZ_p$. Using the optimization above, the marginal cost with respect to $k$ of the protocol is a single element in $\ZZ_p$. If $\lambda=\lceil\log_2(p)\rceil$ is $120$, then this means evaluating the polynomial at an additional point increases the proof size by only $15\log(d+1)$ bytes.

\paragraph{Joining $\mathsf{Eval}$s.} While the polynomial commitment scheme might be useful in a standalone context, it is certainly useful as a primitive tool applied in multiple places in a SNARK construction. In such cases, the scheme's homomorphic properties enable another reduction of the bandwidth cost. Instead of proving $k$ evaluations of $k$ polynomials, it suffices to state $k$ evaluation claims and proceed to prove one evaluation of a random linear combination of the $k$ polynomials, with the random weights being supplied by the verifier. If the points $z$ in which the evaluations are queried, are different, then the batched protocol must account for different $(y_i, y_{L,i}, y_{R,i})$ tuples in every round, one for each point $z_i$. The communication cost scales linearly with the number of distinct evaluation points, but the amortization technique remains concretely effective as the group elements dominates the communication cost for a single standalone protocol. This optimization is important enough to warrant its own security proof. Correctness is immediate (after accounting for a larger bound), so we focus on knowledge-soundness.


\begin{theorem}
    Let $(\prover_\mathsf{orig}, \verifier_\mathsf{orig})$ be a proof system where $k$ polynomial commitments are evaluated using $\eval$; specifically, $\pro{EvalBounded}(\gr{c}_i, z_i, y_i, d_i, b_i; f_i(X))$ for $i \in [k]$. Let $(\prover_\mathsf{join}, \verifier_\mathsf{join})$ be the same proof system but with the following changes: \begin{itemize} \itemsep0pt
        \item the invocations of $\pro{EvalBounded}$ are dropped;
        \item an instruction is added at the end: \verifier sends $\boldsymbol{\alpha} \sample [-\frac{p-1}{2}; \frac{p-1}{2}]^k$ to \prover;
        \item an instruction is added at the end: \\
        $\pro{EvalBounded}(\prod_{i=1}^k (\gr{c}_i^{\alpha_i})^{q^{D-d_i}}, \boldsymbol{z}, \boldsymbol{y}, D, pb; \sum_{i=0}^k \alpha_i X^{D-d_i} f_i(X))$, \\
        where $D = \max_i d_i, \boldsymbol{z} = (z_1, \ldots, z_k)$, and $\boldsymbol{y} = (y_1', \ldots, y_k')$, where ${y'}_j = \sum_{i=0}^k \alpha_i f_i(z_j)$.
    \end{itemize}
    Then $(\prover_\mathsf{join}, \verifier_\mathsf{join})$ has witness-extended emulation for the relation $\mathcal{R}$ if $(\prover_\mathsf{orig}, \verifier_\mathsf{orig})$ has witness-extended emulation for the relation $\mathcal{R}$.
\end{theorem}
\alan{todo: Analyze bound on $q$ in light of lemma 9.}
\begin{proof}
We show how to build the extractor $\mathcal{E}_\mathsf{join}$ for $\prover_\mathsf{join}^*$, given black-box access to an extractor $\mathcal{E}_\mathsf{orig}$ and a prover $\prover^*$ attempting to prove a statement $x$. The extractor $\mathcal{E}_\mathsf{join}$ obtains the polynomial $f(X) = \sum_{i=0}^k \alpha_i X^{D-d_i} f_i(X)$ by from the extractor $\mathcal{E}_\pro{Eval}$, and repeating this process for $k$ different $\boldsymbol{\alpha}$'s yields the individual polynomials $f_i(X)$. With the knowledge of these individual polynomials, $\mathcal{E}_\mathsf{join}$ can now generate transcripts for the individual evaluations of $f_i(X)$ occurring in the original protocol. This enables $\mathcal{E}_\mathsf{join}$ to provide $\mathcal{E}_\mathsf{orig}$ with transcripts that are indistinguishable from authentic ones. As a result, $\mathcal{E}_\mathsf{orig}$ will output a transcript-witness pair $(\mathsf{tr}_\mathsf{orig}, w)$. The extractor $\mathcal{E}_\mathsf{join}$ outputs one of the transcripts it provided to $\mathcal{E}_\mathsf{orig}$ in addition to the witnes it received from $\mathcal{E}_\mathsf{orig}$. By the assumption about $\mathcal{E}_\mathsf{orig}$, $w$ is a valid witness: $(x,w) \in \mathcal{R}$.
\end{proof}

%to a non-falsiable  but we do advise against this option. The reason for this advice is two-fold. First, in a SNARK compilation process where the commitment scheme is used as a primitive, zero-knowledge is typically added at the end anyway and it suffices to have a primitive that does not provide zero-knowledge on it own.
%Second, the natural way to add zero-knowledge is via a Pedersen-like commitment function $f(X) \mapsto \gr{g}^{f(q)}\gr{h}^r$, where $\gr{g}, \gr{h}$ are both random group elements and where $r \sample [0; 2^\lambda]$ is a randomizer with enough entropy.
%The scheme's homomorphism translates naturally to $\eval$ protocol and the only change the protocol needs is in the last step where $\gr{g}^f\gr{h}^{r'}$ must be opened to $f \bmod p$ and \emph{should not leak any other information}.
%The natural tool to achieve this is a zk-$\mathsf{PoKE}$ (zero-knowledge proof-of-knowledge of exponent)~\cite[\S A.4]{C:BonBunFis19} but unfortunately it is only provably secure in the generic group model.
\paragraph{Evaluating the polynomial over multiple fields}
The polynomial commitment scheme is highly flexible. For example it does not specify a prime field $\ZZ_p$ or a degree $d$ in the setup. It instead commits to an integer polynomial with bounded coefficients. That integer polynomial can be evaluated modulo arbitrary primes which are exponential in the security parameter $\lambda$ as the soundness error is proportional to its inverse.
Note that $q$ also needs large enough such that the scheme is secure for the given prime $p$ and degree $d$ (see Theorem \ref{thm:polycommitsecurity}). The second condition, however, can be relaxed. A careful analysis shows that the challenges $\alpha$ just need to be sampled from an exponential space, e.g. $[-2^{\lambda},2^{\lambda}]$. So as long as $q>2^{\lambda 2\lceil \log_2(d+1)\rceil+1}$ for RSA groups or  $q>2^{\lambda 3\lceil \log_2(d+1)\rceil+1}$ for Class groups one can evaluate degree $d$ polynomial with coefficients bounded by $2^\lambda$ over any prime field.

Additionally the proof elements $\gr{C}_L$, $\gr{C}_R \in \GG$ are independent from the field over which the polynomial is evaluated. This means that it is possible to evaluate a committed polynomial $f(X) \in B_b$ over two separate fields $\ZZ_{p}$ and $\ZZ_{p'}$ in parallel using only $2\log(d+1)$ group elements. 

%This property can be used to efficiently evaluate the polynomial modulo a large integer $m$ by choosing multiple $\lambda$ bit primes $p_1,\dots p_k$ such that $\prod_{i=1}^k p_i\geq m$ and using the Chinese Remainder Theorem to simulate the evaluation modulo $m$.
\benedikt{\@ Alan: This probably needs a pass but I need to write some other sections first.}


\paragraph{Performance.}
The polynomial commitment scheme has logarithmic proof size and verifier time in the degree $d$ of the committed polynomial.  

\begin{table} 
\begin{tabular}{l|l||l|l|l}
	Operation & $|\crs|$  & Prover & Verifier & Communication\\
	\hline
    \commit(f(X)) & 1 $\GG$ & $O(\lambda d\log(d))\GG$ & - & $1 \GG$\\
    \commit(f(X)) & $d$ $\GG$ & $O(\frac{\lambda d}{\log(d)}) \GG$ & - & $1 \GG$\\
    \eval($f(z)=y\in \ZZ_p$)  & 1 $\GG$ & $O(\lambda  \log(d) d)\GG$ & $O(\lambda \log(d))\GG$ & $2 \log(d) \GG$ +$2 \log(d) \ZZ_p$ \\
        \eval($f(z)=y\in \ZZ_p$)  & $d$ $\GG$ & $O(\lambda d)\GG$ & $O(\lambda \log(d))\GG$ & $2 \log(d) \GG$ +$2 \log(d) \ZZ_p$ \\
    \eval($f(\boldsymbol{z})=\boldsymbol{y}\in \ZZ^k_p$)  & 1 $\GG$ & $O(\lambda \log(d)d)\GG$ & $O(\lambda \log(d))\GG$ & $2 \log(d) \GG$ +$(k+1) \log(d) \ZZ_p$ \\
       \eval($f(\boldsymbol{z})=\boldsymbol{y}\in \ZZ^k_p$)  & $d$ $\GG$ & $O(\lambda d)\GG$ & $O(\lambda \log(d))\GG$ & $2 \log(d) \GG$ +$(k+1) \log(d) \ZZ_p$ \\
        \eval($f(z)=y, g(z)=y'\in \ZZ_p$)  & $1$ $\GG$ & $O(\lambda\log(d) d)\GG$ & $O(\lambda \log(d))\GG$ & $2 \log(d) \GG$ +$2 \log(d) \ZZ_p$ \\
                \eval($f(z)=y, g(z)=y'\in \ZZ_p$)  & $d$ $\GG$ & $O(\lambda d)\GG$ & $O(\lambda \log(d))\GG$ & $2 \log(d) \GG$ +$2 \log(d) \ZZ_p$ \\

\end{tabular}
\caption{$\GG$ denotes the size of a group element for communication and a single group operation for computation. $\ZZ_p$ denotes the size of a field element, i.e. $\lambda$ bits.}
\end{table}

\subsection{Multivariate polynomial commitments}\label{sec:multivariate}

We can extend our polynomial commitment scheme to multivariate polynomials. The idea is simply to use higher degrees of $q$ to encode the polynomial. The protocol is linear in the number of variables and logarithmic in the total degree of the polynomial. For simplicity we only present a protocol for $n$-variate polynomials where the degree in each variable is $d$. The protocol naturally extends to different degrees per variable.
\paragraph{Encoding}
Let $q_i=q^{(d+1)^i}$ then $f(q_1,\dots,q_n)\in \ZZ$ is an encoding of the multivariate polynomial $f(X_1,\dots,X_n)$ with maximum degree $d$. We use $\dec_{Multi}(f(q),n,d)$ to denote the decoding of an $n$-variate polynomial with degree exactly $d$ in each variable. The decoding algorithm simply uses the univariate decoding algorithm described in Section \ref{sec:encoding} to decode a univariate polynomial $\hat{h}(X)$ of degree $(d+1)^n-1$. From this it is easy to compute the $n$-variate polynomial $f(X_1,\dots,X_n)$ of degree $d$ by assigning the coefficients of $X^{(d+1)^i}$ to the variable $X_i$.
\paragraph{Protocols}
 Using this encoding we can naturally derive the multi-variate commitment scheme and $\eval$ protocol. The $\eval$ protocol computes the univariate polynomials $f(q_1,\dots,q_{n-1},X_n)$ and then uses the univariate eval protocol to reduce the claim from a claim about an $n$-variate polynomial to one about an $n-1$-variate one. At the final step the prover opens the now constant polynomial and the verifier can check the claim. For a bivariate (say $X$ and $Y$) cubic polynomial the protocol would first reduce the degree of $X$ to $0$ in two rounds of interaction and then reduce the degree of $Y$ using another two rounds.
 
 \begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{MultiSetup}(1^\secpar):$
		\begin{enumerate}[nolistsep]
			\item $ \GG \sample \ggen(\secpar)$
			\item $ \gr{g} \sample \GG$
			%\item $q \gets 2^k$ such that $q > (d+1) \cdot 2\cdot p^{\log_2(d+1)+1} $
			\item Pick a prime $p\in \NN$ such that $\lceil\log_2(p)\rceil=\lambda$.
			\item Pick a sufficiently large and odd $q\in \NN$ \pccomment{$q=O_\lambda(p^{n \cdot \log(d)})$}
			\item $\pcreturn \params = (\secpar,\GG,\gr{g},p,q)$
		\end{enumerate}
	$\pro{MultiCommit}(\crs;f(X_1,\dots,X_n) \in B_{p}^n[X]\subset \ZZ[X]):$ 		\begin{enumerate}[nolistsep]
			\item $d\gets \deg(f)$\pccomment{For simplicity assume $f(X_1,\dots,X_n)$ has degree $d$ in each variable}
			\item $q_i\gets q^{(d+1)^{i-1}}$ for each $i\in [1,n]$
			\item $\gr{C} \gets \gr{g}^{f(q_1,\dots,q_n)}$
			\item $\pcreturn (\gr{C};f(X_1,\dots,X_n))$
		\end{enumerate}
			\end{flushleft}
\end{minipage}
\end{mdframed}
 
 \begin{mdframed}
\begin{minipage}{\textwidth}
			$\pro{MultiEval}(\crs, \gr{C}\in \GG, \boldsymbol{z}\in \ZZ_n,y \in \ZZ_p, d,n,b \in \NN; f(X_1,\dots,X_n)\in \ZZ_p^n[X]) :$ 			\begin{enumerate}[nolistsep]
			\item \pcif{n=1} 
			\item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\params,\gr{C},z_1,y,d,b,x;f(X_1))$ 
			\item \pcelse
			\item \pcind[1] Let $\hat{f}(X_n)\gets f(q_1,\dots,q_{n-1},X_n)$
			\item \pcind[1] Let $\crs_n \gets \{\lambda,\GG,\gr{g},p,q_n\}$
			\item \pcind[1] \prover and \verifier run the univariate $\pro{EvalBounded}(\params_n,\gr{C},z_n,y,d,q_n;\hat{f}(X))$
			\item \pcind[2] except: when $d=0$, $f$ is not sent; instead the protocol returns its input at this point, \emph{i.e.}, $(\gr{C}',y',b')$ along with the prover's witness $f'(X_1,\dots,X_{n-1})=\dec(f,n-1,d)$ (Lines~\ref{line:basestart}-\ref{line:baseend} of $\pro{EvalBounded}$). 
			\item \pcind[1]$\boldsymbol{z}'\gets (z_1,\dots,z_{n-1})\in \ZZ_p^{n-1}$
			\item \pcind[1]\prover and \verifier run $\pro{MultiEval}(\crs,C',\boldsymbol{z}',y',d,n-1,b';f')$
		    \end{enumerate}
      \end{minipage}
\end{mdframed}
\begin{theorem}[Multivariate Eval]
	The polynomial commitment scheme for multi-variate polynomials consisting of protocols $(\pro{MultiSetup},\pro{MultiCommit},\pro{MultiEval})$ has perfect correctness and witness extended emulation if the Adaptive Root Assumption and the strong RSA Assumption hold for $\ggen$ for $n$-variate polynomials of degree $d$ and if $d^n=\poly$ if $q>(p-1)^{n\cdot \lceil \log_2(d+1)\rceil+1}(\frac{p+1}{2})^{n \cdot \lceil \log_2(d+1)\rceil}$.
\end{theorem}
\begin{proof}
	Perfect correctness follows from the correctness of the univariate scheme and the fact that the bounds $b$ are appropriately updated and remain less than $q/2$.
	
	To show witness extended emulation we use the forking lemma (Lemma \ref{lemma:GFL}) and build a polynomial time extractor algorithm $\mathcal{X}_{\pro{MultiEval}}$ that given a binary tree of transcripts of depth $n \cdot\lceil\log(d+1)\rceil$, extracts a witness. Each node corresponds to a different challenge $\alpha$ as described in the forking lemma. The tree consists of $n^{\lceil\log(d+1)\rceil}=\poly$ transcripts. 
We can therefore use Lemma~\ref{lem:poe} to replace all \textsf{PoE} executions with direct verification checks that $\gr{C}_L\gr{C}_R^{q^{d'+1}}=\gr{C}$. The lemma focusses on the univariate \pro{Eval} protocol but works identically for the multivariate protocol. The probability that an adversary can create any accepting transcript for which the $\textsf{PoE}$ can't be replaced by a direct check is negligible under the Adaptive Root Assumption.

	We now use the extractor $\mathcal{X}_{\pro{Eval'}}$ described in the proof of Theorem~\ref{thm:polycommitsecurity} to build $\mathcal{X}_{\pro{MultiEval}}$. 
	
	$\mathcal{X}_{\pro{MultiEval}}$ takes the entire transcript tree and invokes the univariate extractor on input $\gr{C}$ to extract either a degree $(d+1)^n-1$ polynomial univariate polynomial $\hat{f}(X)$ or an element of known order or a fractional root of $\gr{g}$. The extracted polynomial has coefficients bounded by $b=\frac{p-1}{2}(\frac{p^2-1}{2})^{n
	cdot \lceil\log_2(d+1)\rceil}$. Since $q>2b$ decoding and extraction succeeds. Further using $f(X_1,\dots,X_n)\gets\dec_{Multi}(\hat{f}(q),n,d)$ we can extract an $n$-variate polynomial of degree $d$ in each variable. 
It remains to show that $f(z_1,\dots,z_n)=y$. Lemma~\ref{lem:strongtofractional} which proofs the soundness of each individual extraction step does not require the evaluation point $z$ to be the same in each round. This shows that the extracted evaluation of $f(X_1,\dots,X_n)$ follows exactly the honest provers evaluation.
For the $y=\sum_{i=0}^{(d+1)^n-1 } \hat{f}_{i} (\prod_{j=1}^n  z_j^{\lceil i/(d+1)^j\rceil \bmod d+1 }) $, where $\hat{f}_i$ are the coefficients of the encoded univariate degree $(d+1)^n-1$. The decoding sets $\hat{f}_i$ to be the coefficient of $\prod_{j=1}^n  X_j^{\lceil i/(d+1)^j\rceil \bmod d+1 }$ which shows that $y=f(z_1,\dots,z_n)$.
	
	Under the Strong RSA Assumption and the Adaptive Root Assumption the probability that the polynomial time adversary can produce an element of known order or a fractional root of $\gr{g}$ is negligible. This shows that the multivariate polynomial commitment scheme has witness extended emulation.
\end{proof}




\section{Transparent Preprocessing SNARKs via Polynomial IOPs}\label{sec:polyiop}
\input{lineariop}

\section{Conclusion}

The compilation of a SNARK for general purpose computations is generally divisible into three phases. First is \emph{arithmetization}, in which the computation is expressed as a satisfaction problem over some algebra. Second is \emph{information-theoretic compilation}, in which the algebraic problem is transformed into an interactive protocol for proving satisfiability or knowledge of witness for the algebraic claim. The third and last step is \emph{cryptographic compilation}, in which information-theoretical and ideal components in the information-theoretical protocol are replaced by cryptographic components, thereby realizing the abstract object at the cost of computational security. 

In the context of this three-pass compilation process, DARK protocols inhabit the last phase. Our polynomial commitment scheme based on groups of unknown order represents an alternative to similar schemes based on powers-of-$\tau$ or Merkle trees of Reed-Solomon codewords. Any SNARK construction that uses these latter schemes as black boxes can be lifted to the DARK family by replacing the polynomial commitment scheme. When the DARK protocol is instantiated with class groups, this replacement obviates the need for a trusted setup.

The polynomial commitment scheme presented by this paper highlights the need for a theoretical framework where such a tool is a native first-order member.  The information-theoretical Polynomial IOP formalism provides exactly such a framework. Upon inspection it is found to capture SNARK constructions such as Sonic and STARK, indicating conceptual soundness. The slightly more general Algebraic Linear IOP captures more SNARK constructions still. While all IOPs can be instantiated with DARK protocols, in the Algebraic Linear case, a quasilinear prover time can no longer be guaranteed. 

By design, the IOP formalisms make abstraction of the cryptographic assumptions used in the layer underneath. As a result, the IOP formalisms fail to capture fully the expressive power of Diophantine Complexity. An interesting question left open by this work is the potential of algebraic IOPs where the proofs represent integers rather than polynomials or vectors over a finite field. An associated question is the search for alternative algebras that naturally commit to integers --- not just alternative groups of unknown order which, while an interesting research project, admit Shor's quantum order finding algorithm~\cite{conf/focs/Shor94} and therefore necessarily fail to provide post-quantum security. The converse is yet another interesting open question: is it possible to instantiate Polynomial IOPs or polynomial commitment schemes with other algebras and hard problems, beyond groups of unknown order and Merklte trees of Reed-Solomon codes --- for instance, from elliptic curve groups and based on the hardness of the discrete logarithm, or based on post-quantum hard problems that are more expressive than generic hash functions.

The cryptographic hardness assumptions underlying the security of SNARK constructions are rarely falsifiable, and this seems to be a by-product of the cryptographic compilation process. In powers-of-alpha type constructions the unfalsifiable hardness assumption is inherently algebraic. In contrast, the hardness assumption of groups of unknown order \emph{are} falsifiable; it is only the Fiat-Shamir heuristic for $\mathsf{polylog}$-many round protocols that is unfalsifiable because it is only provably secure in the random oracle model; a security reduction of such heuristics to standard assumptions is as yet unavailable.

% * nevertheless, polynomial commitment schemes do not necessarily correspond integer relations; it's just that integer relations are powerful enough to do that also --- what other things can they do beyond polynomial commitments?
 
% * falsifiable assumptions at the cost of the fiat-shamir heuristic
% * future work / open questions:
%  - constant-size evaluations
%  - constructions for smaller groups of unknown order (because no subexponential algorithms)
%  - PQ analogues $<--$ for capturing integer relations
%  - PQ analogues $<--$ for capturing polynomial commitments
%  - polynomial commitment schemes from DLOG ?

%\bibliography{cryptobib/references}
\bibliographystyle{alpha}
  \bibliography{cryptobib/crypto,cryptobib/additional}

\appendix

\input{appendix} 

\end{document}
