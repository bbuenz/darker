\documentclass[12pt]{article}
\pagestyle{plain} 
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics,advantage]{cryptocode}
\usepackage{notations}
%\usepackage{bm}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath,amssymb}
\usepackage[utf8x]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{xspace}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
%\usepackage{authblk}
%\usepackage{draftwatermark}
\usepackage[legalpaper, margin=1in]{geometry}

\usepackage{comment}
\title{Darker}

\begin{document}
	
\maketitle
\section{Sketched Protocol}
\subsection{Odd Even Protocol}
\begin{mdframed}
Public Input: $C\in \GG$\\
Witness: $f(X) \in \ZZ_p[X]$ \\
Claim: $C=\commit(f(X))$ and $\deg(f(X))<d$	\\
$\textsf{FFTEval}(q,C,d;f(X))$
\begin{enumerate}[nolistsep]
		\item $\pcif d=0$
		\item $\pcind[1]$ $\prover$ sends $f=f(X)$
		\item $\pcind[1]$ $\verifier$ checks that $|f|<2^{\log_2(d_{\max}) \cdot \lambda}$ and that $g^f=C$ \pccomment{$d_{\max}$ is the original degree here}
		\item $\prover$ computes $f_E(X)$ and $f_O(X)$ s.t. $f_E(X^2)+X \cdot f_O(X^2)=f(X)$\pccomment{Odd and Even coefficients} 
		\item \prover sends $\gr{C}_E\gets \gr{g}^{f_E(q^2)}$ and $\gr{C}_O\gets \gr{g}^{f_O(q^2)}$ to $\verifier$.
		\item $\verifier$ checks that $\gr{C}_E\cdot \gr{C}_O^q=\gr{C}$ \pccomment{$q$ grows in each round. Outsourced with PoEs. See below}
		\item $\verifier$ samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to $\prover$
		\item \prover and \verifier compute $\gr{C}'\gets \gr{C}_E\gr{C}_O^{\alpha}$
		\item $\prover$ computes $f'(X)\gets f_E(X)+\alpha f_O(X)$
		\item \prover and \verifier run $\textsf{FFTEval}(q^2,\gr{C}',\frac{d}{2};f'(X))$
	\end{enumerate}
\end{mdframed}
\subsection{Computing all PoEs at once}
Let the subscript $i$ denote proof elements from the $i$th round of the protocol.
Let $\gr{D}_i\gets \gr{C}_{O,i}$ and $\gr{D}_i'\gets \gr{C}_i/\gr{C}_{E,i}$. The prover needs to show that $D_i^{q^{2^{i-1}}}=\gr{D}'_i$
\begin{enumerate}[nolistsep]
\item $X_{\log_2(d)}=\gr{D}_{\log_2(d)}$, $Z_{\log_2(d)}=\gr{D}'_{\log_2(d)}$
\item $Y_{\log_2(d)}\gets X_{\log_2(d)}^{q^{d/4}}$ \pccomment{Computable as $g_{\frac{d}{4}}^{f_{\log_4(d)}}$ for $g_{\frac{d}{4}}=g^{(q^{\frac{d}{4}})}$}
\item \prover sends $Y_{\log_2(d)}$ to $\verifier$
	\item $\pcfor i \in [\log_2(d)-1,2]$
	\item \pcind[1]$\verifier$ samples $\alpha,\beta \sample [-2^{\lambda-1} ,2^{\lambda-1}]$ and sends them to $\prover$
	\item \pcind[1]\prover and \verifier compute  $X_{i}\gets  X_{i+1} Y_{i+1}^{\alpha}D_{i}^{\beta}$
	\item $\pcind[1]$\prover and \verifier compute   $Z_{i}\gets Y_{i+1}Z_{i+1}^{\alpha}D_{i}^{'\beta}$
		\item \pcind[1]\prover computes $Y_{i}\gets X_{i}^{q^{2^{i-2}}}$ \pccomment{See discussion below}
		\item \pcind[1]$\prover$ sends $Y_{i}$ to \verifier.
\item \verifier samples random $\alpha,\beta \sample [-2^{\lambda-1} ,2^{\lambda-1}]$ and checks that $(X_{2} Y_{2}^{\alpha}D_{1}^{\beta})^q=Y_{2}Z_{2}^{\alpha}D_{1}^{'\beta}$
\end{enumerate}
\subsection{Computational complexity of batch PoE}
The main prover work is in computing $Y_i$. In the first few loops $Y_i=g^{h(q)}$ for a sparse polynomial $h(X)$. For example in the first loop $h(X)$ has only a single non-zero coefficient.
After $\log_2(d)/2$ rounds the polynomial has roughly $\sqrt{d}$ coefficients. It then makes sense to switch to computing $Y_i$ using a sequential computation, i.e. $Y_i=X_i^{q^{2^{i-2}}}$. This now also takes $O(\sqrt{d}\cdot \log{d})$ work. One could also switch earlier from one computation to the other. Additionally it is possible to use Wesolowski PoEs for the second part of the loop, i.e. the first half of the Odd/Even protocol. This leads to a smaller proof size. One possible split may be to only do $\log{\log{d}}$ BatchPoEs at the end. This should give you prover time that is still linear but better proof size. In practice doing BatchPoE for the last $6$ rounds should be good for almost all input sizes.
\section{$\tilde{O}(\sqrt{d})$ eval}
The PoEs are efficient and with some caching during the commitment phase we can also make the rest of the eval have $\tilde{O}(\sqrt{d})$ complexity (only group operations). The protocol is parameterized by a bound $b$ which determines the amount of preprocessing. We discuss the perfect choice for $b$ later but for intuition it helps to think of $b=d/b=\sqrt{d}$.
\subsection{Idea}
The core idea is that we can write a polynomial $f(X)$ of degree $d-1$ as the sum of $b$ polynomials $f_i(X)$ of degree less than $\frac{d}{b}$. That is $f(X)=\sum_{i=0}^b X^i f_i(X^b)$. This is a direct generalization of the odd/even split that the $\textsf{FFTEval}$ protocol uses. During the committing phase the prover computes and stores commitments to $f_i(X^b)$, i.e. $P_i\gets g^{f_i(q^b)}$. Using the $\frac{d}{b}$ precomputed group elements $g,g^{q^b},g^{q^{2b}}\dots$ all $b$ $P_i$'s can be computed using $d$ $\lambda$-bit exponentiations\footnote{Ignoring multi-exponentiation speedups for now}. Given the $P_i$'s one can compute $C=g^{f(q)}$. This is because $C=\prod_{i=0}^{b-1} P_i^{q^i}$. By computing this product left to right, i.e. $C=(((P_{b-1}^qP_{b-2})^qP_{b-3})^q \dots)P_0$ this can be done using only $b$ $\log_2(q)$-bit exponentiations.

Similarly the prover can use the $P_i$ to compute to $C_O$, i.e. the commitment to $f_O(X^2)$ where $f(X)=f_E(X^2)+Xf_O(X^2)$. Additionally computing $C_O'=g^{q f(q^2)}$ can be done efficiently given just $C_O$ as $C_O'=C_O^q$. 

After each round the protocol continues with $f'(X)=f_E(X)+\alpha f_O(X)$ as a witness and $q_{i+1}=q_{i}^2$. Similarly as in the first round we can write $f'(X)$ as the sum of $b/2$ polynomials of degree less than $\frac{d}{b}$.
$f'(X)=\sum_{i=0}^{\frac{b}{2}-1} X^i f'_i(X^{\frac{b}{2}})$. Given the commitments to the $f_i(X^b)$ we can efficiently compute commitments to $f_i'(X)=f_{2i}(X)+\alpha f_{2i+1}(X)$ as $P_i'\gets P_{2i}P_{2i+1}^{\alpha}$. This takes work at most $b$, $\lambda$-bit exponentiations. Repeating this for $\log_2(b)$ rounds we end up with a witness polynomial $f''(X)$ of degree less than $\frac{d}{b}$. Given the precomputed $g_i$ the prover can construct commitments to $f''(X)$ and finish the protocol using $\frac{d}{b}$ $\lambda$-bit exponentiations. In the first $\log_2(b)$ steps the most expensive operations is computing $C_O$ given the $P_i$'s. This takes roughly $b$ $\log_2(q)$-bit exponentiations in every round, i.e. $b\log_2(b) \log_2(q)$-bit exponentiations in total.
\subsection{Protocol}
\begin{mdframed}
$\textsf{Preprocess(b)}$:
\begin{enumerate}[nolistsep]
	\item $g_i=g^{q^{ib}}$ for $i \in [0,\frac{d}{b}-1]$
	\item Output $g_0,\dots,g_{\frac{d}{b}-1}$
\end{enumerate}
$\textsf{Commit}(f(X),b):$
\begin{enumerate}[nolistsep]
	\item $f(X)=\sum_{i=0}^{b-1} X^{i} f_i(X^{b})$ \pccomment{$\deg(f_i(X))<\frac{d}{b}$.}
	\item Let $P_i\gets g^{f_i(q^b)}$ for all $i \in [0,b-1]$\pccomment{ computed using $g_i$; Cost: $d$ $\lambda$-bit exp.}
	\item Compute $C\gets \prod_{i=0}^{b-1} P_i^{q^i}=((P_{b-1}^q P_{b-2})^q P_{b-3})^q...P_0$ \pccomment{Cost: $b$ $\log_2(q)$-bit exp.}
	\item Output $C$ and $P_{0}\dots,P_{b-1}$
\end{enumerate}
$\textsf{FFTEval}(q,C,P_0,\dots,P_{b-1},b,d;f_0(X),\dots,f_{b}(X))$
\begin{enumerate}[nolistsep]
		\item $\pcfor i=1$ to $\log_2(b)$
		\item $\pcind[1]$ $C_{O,i}\gets\prod_{j=0}^{\frac{b}{2^i}-1} P_{2j+1}^{q^{j\cdot 2^i}}$ \pccomment{Computed using folding method, Total Cost: $b \log{b}$ $\log_2(q)$-bit exp}.
		\item \pcind[1] $C_{O,i}'=C_{O,i}^{q^{2^i}}$ \pccomment{Total cost (all iterations) $b$ $q$-bit exp, might as well do W PoE here}
		\item \pcind[1] $\alpha_i\gets \hash(C_{O,i})$ \pccomment{Fiat-Shamir}
		\item $\pcind[1] P_{j}=P_{2j}P_{2j+1}^{\alpha}$ for $j \in [0,\frac{b}{2^i}]$\pccomment{$b$ $\lambda$-bit exp in total}
		\item $f'(X)\gets \sum_{i=0}^{b-1} f_i(X) \prod_{j=1}^{\log_2(b)} \alpha_j^{j\text{th last bit of }i}$ \pccomment{$f_0(X)+\alpha_1 f_1(X) + \alpha_2 f_2(X)$, Cost: $d$ field ops}
		\item \pcfor $i=\log_2(b)+1$ to $\log_2(d)$
		\item \pcind[1] $f'(X)=f_E(X^2)+Xf_O(X^2)$
		\item \pcind[1] $C_{O,i}\gets g^{f_O(q^{2^i})}$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp}
		\item  \pcind[1] $C_{O,i}'\gets g^{q^{2^{i-1}} \cdot f_O(q^{2^i})}$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp using $g_i$}
		\item \pcind[1] $\alpha_i\gets\hash(C_{O,i},C_{O,i}')$
		\item \pcind[1] $f'(X)=f_E(X)+\alpha_i f_O(X)$
		\item Proof is $C_{O,1},\dots,C_{O,\log_2(d)}$ and $C_O$'s
		\item Add $f'=f'(X)$ to proof.
	\end{enumerate}
	\end{mdframed}
	For $b=\sqrt{d}$ the runtime is $O(d \log_2(d)^2)$. A value like $b=\sqrt{d/\log(d)}$ gives roughly $O(d\log_2(d)^{1.5})$. Parallelism and multi-exp techniques need to be taken into account and the optimal value is likely best determined numerically. There are limited options anyway as $b$ needs to be a power of $2$.\\ 
Step 2 in FFTEval is likely a bottleneck. Smaller q value would still help in this protocol.
\begin{comment}
\section{Other ideas (WIP)}
\subsection{No field elements eval}


\begin{mdframed}
Public Input: $C\in \GG,z\in \ZZ_p,y\in \ZZ_p$\\
Witness: $f(X) \in \ZZ_p[X]$ \\
Claim: $C=\commit(f(X))$, $\deg(f(X))<d$ and $f(z)=y \bmod p$
	\begin{enumerate}[nolistsep]
		\item $\prover$ computes $q(X) \in \ZZ_p[X]=f(X)//(X-z) \bmod p$ and $Q\gets\commit(q(X))$
		\item \prover sends $Q$ to $\verifier$.
		\item $\prover$ and $\verifier$ compute $D\gets C/(Q^{(q-z)}g^y)$ \pccomment{$D$ commits to $h(X)=f(X)-q(X)(X-z)-y\equiv 0\bmod p$.}

		\item \prover and \verifier run $\textsf{DegreeProof}(D,Q^q,d;h(X),q(X)\cdot X)$
	\end{enumerate}
\end{mdframed}

Assume $d+1$ is a power of $2$
\begin{mdframed}
\begin{minipage}{\textwidth}
			$\pro{DegreeProof}(\crs, \gr{C},\gr{Q}\in \GG, d \in \NN; h(X),q(X)\in \ZZ_p[X]) :$ \pccomment{$\tilde{f}(X) = \sum_{i=0}^d \tilde{f}_i X^i$}
			\begin{enumerate}[nolistsep]
					\item \verifier samples challenge $\alpha$ 
			\item $\gr{C}'\gets \gr{C}^{\alpha}Q$
			\item \prover and \verifier run $\pro{DegreeProofBounded}(\params,q,\gr{C}',d,p\cdot 2^\lambda;\alpha \cdot h(X)+f(X))$
        \item \ \verifier checks that $b\cdot \boldsymbol{\varsigma}_{p,d} < q$\pccomment{$\boldsymbol{\varsigma}_{p,d}=O(p^{2\log(d)})$ (see Theorem~\ref{thm:polycommitsecurity} and \ref{thm:dyadicpolysecurity})}
        %q/(2^{\lceil \log_2(d+1) \rceil+1} p^{2 \lceil \log_2(d+1) \rceil+1})$
        \item \pcind[1] \verifier checks that $|h|\leq b$ and 
          \item \pcind[1] \verifier checks that $f\equiv 0 \bmod p$
                \item \label{line:baseend}\pcind[1] \verifier checks that $\gr{g}^{\alpha h}=\gr{C}$
\item \pcind[1] \verifier outputs $1$ \pcif all checks pass, $0$ otherwise.
		    \end{enumerate}
		    		\vspace{1em}
		$\pro{EvalBounded}(\crs,q,\gr{C}'\in \GG,d\in \NN,b\in \ZZ;\alpha h(X),f(X)\in \ZZ(b)[X])$		
	    \begin{enumerate}[nolistsep]
        \item \pcif $d=0$:
        \item \label{line:basestart}\pcind[1] \pcreturn $\gr{C}$ to $\prover$ and $\verifier$ and $\alpha h(X), f(X)$ \pccomment{$\alpha h(X)$ and $f(X)$ are constants}

        
        \item \pcelse: \pccomment{$d \geq 1$ and $d+1$ is even}
       
        \item \pcind[1] \prover and \verifier compute $d' \gets \lfloor\frac{d}{2}\rfloor$
        \item \pcind[1] \prover computes $f_E(X) \gets \sum\limits_{i=0}^{d'} f_{2\cdot i} \cdot X^i$ and $f_O(X)\gets\sum\limits_{i=0}^{d'} f_{2\cdot i 1}\cdot X^{i}$
        \item \pcind[1] \prover computes $\gr{C}_E \gets \gr{g}^{f_L(q^2)}$ and $\gr{C}_O \gets \gr{g}^{f_R(q^2)}$
        \item \pcind[1] \prover sends $\gr{C}_E, \gr{C}_O$ to \verifier. \pccomment{See Section \ref{subsec:optimization} for an optimization}
        \item \pcind[1] \label{line:PoE} \prover and \verifier run $\pro{PoE}(\gr{C}_E, \gr{C}/\gr{C}_O, q)$\pccomment{Showing that $\gr{C}_E\gr{C}_O^{q}=\gr{C}$}
        \item \pcind[1] \verifier samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to \prover
        \item \pcind[1] \prover and \verifier compute $\gr{C}' \gets \gr{C}_E^\alpha  \gr{C}_O$, $b'\gets b \cdot 2^{\lambda}$. 
        \item \pcind[1] \prover computes $f'(X) \gets \alpha \cdot f_E(X) + f_O(X) \in \ZZ[X]$  and\\
        \pcind[1] $h'(X)=\alpha h_E(X) + h_O(X)$\pccomment{$\deg(f'(X))=\deg(h'(X))=d'$}
        \item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}',q^2, d',b' ; \alpha f'(X))$
               \end{enumerate}
      \end{minipage}
\end{mdframed}
\end{comment}
\end{document}
