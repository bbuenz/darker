
All existing SNARK constructions can be viewed conceptually as consisting of an underlying information-theoretic statistically sound protocol that is then “cryptographically compiled” into one that achieves the desired efficiency properties (\emph{i.e.}, succinctness, non-interaction, etc) at the cost of \emph{computational soundness}. The information theoretic protocol is secure against unbounded provers whereas the compiled protocol is sound only against computationally bounded provers. In some cases zero-knowledge is also only achieved after compilation. This viewpoint has proved useful both as a modular method for constructing new proof systems as well as an analytical tool for classifying existing ones. 

\paragraph{CS proofs} The earliest construction of a succinct non-interactive argument system for NP, Micali’s ``CS proofs” \cite{CSproofs}, used random oracles and Merkle tree commitments to cryptographically compile classical PCPs via the Fiat-Shamir heuristic. In a PCP there is a verifier who has oracle access to a proof string and thus may query $q$ locations of the string in time O(q). The celebrated PCP theorem \cite{FOCS:ALMSS92} showed that any NP statement has a corresponding proof string of polynomial size, which the verifier only needs to check in O(1) locations in order to verify the statement with statistical soundness. In a CS proof, the first step is to build an interactive public-coin proof with succinct communication as first proposed by Kilian ~\cite{STOC:Kilian92} where the prover sends the verifier a Merkle tree commitment to the PCP string, receives the verifier’s public coin queries, and provides Merkle proofs to authenticate its answers to these queries. The second step is to make this non-interactive via Fiat-Shamir. However, this construction was purely theoretical due to the concrete inefficiency of classical PCPs. 

\paragraph{Short vs linear PCPs} These classical PCPs of polynomial length are called ``short PCPs''. Ishai, Kushilevitz, and Ostrovsky~\ref{CC:IKO07} gave the first communication efficient interactive argument that did not rely on commitments to short PCPs. The underlying information theoretic object in this construction is a \emph{linear} PCP, which is an oracle computing a linear function $\proofO: \FF^m \rightarrow \FF$, \emph{i.e.}, the answer to each query $\mathbf{q} \in \FF^m$ is the inner product $\langle \proofO, \mathbf{q} \rangle$. Their four-move succinct interactive argument uses linear homomorphic encryption to compile the linear PCP. The verification time in this construction is still linear and the prover time is quadratic due to the particular linear PCP instantiation based on Hadamard codes~\cite{FOCS:ALMSS92}. Gennaro, Gentry, Parno, and Raykova ~\cite{EC:GGPR13} were the first to present a concretely practical SNARK that reduced the prover time to $O(n log n)$ based on a more efficient instantiation of the linear PCP oracle, namely an encoding of the computation as a quadratic arithmetic program (QAP). The GGPR protocol (and followup improvements) were not initially described through the lens of linear PCPs, but were later adapted to this framework~\cite{TCC:BCIOP13,ES:SBVBPW13}. Bitansky et. al.~\cite{TCC:BCIOP13} generalized this construction, showing how any linear PCP of a particular kind (QAPs being one example) could be combined with linear-only encodings to get a SNARK with sublinear verification time and linear time preprocessing. The preprocessing step in these constructions requires a trusted secret setup. 

\paragraph{IOPs} Interactive Oracle Proofs (IOPs)~\cite{TCC:BenChiSpo16,STOC:ReiRotRot16} combine IPs and PCPs: in each round of an IOP the verifier sends a message $m_i$ to the prover and the prover responds with a polynomial length proof oracle $\boldsymbol{\pi_i}$, which the verifier can query via random access. The verifier can continue to query this oracle in future rounds. In other words, each $\boldsymbol{\pi_i}$ is a PCP. Boneh et. al. \cite{C:BBCGI19} introduced linear IOPs as the IOP extension of linear PCPs, where in each round the prover's message is a linear PCP oracle. The study of IOPs, and in particular interactive oracle proofs of proximity (IOPPs) based on Reed-Solomon codes, has led to more efficient SNARKs that extend the CS-proof paradigm ~\cite{ICALP:BBHR18}.

%\paragraph{Linear IOPs} Another line of work … GKR based …. Can be viewed as linear IOP [IshaiCorrigan19]… In fact, linear IOPs capture all existing SNARK constructions, as they generalize both linear PCPs and short PCPs. Discuss STARK, Aurora, how it can be viewed as starting with a linear IOP where each proof oracle is a polynomial function and then turns it into a classical IOP by replacing each proof oracle with the evaluation of the polynomial at a linear number of points. This is so that they can apply weaker cryptographic compilers that don't require trusted setup (Merkle trees), but this underlying linear IOP could be compiled directly given a more advanced cryptographic compilation tool. 

%\paragraph{Our results} Present our polynomial commitment and inner product argument as cryptographic compilation techniques applied to linear IOPs. Introduce terminology of algebraic linear IOPs, where queries are derived by applying bounded-degree polynomials to verifier’s coins. Subclass of algebraic linear IOPs is polynomial IOPs, where each oracle encodes a polynomial function of bounded degree and linear queries are all evaluations of the polynomial at a point. One way to see the connection to algebraic linear IOP is that each component of the query is derived via a bounded-degree monomial. 
%Explain a new view of QAP as one round linear IOP instead of linear PCP and how this yields a QAP-based SNARK without trusted setup. Provide general theorem for compiling linear IOPs of two kinds: algebraic linear IOPs (theorem generalizes QAP construction), polynomial IOPs. In each give complexity of resulting preprocessing SNARK as a function of various parameters in the underlying linear IOP (number of rounds, etc). 

\subsection{Algebraic Linear IOPs} 

In this section we define \emph{algebraic linear IOPs}. Recall that in a linear PCP~\cite{CC:IKO07}, the prover sends a single proof vector $\proofO \in \FF^m$ to some language membership assertion, and the verifier checks the assertion by making $\emph{linear queries}$ to $\pi$. The PCP is modeled as giving the verifier access to an oracle that receives queries of the form $\mathbf{q} \in \FF^m$ and returns the inner-product $\langle \proofO, \mathbf{q} \rangle$. Bitansky et. al. \cite{TCC:BCIOP13} defined a linear PCP to be \emph{algebraic} if there are low (\emph{i.e.}, $\poly$) degree circuits that derive the query vector from the verifier's random coins and implement the verifier's decision algorithm based on the query responses. by an arithmetic circuit of low degree, \emph{i.e.}, each component of the query is the output of a polynomial function of 

 (\emph{i.e.}, $poly(\lambda)$). More precisely, in an algebraic degree $d$ PCP there is a query function $Q: \FF^\mu \rightarrow \FF^m$ such that each verifier query is of the form $\mathbf{q} \leftarrow Q(\mathbf{r})$, where $\mathbf{r}$ is uniformly sampled from $\FF^\mu$, and the function $Q$ is computable by a vector of $\mu$-variate polynomials of degree at most $d$. 

A subclass of algebraic linear PCPs are \emph{polynomial PCPs}. A $\mu$-variate degree $d$ polynomial PCP oracle encodes a $\mu$-variate polynomial function of degree $d$, and all oracles queries return evaluations of the polynomial at points in $\FF^\mu$. If the proof oracle is represented by the coefficient vector $\proofO \in \FF^{d^\mu}$ then its evaluation on a point in $\FF^\mu$ can be viewed as a linear query $\mathbf{q} \in \FF^{d^\mu}$ (\emph{i.e.}, returning $\langle \proofO, \mathbf{q} \rangle$) with each component of $\mathbf{q}$ computed by a $\mu$-variate monomial of degree at most $d$. 

We define algebraic linear IOPs analogously to algebraic linear PCPs. To keep the syntax simple, we will only the present the definition for the case of public-coin linear IOPs. Our results will only make use of public-coin IOPs. 

\begin{definition} [Public-coin linear IOP]
\label{def:linearIOP}
Let $\mathcal{R}$ be a binary relation and $\FF$ a finite field. A $t$-round $\ell$-query public-coin linear IOP for $\mathcal{R}$ over $\FF$ with soundness error $\epsilon$ and knowledge error $\delta$ and query length $\mathbf{m} = (m_1,...,m_t)$ is defined by a tuple of stateful PPT algorithms $(P, Q, V)$ that satisfy the following requirements:\\
 
\noindent \underline{Protocol syntax}. 
%There is a prover algorithm $P$, a query algorithm $Q$, and a verification algorithm $V$. 
For each $i$th round there is a prover state $\textsf{st}^P_i$ and a verifier state $\textsf{st}^V_i$. For any common input $x$ and $\mathcal{R}$ witness $w$, at round 0 the states are $\textsf{st}^P_0 = (x, w)$ and $\textsf{st}^V_0 = x$. 
In the $i$th round (starting at $i = 1$) the prover outputs a single\footnote{The prover may also output more than one proof oracle per round, however this doesn't add any power since two proof oracles of the same size may be viewed as a single (concatenated) oracle of twice the length.} proof oracle $\proofO_i \leftarrow P(\textsf{st}^P_{i-1})$ in $\FF^{m_i}$ and the verifier outputs a uniformly sampled $\mathbf{r}_i \leftarrow_R \FF^{\mu_i}$. 
This determines a query matrix $\mathbf{Q}_i \leftarrow Q(\textsf{st}^V_{i-1}, \mathbf{r}_i)$ consisting of $\ell$ column vectors in $\FF^{m_i}$, and the verifier obtains the linear oracle response $\mathbf{a}_i \leftarrow \proofO_i^\top \mathbf{Q}_i$. The updated prover state is $\textsf{st}^P_i \leftarrow (\textsf{st}^P_{i-1}, \mathbf{r}_i)$ and verifier state is $\textsf{st}^V_i \leftarrow (\textsf{st}^V_{i-1}, \mathbf{r}_i, \mathbf{a}_i)$. Finally, $V(\textsf{st}^V_t)$ returns $\textsf{Accept}$ or $\textsf{Reject}$. \\ 

\noindent \underline{Completeness}. For every $(x, w) \in \mathcal{R}$, following the protocol syntax above $V(\textsf{st}^V_t)$ returns $\textsf{Accept}$ with probability 1. \\

\noindent \underline{Soundness}. If $(x, w) \notin \mathcal{R}$ for every $w$, then for every prover algorithm $P^*$ that outputs a linear function oracle $\proofO^*_i: \FF^{m_i} \rightarrow \FF$ in the $i$th round of the protocol initialized on $x$, the probability $V(\textsf{st}^V_t)$ returns $\textsf{Accept}$ is less than $\epsilon$. \\

\noindent \underline{Knowledge}. There exists a PPT knowledge extractor $\mathcal{E}$ such that for any prover algorithm $P^*$ and every $x$, if $V(\textsf{st}^V_t)$ outputs \textsf{Accept} in its interaction with $P^*$ on input $x$ with probability greater than $\delta$ then $\mathcal{E}^{P^*}(x)$ outputs $w$ such that $(x, w) \in \mathcal{R}$ in expected polynomial time. $\mathcal{E}^{P^*}(x)$ receives the input $x$ and interacts with $P^*$ via rewinding, sending partial transcripts and receiving $P^*$'s next output. (Although the verifier only accesses $P^*$'s output by querying a linear function oracle, $E$ reads the whole output).  \\

Furthermore, the linear IOP has \textbf{degree} $d$ if for each $i \in [t]$ and $\textsf{st}^V_{i-1}$ there are $\ell$ $\mu_i$-variate (at most) degree $d$ polynomial functions $p_1,...,p_\ell: \FF^{\mu_i} \rightarrow \FF^{m_i}$ such that $Q(\textsf{st}^V_{i-1}, \mathbf{r}_i) = p_i(\st_{i-1}, \mathbf{r}_i)$. The IOP is \textbf{algebraic} for a parameter $\lambda$ if $d = poly(\lambda)$.
It is \textbf{input-oblivious} if $x$ is not included in the state passed to $Q$, and is \textbf{stateless} if the only input to $Q$ in each round is the round index $i$ and $\mathbf{r}_i$.

%\alan{I think an algebraic linear IOP is sufficiently important and standalone and sufficiently different from a generic linear IOP for it to have its own definition --- which can be two lines referring to linear IOPs.}

\end{definition} 


\begin{definition}[HVZK for public-coin IOPs]
Let $\textsf{View}_{\langle P(x, w), Q(x) \rangle}(V)$ denote the view of the verifier in the $t$-round $\ell$-query interactive protocol described in Definition~\ref{def:linearIOP} on inputs $(x,w)$ with prover algorithm $P$ and query algorithm $Q$, consisting of all public-coin challenges and oracle outputs (\emph{i.e.}, equivalent to the final state $\textsf{st}^V_t$). The interactive protocol has $\delta$-statistical honest verifier zero-knowledge if there exists a probabilistic polynomial time algorithm $S$ such that for every $(x, w) \in \mathcal{R}$, the distribution $S(x)$ is $\delta$-close to $\textsf{View}_{\langle P(x, w), Q(x) \rangle}(V)$ (as distributions over the randomness of $P$ and random public-coin challenges).
\end{definition}

\paragraph{Preprocessing IOP} In some IOPs the verifier and prover might jointly establish an oracle together. (For IOPS with polynomial length PCPs, the verifier may equivalently read the entire contents of the PCP the first time it is received in order to check that it is correct). There are several reasons the verifier might want to query this oracle again later instead of storing its contents locally. One reason might be to save local storage space. Another reason might be to separate the protocol into an ``offline" or ``preprocessing" phase where the prover and verifier jointly establish several oracles, and an ``online" phase where the verifier queries the oracle. This is particularly useful if the oracles can be reused for verifying many different statements, which is the case with preprocessing SNARKs for NP.  %could be separated into an ``offline" might need to check the correctness of an entire oracle after it is first sent, or equivalently jointly establish the oracle together with prover

\subsection{Polynomial IOPs} 
\textbf{Polynomial IOPs} are a subclass of algebraic linear IOPs: in a $(\mu, d)$ polynomial IOP each proof oracle is a $\mu$-variate degree-$d$ polynomial and queries to this oracle return evaluations of the polynomial at points in $\FF^\mu$. In other words, each proof oracle is a restricted type of linear PCP that we call a \emph{polynomial PCP}. In this model, when the prover sends a polynomial PCP to the verifier, the verifier obtains for free a guarantee on the number of variables $\mu$ and the degree $d$ (\emph{i.e.}, equivalent to reading the length of the coefficient vector). 
%We use the notation $\tilde{f} \leftarrow \textsf{Send}(\mu, d, f(X))$ to denote sending such an oracle, and $y \leftarrow \textsf{Query}(\tilde{f}, z)$ to denote a query that returns $y = f(z)$. 

Observe that polynomial PCPs are ``short" like classical PCPs because they have a polynomial size representation as the coefficients of the polynomial or evaluations on $d+1$ points (when $d$ is polynomial size). Polynomial PCPs can implement classical PCPs defined as an $n$-length vector $\proofO$ over $\FF$ by interpolating a polynomial of degree $n+1$ over the components of $\proofO$. The polynomial oracle does not directly support ``index queries" that return individual coefficients of the polynomial. However, we show there is a two round polynomial IOP that implements this functionality. We also observe there is a polynomial IOP that implements ``inner products" between the coefficients of two polynomial oracles. 
%\alan{Important to note: these last two results hold only for univariate Polynomial IOPs.}

One implication of these observations is that algebraic linear IOPs can be implemented with polynomial IOPs, adding only several extra rounds of interaction. Each $\FF$-vector proof oracle $\proofO$ in the linear IOP is replaced with a polynomial oracle whose coefficient vector is $\proofO$. The polynomial functions $p_1,...,p_\ell: \FF^{\mu_i} \rightarrow \FF^{m_i}$ that generate the verifier's linear query are replaced with $\mu_i+1$ variate polynomial proof oracles. These are all established in the first round (or even in a preprocessing stage), in which the verifier can check these oracles for correctness. During the online IOP, whenever the prover receives a challenge $\mathbf{r}$, it computes the verifier's query vector $\mathbf{q}$, and sends this as a proof oracle $\proofO_q$ containing the polynomial with coefficients $\mathbf{q}$. This $\proofO_q$ can be checked for correctness against the query generation proof oracles through several queries at random points. Finally, $\proofO_q$ can be applied to a proof oracle $\proofO$, returning $\langle \proofO, \mathbf{q} \rangle$ by using the multiround univariate polynomial IOP for inner products. All of these steps are described in more detail in Section~\ref{sec:algebraicIOP} below. 

\paragraph{IOPPs and polynomial IOPs} It turns out that with multiple rounds of interaction, it is also possible to implement polynomial IOPs with classical IOPs, namely interactive oracle proofs of proximity (IOPPs)~\cite{STOC:ReiRotRot16,TCC:BenChiSpo16}. In particular, a univariate polynomial commitment scheme is implicit in the DEEP-FRI protocol~\cite{ECCC:BGKS19}, an improvement of FRI (Fast Reed-Solomon IOPP)~\cite{ICALP:BBHR18}. This connection is also explicitly described in a recent preprint~\cite{MatterLabs}. Evaluating committed polynomials using these techniques results in an IOP with polylogarithmic communication complexity.


\subsubsection{Univariate polynomial coefficient queries}~\label{sec:opencoefficient} 
For a polynomial $f \in \FF[X]$ let $f_i$ denote the $i$th coefficient. Given a polynomial PCP $f$ of at most degree $d$ with coefficient vector $(f_1,...,f_d)$, the following is a $(1, d)$-polynomial IOP for the statement $f_i = a$. In the polynomial IOP model each proof oracle sent to verifier is guaranteed to be a univariate polynomial of degree at most $d$; the verifier does not need to perform extra checks to ensure this.

\begin{itemize}

\item \emph{Prover}: Split $f(X)$ about the term $X^i$ into a lower part $f_L(X)$ of degree $i -1$ and an upper part $f_R(X)$ of degree $d - i - 1$ such that $f(X) - a X^i = X^{i+1} f_R(X) + f_L(X)$. Send polynomials $f$, $f_R(X)$, and $X^{d - i + 1}f_L(X)$. 

%The coefficients of $Compute commitments $c_R \leftarrow \pro{Commit}(\params, f_R(X))$ and $c_L \leftarrow \pro{Commit}(\params, f_L(X))$. Send $c_R$ and $c_L$ to the verifier. 

\item \emph{Verifier}: Sample uniform random  $\beta \leftarrow_R \FF_p$ and query for $y_R \leftarrow f_R(\beta)$, $y_L \leftarrow f_L(\beta)$, and $y \leftarrow f(\beta)$. 
Check that $y = y_L \beta^{-d + i - 1} + \beta^{i+1} y_R - a \beta^i \bmod p$ and return $0$ (abort) if not. Otherwise output $1$ (accept). 

%\item \emph{Prover}: Evaluate $y_R \leftarrow f_R(\beta)$, $y_L \leftarrow f_L(\beta)$, and $y \leftarrow f(\beta)$. Send $y_R, y_L, y$ to the verifier. 

%\item Prover and verifier run: 
%\begin {itemize} 
%\item  $\pro{Eval}(\params, c_R, \beta, y_R, d - i -1; f_R(X))$ 
%\item $\pro{Eval}(\params, c_L, \beta, y_L, i -1; f_L(X))$ 
%\item $\pro{Eval}(\params, c, \beta, y, d; f(X))$
%\end{itemize} 
%Verifier aborts and outputs $0$ if either subprotocol returns $0$. Otherwise it outputs $1$. 

\end{itemize}

\paragraph{Knowledge extraction} We need to show there is knowledge extractor that extracts $f$ with $i$th coefficient $a$. The verifier only accepts given proof oracles for degree $d$ polynomials $f$, $f_0$, and $f_1$ in $\FF_p[X]$ such that $f(\beta) = f_0(\beta) \beta^{-d + i - 1} + \beta^{i+1} f_1(\beta) + a\beta^i$ for random $\beta \sample \FF$. If $f(X) \neq f_0(X) X^{-d + i -1} + X^{i+1}f_1(X) + aX^i$ then the verifier would accept with probability $d/|\FF|$. Since $f_0, f_1$ are degree (at most) $d$ univariate polynomials, it follows that $f_0(X) X^{-d + i -1}$ has degree at most $i -1$ and $X^{i+1}f_1(X)$ has degree at least $X^{i+1}$. This implies that $a$ is the $i$th coefficient of $f$. The extractor obtains $f$ directly. 

 

\subsubsection{Polynomial IOP for inner product}\label{sec:innerproduct}
The following is an IOP where the prover first sends two degree $d$ univariate polynomial oracles $f, g$ and proves to the verifier that $\langle \mathbf{f}, \mathbf{g}^r \rangle = a$ where $\mathbf{f}, \mathbf{g}$ denote the coefficient vectors of $f, g$ respectively and $\mathbf{g}^r$ is the reverse of $\mathbf{g}$. This argument is sufficient for our application to transforming algebraic linear IOPs into polynomial IOPs. It is also possible to prove the inner product $\langle \mathbf{f}, \mathbf{g} \rangle$ by combining this IOP with another one that probes the relation $g(X) = X^dg^r(X^{-1})$ in a random point $z \sample \mathbb{F} \backslash \{0\}$, and thereby shows that $\mathbf{g}$ and $\mathbf{g^r}$ have the same coefficients only reversed, but we omit this more elaborate construction for the sakes of clarity and space.

\begin{itemize}
\item \emph{Prover}: Sends proof oracles for $f(X)$, $g(X)$, and the degree $2d$ polynomial product $h(X) = f(X)\cdot g(X)$ to the verifier. 
\item \emph{Verifier}: Chooses $\beta \sample \FF$ and queries for $y_1 \leftarrow f(\beta)$, $y_2 \leftarrow g(\beta)$, and $y_3 \leftarrow h(\beta)$. Check that $y_1 y_2 = y_3$ and return $0$ (abort) if not.
\item Prover and verifier engage in the 1 round IOP (Section~\ref{sec:opencoefficient}) for proving that the $d$th coefficient (\emph{i.e.}, on term $X^d$) of $h(X)$ is equal to $a$. (The proof oracles for this subprotocol can all be sent in the first round, so this does not add an additional round). Abort and output $0$ if this fails, otherwise return 1 (accept). 
\end{itemize}

\paragraph{Knowledge extraction} If $h(X) \neq f(X) \cdot g(X)$ then the verifier's check $y_1 y_2 = y_3$ at the random point $\beta$ fails with probability $(|\FF| - d')/|\FF|$, where $d' = \max(\deg(h(X)),$ $\deg(f(X)\cdot{}g(X)))$. The extractor directly obtains $h(X)$, and by definition the middle coefficient (\emph{i.e.}, on the monomial $X^d$) of $h(X)$ is the inner product $\langle \mathbf{f}, \mathbf{g}^r \rangle$. Combined with the the knowledge extraction property of the IOP for opening coefficients, it follows that this inner product is equal to $a$.  
%\alan{This does not work unless you flip $g(X)$.}

\subsubsection{Reducing algebraic linear IOPs to polynomial IOPs} 
\label{sec:algebraicIOP}
\begin{lemma}\label{lem:algebraicIOPcompiler}
Any $t$-round stateless input-oblivious algebraic\alan{insert "linear"?} IOP can be implemented with a $t+1$-round polynomial IOP. Suppose the original $\ell$-query IOP is $(\mu,d)$ algebraic with query length $(m_1,...,m_t)$ then the resulting polynomial IOP has for each $i \in [t]$: $2\ell$ degree $m_i$ univariate oracles, $\ell$ multivariate polynomials of degree $d$ and $\mu+1$ variables, $\ell$ degree $2m_i$ univariate oracles %(for inner products), 
and $2\ell$ degree $2m_i$ univariate oracles. %(for coefficient openings). 
There is exactly one query to each oracle on a random point in $\FF$.
\end{lemma}

\alaninline{Is this the main theorem? If so, why not upgrade it from lemma to theorem? A theorem like this needs a) an algorithm, either a compiler that takes the original IOP as input and outputs a new one, or a new IOP described in terms of oracle access to the original IOP; a proof of completeness and soundness. I think completeness follows from construction, but there is definitely some soundness loss!}
\alaninline{Also, where does the description of the compiler/new IOP start? The following text could achieve various things, including providing extra background or intuition before the proof is presented, it could be part of Lemma 10, or it could be the first step of the compiler.}
\alaninline{Also: offline oracle refers to oracles sent in the preprocessing phase? That's the most likely explanation in my reading, but I might be wrong. And if I'm right, then it might be worthwhile to make it explicit for the reader that this offline/online distinction refers to the paragraph about preprocessing earlier.}

\paragraph{Offline oracles} For each $i$th round there are $\ell$ query generation functions $P_1,...,P_\ell: \FF^\mu \rightarrow \FF^{m_i}$, where the $j$th component of $P_k(\mathbf{r}_i)$ is a $\mu$-variate degree $d$ polynomial function\alan{Is there a difference between a polynomial and a polynomial function? If not, don't use the second term because the reader will wonder what the difference is.} $p_{k,j}(\mathbf{r}_i)$. In the offline phase, the prover and verifier establish several $\mu+1$-variate degree $d$ polynomial oracles (e.g. prover sends to verifier and verifier checks each at $d+1$ points). %verifier and the verifier sends  uses $\Gamma$ to generate a commitment $c_{P_k}$ to $(p_{k,1},..., p_{k,m_i})$ as follows:
 
For each $k \in [\ell]$, the vector $(p_{k,1},...,p_{k, m_i})$\alan{This is a vector of polynomials, not of scalars, correct?} is encoded as a polynomial in $\mu + 1$ variables as follows. Let $\mathbf{X} = (X_1,...,X_\mu)$ and $Z$ denote the $(\mu+1)$'st indeterminate, then define $\tilde{P}_k(\mathbf{X}, Z) := \sum_{j=1}^{m_i} p_{k,j}(\mathbf{X}) Z^j$.
The prover and verifier establish the oracle $\tilde{P}_k$. 

\paragraph{Online IOP}
The original linear IOP is modified as follows. 

\begin{itemize}

\item Wherever the original IOP prover sends an oracle $\proofO$ of length $m_i$, the new prover sends a degree $m_i - 1$ \alan{univariate?}polynomial oracle $f_\pi$ whose coefficient vector is \emph{the reverse} of $\proofO$. 

\item Wherever the original IOP\alan{The prover or the verifier?} makes $\ell$ queries\alan{What if the verifier chooses the next query depending on the answers to the previous ones?} within a round to a particular proof oracle $\proofO$, where queries are defined by query matrix $\mathbf{Q} \in \FF^{m_i \times \ell}$, consisting of column query vectors $(\mathbf{q}_1,...,\mathbf{q}_\ell)$, the new prover and verifier engage in the following interactive subprotocol for each $k \in [\ell]$: \alan{What does this subprotocol accomplish?}

\begin{itemize}
 \item Prover: Send an oracle for the polynomial $F_k$ whose coefficient vector is $\mathbf{q}_k$. \alan{How does the prover know this coefficient vector if the verifier didn't send $\mathbf{r}$ or $\mathbf{Q}$ yet?}
 
 \item Verifier: Run the original IOP verifier to get the message $\mathbf{r}$ such that $Q(\mathbf{r})$ defines the original verifier's queries in the current round. Sample uniform random $\beta \sample \FF$ and query both $F_k$ and $\tilde{P}_k$ at $\beta$ in order to check that $F_k (\beta) = \tilde{P}_k(\mathbf{r}, \beta)$. If the check fails, aborts and output 0. \alan{$\tilde{P}_k$ is as it is defined in the offline oracles paragraph? Maybe anticipate the link or make it explicit.}
 
% \item The prover evaluates $y_1 \leftarrow \mathbf{q}_k(\beta)$ and $y_2 \leftarrow \tilde{P}_k(\mathbf{r}_i, \beta)$ and sends these to the verifier. The verifier aborts if $y_1 \neq y_2$ and returns 0. 
% \item Assume at this point $y = y_1 = y_2$. The prover and verifier run $\eval(\params, c_{\mathbf{q}_k}, \beta, y, m_i; \mathbf{q}_k)$ and $\eval(\params, c_{P_k}, (\mathbf{r}, \beta), y, d; \tilde{P}_k)$. If the verifier returns 0 in either subprotocol, the verifier aborts and outputs 0. 
 
 \item Prover: Compute $a_k = \langle \proofO, \mathbf{q}_k \rangle$ and sends $a_k$ to the verifier. 
 
 \item The prover and verifier run the inner product polynomial IOP from Section~\ref{sec:innerproduct} on the oracles $F_k$ and $f_\pi$ to convince the verifier that $a_k = \langle \mathbf{q}_k, \proofO \rangle$. If the inner product subprotocol fails the verifier aborts and outputs 0.  
 \end{itemize}
\end{itemize}

If all substeps succeed the the verifier obtains correct output of each oracle query from the original IOP. These outputs are passed to the original verifier decision algorithm, which either accepts or rejects. 

\paragraph{Round complexity} The prover and verifier can first simulate the $t$-round original IOP  on the verifier's public-coin challenges, proceeding as if all queries were answered honestly. Wherever the original IOP prover would send an oracle for the vector $\proofO$ the prover sends $f_\pi$. Then, after the verifier has sent its final public coin challenge from the original IOP, there is one more round in which the prover sends all $F_{i, k}$ for the $k$th query vector in the $i$th round and all the purported answers $a_{i, k}$ to the $k$th query in the $i$th round. The prover/verifier engage in the protocol above to prove that these answers are correct. The inner product subprotocol for each $F_{i,k}$ with $f_\pi$ can be done in parallel with the check that $F_{i,k}(\beta) = \tilde{P}_{i,k}(\mathbf{r}_i, \beta)$. Thus, there is only one extra round.    


\subsection{Compiling polynomial IOPs} 
\label{subsec:compiling}
%We are now ready to present our main theorems. We formulate two separate theorems: the first pertains only to compiling polynomial IOPs, and the second deals with more general stateless input-oblivious algebraic IOPs. The first result is more practical because it yields interactive arguments with quasi-linear prover time. In fact, there is a concrete instantiation of the polynomial IOP (used in Sonic~\cite{Sonic}) that results in an interactive argument with both quasi-linear prover time and logarithmic communication/verification. The second result is less practical because it only guarantees polynomial prover time, but includes a much broader spectrum of concrete instantiations, including QAP-based IOPs. The prover time in a QAP-based instantiation is quadratic. These instantiations are discussed in more detail in Section~\ref{sec:instantiations}. \\

%\noindent \emph{Remark on $(\mu, d)$}: For simplicity, in our general theorems statements we consider $(\mu, d)$ polynomial IOPs where every polynomial PCP oracle is a $\mu$-variate degree $d$ polynomial. This is without loss of generality because $(\mu, d)$ can be viewed as an upper bound on the variables and degree. Of course, when a polynomial IOP involves a combination of oracles with different $\mu$ and $d$, the cryptographic compiler may indeed gain efficiency by taking advantage of this. We could formulate a more fine-grained theorem for $\{\mu_i, d_i\}$ polynomial IOPs where the $i$th round PCP is a $\mu_i$-variate degree $d_i$ polynomial. 
%We similarly use a fixed $(\mu, d)$ upper bound on the variables/degree of the query generation polynomials in our theorem concerned with compiling algebraic linear IOPs. In Section~\ref{sec:instantiations} we discuss optimizations for concrete instantiations. 

\subsubsection*{Compilation I: polynomial IOP to IP} 
Let $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open}, \pro{Eval})$ be a multivariate polynomial commitment scheme. Given any $t$-round polynomial IOP for $\mathcal{R}$ over $\FF$, construct an interactive protocol\alan{Does this interactive protocol consist of \setup, \prover, \verifier; or just the last two? Maybe give it a name, \emph{e.g.}, $\Pi$.} as follows: 
\begin{itemize}
\item Run $\params \leftarrow \pro{Setup}(1^\lambda)$
\item Replace\alan{Replace where? the IOP is not a transcript.} each $(\mu, d)$ polynomial proof oracle $\proofO: \FF^\mu \rightarrow \FF$ with a commitment $c_{\proofO} \leftarrow \pro{Commit}(\params; \proofO)$ 
\item Replace each verifier \emph{evaluation} query $\mathbf{r}$ to a $(\mu, d)$ polynomial proof oracle $\proofO$ with a interactive execution of $\pro{Eval}(\params, c_\pi, \mathbf{z}, y, \mu, d; \proofO)$, where $\proofO(\mathbf{z}) = y$. 
\end{itemize}

If the \alan{IP verifier or IOP verifier?}verifier does not abort in any of these subprotocols, then it receives a simulated IOP transcript of oracle query outputs. It runs the IOP verifier $V$ on this transcript and outputs the result. \alan{But the IOP verifier is an interactive algorithm, it cannot be run on a non-interactive transcript.}

\paragraph{Optimization: delayed evaluation} As an optimization to reduce round-complexity and enable batching techniques, all invocations of $\pro{Eval}$ can be delayed until the final round, and heuristically could be run in parallel. Delaying the evaluations until the final round does not affect our analysis. However, our analysis does not consider parallel execution of the $\pro{Eval}$ subprotocols. We assume the protocol transcript contains an isolated copy of each $\pro{Eval}$ instance and does not interleave messages or re-use randomness.
%We begin with a lemma on using polynomial commitments (that has witness-extended emulation) to compile a public-coin polynomial IOP with negligible knowledge error into a public-coin interactive argument with witness-extended emulation. 

\begin{lemma}\label{lem:IOPcompiler}
If the polynomial commitment scheme $\Gamma$ has witness-extended emulation and the $t$-round polynomial IOP for $\mathcal{R}$ has negligible knowledge error, then \emph{Compilation I} generates a public-coin interactive argument for $\mathcal{R}$ that has witness-extended emulation. The compilation also preserves HVZK if $\Gamma$ is hiding and $\eval$ is HVZK. 
\end{lemma}

\begin{proof}
The fact that the compilation preserves HVZK is straightforward. We prove this part first and then move on to proving witness-extended emulation. 

\paragraph{HVZK} Let $S_\eval$ denote the HVZK simulator for $\eval$ and $S_\pro{IOP}$ denote the HVZK simulator for the original polynomial IOP. We construct an HVZK simulator $S$ for the compiled interactive argument as follows. 
$S$ begins by running $S_\pro{IOP}$ on the input $x$, which produces a series of query/response pairs to arbitrarily labeled oracles that are ``sent" from the IOP prover to the verifier. $S$ simulates the view of the honest verifier in the compiled interactive proof by replacing each distinctly labeled oracle with a fresh $\Gamma$ commitment to $0$, \emph{i.e.}, the zero polynomial over $\FF_p$. By the hiding property of $\Gamma$ this has negligible distance $\delta_0$ from the commitment sent in the real protocol.
(It places this commitment at the location in the transcript where the commitment to this oracle would be sent in the compiled protocol).
 For each query/response pair $(z, y)$ to an oracle, $S$ runs $S_\eval$ to simulate the view of an honest-verifier in the $\eval$ protocol opening a hiding polynomial commitment to the value $y$ at the point $z$. Let $P$ denote an upper bound on the total number of oracles sent and $Q$ denote an upper bound on the total number of queries to IOP oracles. 
If the simulation of $S_\pro{IOP}$ has statistical distance $\delta_1$ from the real IOP verifier's view, and each simulated $\eval$ subprotocol has statistical distance $\delta_2$ to the real $\eval$ verifier's view, then the output of $S$ has statistical distance at most $P/\delta_0 + \delta_1 + Q/\delta_2$\alan{Where does this formula come from? (In fact I think it's false, but I'm not sure how to correct it.} from $\textsf{View}_{\langle P(x, w), V(x) \rangle}$. For $P, Q < \poly$ and $\delta_0, \delta_1, \delta_2 < \negl$ this statistical distance is negligible in $\lambda$. 

\paragraph{Witness-extended emulation (knowledge)}
Without loss of generality, assume the original IOP makes at least one query to each oracle sent (\emph{i.e.}, the queries derived from the verifier's random challenge in this round\alan{which round?} contain at least one\alan{one what?} per proof oracle). An oracle which is never queried can be omitted from the IOP.

We denote by $\verifier$ the IP verifier for the compiled IP, and $\verifier_{O}$ the verifier for the original IOP. 
Given a record oracle $\pro{Record}(P^*, \params, x, \st)$ for an IP prover $P^*$ that produces accepting transcripts with non-negligible probability, we build an emulator $E$ for the compiled IP. $E$ begins by constructing an IOP adversary $P'_{O}$, which succeeds also with non-negligible probability on input $x$. Every successful interaction of $P'_{O}$ with $\verifier_{O}$ on input $x$ corresponds to a successful transcript of $P^*$ with $V$ on $x$. In showing how $E$ builds $P'_{O}$ we also show how $E$ can obtain this corresponding transcript. $E$ will make use of the emulator $E_\eval$ for the commitment scheme $\Gamma$. %We will describe how this is done in the later parts of the proof. Accepting that this is true. 

Finally, $E$ can use the IOP knowledge extractor $E_{\pro{IOP}}^{P'_O}(x)$ in order to output a witness for $x$ along with the corresponding transcript. 

\paragraph{Constructing $P'_O$ (IOP adversary)}
$P'_O$ runs as follows on initial state $\st_0$ and input $x$. It internally simulates the interaction of $P^*$ and $V$, using the record oracle $\pro{Record}(P^*, \params, x, \st)$. It begins by running this for the first round on state $\st_0$. For every message that $P^*$ sends in this first round, $P'_O$ continues simulation until there is an $\eval$ on this commitment. (There is guaranteed to be at least one $\eval$ on each commitment, independent of the randomness). Therefore, denoting by $E_\eval$ the extractor for the $\eval$ subprotocol between $P^*$ and $\verifier$ on a given commitment and evaluation point, the record oracle can be used to simulate $E_\eval$'s record oracle.% for each $m$ evaluated at some point determined by $V$'s challenge.

For each message $m$ that $P^*$ sends to $V$ at the beginning of the first round, $P'_O$ interprets $m$ as a commitment, and attempts to extract from it a polynomial by 
running the PPT emulator $E_\eval$, simulating its record oracle as just described. \textbf{If it fails in any extraction attempt it aborts.} 

If $P'_O$ succeeds in all these extractions, then it uses these extracted polynomials as its first round proof oracles that it gives to $\verifier_O$. Upon receiving the first public-coin challenge from the IOP verifier, $P'$ uses the query function to derive the corresponding queries to each of these proof oracles. Before answering, it rewinds $P^*$ and $\verifier$ back to the point immediately after $P$ sent its first messages, and now substitutes random challenge from $\verifier_O$ in order to simulate $P^*$ and $V$ on these same queries. It checks that $P^*$'s answers are consistent with the answers it can compute on its own from the extracted polynomials. \textbf{If any answers are inconsistent, $P'_O$ aborts}. Otherwise, it sends the answers to $\verifier_O$. 

At the end of this first round (assuming $P'$ has not yet aborted), $P'_O$ has stored an updated state $\st'$ for $P^*$ based on this simulation. It proceeds to the next round and repeats the same process, using the record oracle $\pro{Record}(P^*, \params, x, \st')$. Finally, if $P'$ makes it through all rounds without aborting, then it has a final state $\st_V$ for $\verifier_O$ based on its internal simulation of $P^*$ and $V$ up through the end of the last round. Finally, $\verifier_O(\st_V)$ outputs $\pro{Accept}$ or $\pro{Reject}$. %(Observe that $\verifier_O$ accepts if and only if $\verifier$ would accept in the simulated transcript with $P^*$ because they run the same decision algorithm on the final state of query/response pairs). % $1$ on $\st_V$. (This is due to the fact that the verifier in the compiled IOP runs the same final decision algorithm as the IOP verifier). 

\paragraph{Analysis of $P'_O$ success probability} 
We claim that if $\pro{Record}(P^*, \params, x, \st_0)$ outputs an accepting transcript $\tr$ with non-negligible probability, then $P'_O$ succeeds with non-negligible probability. 

Observe that for any accepting $\tr$ between $P^*$ and $V$, if $P'_O$ happens to follow the same exact sequence of query/responses without ever aborting then it succeeds because $\verifier_O$ and $\verifier$ run the same decision algorithm on the final state of query/response pairs. Thus, it remains only to take a closer look at what events cause $P'_O$ to abort, and bound the fraction of accepting $\tr$ for which this occurs. 

As indicated in bold above, there are two kinds of events that cause $P'_O$ to abort: 
\begin{itemize}
\item It fails to extract from a ``commitment" message $m$ sent by $P^*$
\item After successfully extracting a polynomial $f$ from a commitment, $P^*$ answer queries to $f$ in a way that is inconsistent with $f$. 
\end{itemize}

The second type of event contradicts the evaluation binding property of $\Gamma$, therefore it occurs with negligible probability. 

To analyze the first type of event, let us define ``bad commitments" for a parameter $B$. We define this as a property of a message $m$ (purportedly a commitment) sent in a transcript state $\st$.

\paragraph{Bounding probability of commitment extraction failure} 
The pair $(m, \st)$ is a ``bad commitment" if there is less than a $1/B$ probability that extending the transcript between $P^*$ and $\verifier$, starting from state $\st$, will contain a successful execution of $\eval$ on $m$. This probability is over the randomness of the public-coins of $\verifier$ in the extended transcript. %have a succesful execution on (over the randomness of the public-coins) that $\pro{Record}(P^*, \params, x, \st)$ contains a successful execution of $\eval$ on $m$ on the queries defined by $\st$ and the next public coin challenge, where $\st$ is determined by running $\tr$ up until the point $m$ appears. 

\alan{So $B$ is different from $B(\tr)$. That's a little confusing.}Let $A(\tr)$ denote the event that a transcript $\tr$ sampled from $\pro{Record}(P^*, \params, x, \st_0)$ is accepting. Let $B(\tr)$ denote the event that $\tr$ contains a ``bad commitment" (\emph{i.e.}, some message $m$ sent in state $\st$ such that $\pro{Bad}(m, \st) = 1$). The conditional probability of event $A(\tr)$ conditioned on event $B(\tr)$ is less than $1/B$. To see this, fix $(m, \st)$ with $\pro{Bad}(m, \st) = 1$ and consider ``sampling" a random $\tr$ that contains $m$ at state $\st$. This is done by first choosing randomly from all partial transcripts that result in $(m, \st)$ via brute force, and then running the transcript normally from state $\st$ on random public-coins. No matter how $(m, \st)$ is chosen, the probability that this process produces an accepting transcript is by definition less than $1/B$. (The second part of the transcript following $(m, \st)$ contains at least one execution of $\eval$ on $m$ by hypothesis, and by the definition of $B(m, \st) = 1$ this execution is accepting with probability less than $1/B$).

Assume that $P(A(\tr)) \geq 1/\poly$. Applying Bayes' law, %letting $A(\tr)$ denote the event that $\tr$ is accepting and $P(A(\tr)) > 1/\poly$ the a-priori probability of this event, 
$P[B(\tr) | A(\tr)) \leq P[A(\tr) | B(\tr)] / P(A(\tr)) \leq \poly / B$. 
In other words, at least a $1 - \poly/B$ fraction of accepting transcripts do not contain ``bad commitments". %By a union bound, in a length $L$ transcript void of bad commitments, the transcript does not contain any failed $\eval$ with probability at least $L/B$. 
Furthermore, so long as a commitment $m$ is not ``bad", we can invoke the witness-emulation property of $\eval$ to say that the PPT $E_\Gamma$ emulator extracts a witness polynomial from each $m$ with overwhelming probability.

Setting $B = 2 \poly$ we get that on at least a $1/2$ fraction of accepting transcripts, $P'_O$s simulation also succeeds (\emph{i.e.}, successfully extracts from each prover commitment message) with probability at least $1/2$. This means that $P'_O$ has a non-negligible success probability conditioned on the event that $\tr$ is an accepting transcript. 

In conclusion, if $\tr$ is accepting with non-negligible probability, then there is a non-negligible probability that $P'_O$ succeeds. 


\end{proof}

\subsection{Concrete Instantiations} 
We discuss three concrete examples of polynomial IOPs to which we can apply our polynomial commitment compiler. Section~\ref{sec:optimizations} discusses optimizations and performance estimates for a compilation of the polynomial IOP introduced in \textsf{Sonic}~\cite{Sonic} and improved in \textsf{PLONK}~\cite{Plonk}. 

\subsubsection{Sonic} 
\textsf{Sonic} is zk-SNARK system that has a universal trusted setup, which produces a $CRS$ of $n$ group elements that can be used to prove any statement represented as arithmetic circuits with at most $n$ gates. The CRS can also be updated (e.g. to handle larger circuits, or increase the trust distribution) without re-doing the initial setup. The result in \textsf{Sonic} was not presented using the language of IOPs. Furthermore, the result also relied on a special construction of polynomial commitments (a modification of Kate et. al.~\cite{AC:KatZavGol10}) that forces the prover to commit to a Laurent polynomial with no constant term. Given our generic reduction from coefficient queries to evaluation queries (Section~\ref{sec:opencoefficient}), we re-characterize the main theorem of \textsf{Sonic} as follows: 

\begin{theorem}[Sonic Bivariate, \cite{Sonic}]
There exists a 2-round HVZK polynomial IOP with preprocessing for any NP relation $\mathcal{R}$ (with arithmetic complexity $n$) that makes 1 query to a bivariate polynomial oracle of degree $n$ on each variable, and 6 queries to degree $n$ univariate oracles. The preprocessing verifier does $O(n)$ work to check the single bivariate oracle. 
\end{theorem}

The number of univariate queries increased from the original $3$ in \textsf{Sonic} (with special commitments) to $6$ with our generic coefficient query technique. For uniform circuits\alan{As in, circuits that are the output of a polynomial-time Turing machine?}, the bivariate query is not necessary and can be evaluated efficiently by the verifier.\alan{This sentence does not make any sense to me.} If we were to compile the bivariate query directly using our multivariate commitment scheme this would result in $O(n^2)$ prover time (a bivariate polynomial with degree $n$ on each variable is converted to a univariate polynomial of degree roughly $n^2$). However, \textsf{Sonic} also provides a way to replace the bivariate polynomial with several degree $n$ univariate polynomials and more rounds of communication. 

\begin{theorem}[Sonic Univariate, \cite{Sonic}]\label{thm:sonic} 
There exists a 5-round HVZK polynomial IOP with preprocessing for any NP relation $\mathcal{R}$ (with arithmetic complexity $n$) that makes 27 queries overall to univariate degree $n$ polynomial oracles. The preprocessing verifier does $O(n)$ work to check $12$ univariate degree $n$ polynomials. 
\end{theorem}


The recent system \pro{PLONK} is an improvement on the underlying polynomial IOP in \pro{Sonic}, and achieves the following: 

\begin{theorem}[PLONK,~\cite{Plonk}] 
There exists a 3-round HVZK polynomial IOP with preprocessing for any NP relation $\mathcal{R}$ (with arithmetic complexity $n$) that makes 3 queries overall to univariate degree $3n$ polynomial oracles. Preprocessing? %The preprocessing verifier does $O(n)$ work to check $12$ univariate degree $n$ polynomials.
\end{theorem}

Combining the \pro{Sonic} IOP with the new transparent polynomial compiler of Section~\ref{sec:protocol} gives the following result:  

\ben{TODO: Add actual complexity for preprocessing and prover rather than quasilinear} 
\begin{theorem}
There exists an $O(\log n)$-round public-coin interactive argument of knowledge for any NP relation of size\alan{What's the difference between size and arithmetic complexity?} $n$ that has $O(\log n)$ communication, $O(\log n)$ ``online" verification, quasilinear prover time, and a preprocessing step that is verifiable in quasilinear time. The argument of knowledge has witness-extended emulation assuming it is instantiated with a group $\GG$ for which the Order Assumption\alan{Order Assumption is not necessary in addition to SRA and ARA.}, the Strong RSA Assumption, and the Adaptive Root Assumption all hold. 
\end{theorem}
\begin{proof}
We apply the univariate polynomial commitment scheme from Section~\ref{sec:protocol} to the 5-round polynomial IOP from Theorem~\ref{thm:sonic}. Denote this commitment scheme by $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open}, \pro{Eval})$ 

The preprocessing requires running $\pro{Commit}$ on $12$ univariate degree $n$ polynomials, which involves a quasilinear number of group operations in the group of unknown order $\GG$ determined by $\pro{Setup}$. The prover sends a constant number of proof oracles of degree $n$ to the verifier, which also takes a quasilinear number of group operations. Finally, the 27 queries are replaced with at most $27$ invocations of $\eval$, which adds $O(\log n )$ rounds and has $O(\log n)$ communication. By Theorem~\ref{thm:polycommitsecurity} ($\Gamma$ has witness extended emulation) and Lemma~\ref{lem:IOPcompiler}, the compiled interactive argument has witness-extended emulation.

\end{proof}

\subsubsection{Spartan}
\textsf{Spartan}~\cite{Spartan} transforms an arbitrary circuit satisfaction problem into a polynomial IOP based on an arithmetization technique developed by Blumberg et. al. \cite{EPRINT:BTVW14}, which improved on the classical techniques of Babai, Fortnow, and Lund~\cite{BFL}. Specifically, satisfiability of a 2-fan-in arithmetic circuit on $n$ gates can be transformed into the expression: 
\begin{equation}\label{eqn:hypercubesum}
\sum_{x, y, z \in \{0,1\}^{\log n}} G(x, y, z) = 0
\end{equation} 
for a multilinear polynomial $G$ on $3 \log n$ variables over $\FF$. 
Furthermore, $G$ decomposes into the form: 
$$G(x,y,z) = A(x,y,z) F(x) + B(x, y, z) F(y) + C(x, y, z) F(y) F(z)$$
where $A, B, C,$ and $F$ are all multilinear poylnomials. The polynomials $A, B, C$ are derived from the arithmetic circuit defining the relation $\mathcal{R}$ and are input-independent. $F$ is degree $1$ with $\log n$ variables and is derived from a particular $(x, w) \in \mathcal{R}$. For uniform circuits, the verifier can evaluate $A, B, C$ locally in $O(\log n )$ time. The LFKN sum-check protocol~\cite{FOCS:LFKN90} is applied in order to prove Expression~\ref{eqn:hypercubesum} in a $3\log n$ round polynomial IOP, where the prover's oracle consist of $Z$ and the low-degree polynomials sent in the sumcheck. Since the extra low-degree polynomials are constant size they can be read entirely by the verifier in constant time rather than via oracle access, and hence we ignore them in the total oracle count. The main result in Spartan can be summarized in our framework as follows: 

\begin{theorem}[Setty19]
There exists a $3 \log n$ round polynomial IOP for any NP relation $\mathcal{R}$ computed by a \textbf{uniform} circuit with arithmetic complexity $n$, which makes three queries to a $\log n$-variate degree 1 polynomial oracle.  
\end{theorem}

Applying our multivariate compiler to the \textsf{Spartan} polynomial IOP we obtain an $O(\log n)$-round public-coin interactive argument of knowledge for uniform circuits of size $n$. In our multivariate scheme (Section~\ref{sec:multivariate}), the $\log n$-variate degree 1 polynomial is tranformed into a univariate polynomial of degree $n$. With only three queries overall, the communication is just $6 \log n$ group elements and $6 \log n$ field elements. 

\subsubsection{QAPs and R1CS} 

QAPs and R1CS constraint systems can be expressed as linear PCPs~\cite{TCC:BCIOP13,C:BCGTV13}. We review here how to express R1CS as a one round public-coin $(1, n)$ algebraic IOP. (This captures the satisfiability of any circuit with multiplicative complexity $n$, which is first translated to a system of quadratic equations over degree $n$ polynomials). Each linear query is computed by a vector of degree $n$ univariate polynomials evaluated at a random point chosen by the public-coin verifier. '

\paragraph{R1CS} \alan{This actually describes QAP not R1CS.} The language R1CS over $\FF$ contains systems of satisfiable \emph{rank-1 quadratic equations}. An R1CS instance is defined by length $m+1$ polynomial vectors $A(X)$, $B(X)$, $C(X)$ such that the $i$th components $A_i(X)$, $B_i(X)$, $C_i(X)$ are all degree $n-1$ polynomials over $\FF_p[X]$ for $i \in [0,m]$, and $A_m = B_m = C_m$ is the degree $n$ polynomial $Z(X)$ that vanishes on a specified set of $n$ points in $\FF_p$. There is a length $m-1$ witness vector $\mathbf{w}$ whose first $\ell$ components are equal to the instance $\mathbf{x} \in \FF^\ell$, and a degree $n$ ``quotient" polynomial $H(X)$, such that the following constraint equation is satisfied: 
\begin{equation} \label{eqn:R1CS} 
\begin{split}
[(1, \mathbf{w}, \delta_1)^\top A(X)][(1, \mathbf{w}, \delta_2)^\top B(X)] 
- (1, \mathbf{w}, \delta_3)^\top C(X) = H(X)Z(X) \\ 
\ and \ (1,\mathbf{w})^\top (1,X,...,X^{\ell}, \mathbf{0}^{m- \ell -1}) = (1,\mathbf{x})^\top (1, X,...,X^{\ell})
\end{split} 
\end{equation} \alan{What do $\delta_0, \delta_1, \delta_2$ do? Also, I'm not sure the dimensions work out.}

\paragraph{R1CS algebraic linear PCP} Equation~\ref{eqn:R1CS} is turned into a set of linear queries by evaluating the polynomials at a random point in $\FF$. Satisfaction of the equation evaluated at a random point implies satisfaction of the polynomial equation with error at most $2n / |\FF|$ by Schwartz-Zippel. Translated to an algebraic IOP, the prover sends a proof oracle $\proofO_w$ containing the vector $(1, \mathbf{w}, \delta_1, \delta_2, \delta_3)$ as well as a proof oracle $\proofO_h$ containing the coefficient vector of $H(X)$. A common proof oracle $\proofO_z$ is jointly established containing the coefficient vector of $Z(X)$. 

The verifier chooses a random point $\alpha \in \FF$ and makes four queries to $\proofO_w$, computed by the polynomial vectors $A(X), B(X), C(X)$ and $D(X) = (1, X,...,X^\ell, \mathbf{0}^{m- \ell -1})$. The verifier makes one query each to $\proofO_h$ and $\proofO_z$, which is the evaluation of $H(\alpha)$ and $Z(\alpha)$ respectively. The verifier obtains query responses $y_a, y_b, y_c, y_d, y_h, y_z$ and checks that $y_a \cdot y_b - y_c = y_h y_z$ and $y_d = \langle (1, \mathbf{x}), D(\alpha) \rangle$. 

\paragraph{Compiling R1CS to public-coin argument} 

Following the compilation in Lemma~\ref{lem:algebraicIOPcompiler} (Section~\ref{sec:algebraicIOP}), the R1CS algebraic linear PCP can be transformed into a $2$-round polynomial IOP. For simplicity, assume $m+3 < n$, where $m-1$ is the length of the witness and $n$ is the multiplicative complexity of the circuit. The preprocessing establishes three bivariate degree $n$ polynomials (\emph{i.e.}, encoding $A(X), B(X), C(X)$) and two univariate degree $n$ polynomials (\emph{i.e.}, encoding $Z(X)$ and $D(X)$). In the 2-round online phase the prover sends a degree $n$ univariate oracle for the witness vector $(1, \mathbf{w}, \delta_1, \delta_2, \delta_3)$, a degree $n$ univariate oracle for $H(X)$, four degree $n$ univariate oracles encoding linear PCP queries, four degree $2n$ univariate oracles encoding polynomial products, and eight degree $2n$ univariate oracles for opening inner products. The total number of polynomial oracle evaluation queries is $3$ bivariate degree $n$, $8$ univariate degree $2n$, and $7$ univariate degree $n$.

\begin{theorem}[R1CS polynomial IOP]
There exists a $2$-round polynomial IOP with preprocessing for any NP relation $\mathcal{R}$ (with multiplicative complexity $n$) that makes $7$ queries to univariate degree $n$ oracles, $8$ queries to univariate degree $2n$ oracles, and $3$ queries to bivariate degree $n$ oracles.  
\end{theorem}
 
While theoretically intriguing, compiling the R1CS IOP with our polynomial commitments of Section~\ref{sec:protocol} is less practical than compiling the \textsf{Sonic} IOP. While the R1CS polynomial IOP has only $15$ univariate queries (compared to \pro{Sonic}'s $27$ queries to polynomials of approximately the same degree), the $3$ bivariate polynomial oracles take quadratic time to preprocess and open. Unfortunately, our polynomial commitment scheme does not take advantage of the sparsity of these bivariate polynomials. Furthermore, ignoring prover time complexity, the size of the bivariate $\eval$ proofs are twice as large as univariate $\eval$ proofs so the number of queries is effectively equivalent to $21$ univariate degree $n$ queries. 




