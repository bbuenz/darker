
All existing SNARK constructions can be viewed conceptually as consisting of an underlying information-theoretic statistically sound protocol that is then “cryptographically compiled” into one that achieves the desired efficiency properties (i.e. succinctness, non-interaction, etc) at the cost of \emph{computational soundness}. The information theoretic protocol is secure against unbounded provers whereas the compiled protocol is sound only against computationally bounded provers. In some cases zero-knowledge is also only achieved after compilation. This viewpoint has proved useful both as a modular method for constructing new proof systems as well as an analytical tool for classifying existing ones. 

\paragraph{CS proofs} The earliest construction of a succinct non-interactive argument system for NP, Micali’s ``CS proofs” \cite{Micali}, used random oracles and Merkle tree commitments to cryptographically compile classical PCPs via the Fiat-Shamir heuristic. In a PCP there is a verifier who has oracle access to a proof string and thus may query $q$ locations of the string in time O(q). The celebrated PCP theorem \cite{AS98, ALM+98} showed that any NP statement has a corresponding proof string of polynomial size, which the verifier only needs to check in O(1) locations in order to verify the statement with statistical soundness. In a CS proof, the first step is to build an interactive public-coin proof with succinct communication as first proposed by Kilian ~\cite{Kilian} where the prover sends the verifier a Merkle tree commitment to the PCP string, receives the verifier’s public coin queries, and provides Merkle proofs to authenticate its answers to these queries. The second step is to make this non-interactive via Fiat-Shamir. However, this construction was purely theoretical due to the concrete inefficiency of classical PCPs. 

\paragraph{Short vs linear PCPs} These classical PCPs of polynomial length are called ``short PCPs''. Ishai, Kushilevitz, and Ostrovsky [IKO07] gave the first communication efficient interactive argument that did not rely on commitments to short PCPs. The underlying information theoretic object in this construction is a \emph{linear} PCP, which is an oracle computing a linear function $\proofO: \mathbb{F}^m \rightarrow \mathbb{F}$, i.e. the answer to each query $\mathbf{q} \in \mathbb{F}^m$ is the inner product $\langle \proofO, \mathbf{q} \rangle$. Their four-move succinct interactive argument uses linear homomorphic encryption to compile the linear PCP. The verification time in this construction is still linear and the prover time is quadratic due to the particular linear PCP instantiation based on Hadamard codes [ALM+98]. Gennaro, Gentry, Parno, and Raykova [GGPR] were the first to present a concretely practical SNARK that reduced the prover time to O(n log n) based on a more efficient instantiation of the linear PCP oracle, namely an encoding of the computation as a quadratic arithmetic program (QAP). The GGPR protocol (and followup improvements such as Pinocchio~\cite{Pinocchio}) were not initially described through the lease of linear PCPs, but were later adapted to this framework by Bitansky et. al. and Setty et. al. Bitansky et. al. generalized this construction, showing how any linear PCP of a particular kind (QAPs being one example) could be combined with linear-only encryption to get a SNARK with sublinear verification time and linear time preprocessing. The preprocessing step in these constructions requires a trusted secret setup. 

\paragraph{Linear IOPs} Another line of work … GKR based …. Can be viewed as linear IOP [IshaiCorrigan19]… In fact, linear IOPs capture all existing SNARK constructions, as they generalize both linear PCPs and short PCPs. Discuss STARK, Aurora, how it can be viewed as starting with a linear IOP where each proof oracle is a polynomial function and then turns it into a classical IOP by replacing each proof oracle with the evaluation of the polynomial at a linear number of points. This is so that they can apply weaker cryptographic compilers that don't require trusted setup (Merkle trees), but this underlying linear IOP could be compiled directly given a more advanced cryptographic compilation tool. 

\paragraph{Our results} Present our polynomial commitment and inner product argument as cryptographic compilation techniques applied to linear IOPs. Introduce terminology of algebraic linear IOPs, where queries are derived by applying bounded-degree polynomials to verifier’s coins. Subclass of algebraic linear IOPs is polynomial IOPs, where each oracle encodes a polynomial function of bounded degree and linear queries are all evaluations of the polynomial at a point. One way to see the connection to algebraic linear IOP is that each component of the query is derived via a bounded-degree monomial. 
Explain a new view of QAP as one round linear IOP instead of linear PCP and how this yields a QAP-based SNARK without trusted setup. Provide general theorem for compiling linear IOPs of two kinds: algebraic linear IOPs (theorem generalizes QAP construction), polynomial IOPs. In each give complexity of resulting preprocessing SNARK as a function of various parameters in the underlying linear IOP (number of rounds, etc). 

\subsection{Algebraic Linear IOPs} 

In this section we define \emph{algebraic linear IOPs}. Recall that in a linear PCP the verifier sends query vectors $\mathbf{q} \in \mathbb{F}^m$ and receives a response $\langle \proofO, \mathbf{q} \rangle$. Bitansky et. al. \cite{Bitansky} defined a linear PCP to be \emph{algebraic} if each query vector is computed from the verifier's random coins by an arithmetic circuit of low (i.e. $poly(\lambda)$) degree. More precisely, in an algebraic degree $d$ PCP there is a query function $Q: \mathbb{F}^\mu \rightarrow \mathbb{F}^m$ such that each verifier query is of the form $\mathbf{q} \leftarrow Q(\mathbf{r})$, where $\mathbf{r}$ is uniformly sampled from $\mathbb{F}^\mu$, and the function $Q$ is computable by a vector of $\mu$-variate polynomials of degree at most $d$. 

A subclass of algebraic linear PCPs are \emph{polynomial PCPs}. A $\mu$-variate degree $d$ polynomial PCP oracle encodes a $\mu$-variate polynomial function of degree $d$, and queries to the oracle are evaluations of the polynomial. If the proof oracle is represented by the coefficient vector in $\proofO \in \mathbb{F}^{d^\mu}$ then its evaluation on a point in $\mathbb{F}^\mu$ can be viewed as a linear query $\mathbf{q} \in \mathbb{F}^{d^\mu}$ with each component computed by a $\mu$-variate monomial of degree at most $d$. 

Interactive Oracle Proofs (IOPs) \cite{BCS16, RRR16} combine IPs and PCPs: in each round of an IOP the verifier sends a message $m_i$ to the prover and the prover responds with a polynomial length proof oracle $\boldsymbol{\pi_i}$, which the verifier can query via random access. The verifier can continue to query this oracle in future rounds. In other words, each $\boldsymbol{\pi_i}$ is a PCP. Boneh et. al. \cite{IshaiCorrigan} introduced linear IOPs as the IOP extension of linear PCPs, where in each round the prover's message is a linear PCP oracle. We define algebraic linear IOPs analogously to algebraic linear PCPs. To keep the syntax simple, we will only the present the definition for the case of public-coin linear IOPs. Our results will only make use of public-coin IOPs. 

\begin{definition} [Public-coin linear IOP]
\label{def:linearIOP}
Let $\mathcal{R}$ be a binary relation and $\mathbb{F}$ a finite field. A $t$-round $\ell$-query public-coin linear IOP for $\mathcal{R}$ over $\mathbb{F}$ with soundness error $\epsilon$ and knowledge error $\delta$ and query length $\mathbf{m} = (m_1,...,m_t)$ satisfies the following requirements: 

\begin{itemize} 
\item \underline{Protocol syntax}. There is a prover algorithm $P$, a query algorithm $Q$, and a verification algorithm $V$. For each $i$th round there is a prover state $\textsf{st}^P_i$ and a verifier state $\textsf{st}^V_i$. For any common input $x$ and $\mathcal{R}$ witness $w$, at round 0 the states are $\textsf{st}^P_0 = (x, w)$ and $\textsf{st}^V_0 = x$. 
In the $i$th round (starting at $i = 1$) the prover outputs $\proofO_i \leftarrow P(\textsf{st}^P_{i-1})$ in $\mathbb{F}^{m_i}$ and the verifier outputs a uniformly sampled $\mathbf{r}_i \leftarrow_R \mathbb{F}^{\mu_i}$. 
This determines a query matrix $\mathbf{Q}_i \leftarrow Q(\textsf{st}^V_{i-1}, \mathbf{r}_i)$ consisting of $\ell$ column vectors in $\mathbb{F}^{m_i}$, and the verifier obtains the linear oracle response $\mathbf{a}_i \leftarrow \proofO_i^\top \mathbf{Q}_i$. The updated prover state is $\textsf{st}^P_i \leftarrow (\textsf{st}^P_{i-1}, \mathbf{r}_i)$ and verifier state is $\textsf{st}^V_i \leftarrow (\textsf{st}^P_{i-1}, \mathbf{r}_i, \mathbf{a}_i)$. Finally, $V(\textsf{st}^V_t)$ returns $\textsf{Accept}$ or $\textsf{Reject}$.

\item \underline{Completeness}. For every $(x, w) \in \mathcal{R}$, following the protocol syntax above $V(\textsf{st}^V_t)$ returns $\textsf{Accept}$ with probability 1. 

\item \underline{Soundness}. If $(x, w) \notin \mathcal{R}$ for every $w$, then for every prover algorithm $P^*$ that outputs a linear function oracle $\proofO^*_i: \mathbb{F}^{m_i} \rightarrow \mathbb{F}$ in the $i$th round of the protocol initialized on $x$, the probability $V(\textsf{st}^V_t)$ returns $\textsf{Accept}$ is less than $\epsilon$. 

\item \underline{Knowledge}. There exists a PPT knowledge extractor $\mathcal{E}$ such that for any prover algorithm $P^*$ and every $x$, if $V(\textsf{st}^V_t)$ outputs \textsf{Accept} in its interaction with $P^*$ on input $x$ with probability greater than $\delta$ then $\mathcal{E}^{P^*}(x)$ outputs $w$ such that $(x, w) \in \mathcal{R}$ in expected polynomial time. $\mathcal{E}^{P^*}(x)$ receives the input $x$ and interacts with $P^*$ via rewinding, sending partial transcripts and receiving $P^*$'s next output. (Although the verifier only accesses $P^*$'s output by querying a linear function oracle, $E$ reads the whole output). 

\end{itemize}

Furthermore, the linear IOP has \textbf{degree} $d$ if for each $i \in [t]$ and $\textsf{st}^V_{i-1}$ there are $\ell$ $\mu_i$-variate degree-$d$ polynomial functions $p_1,...,p_\ell: \mathbb{F}^{\mu_i} \rightarrow \mathbb{F}^{m_i}$ such that $Q(\textsf{st}^V_{i-1}, \mathbf{r}_i) = p_i(\mathbf{r}_i)$. The IOP is \textbf{algebraic} for a parameter $\lambda$ if $d = poly(\lambda)$. 
It is \textbf{input-oblivious} if $x$ is not included in the state passed to $Q$, and is \textbf{stateless} if the only input to $Q$ in each round is the round index $i$ and $\mathbf{r}_i$.
Finally, \textbf{polynomial IOPs} are a subclass of algebraic linear IOPs: in a $(\mu, d)$ polynomial IOP each proof oracle is a $\mu$-variate degree-$d$ polynomial and queries are evaluations of the polynomial at points in $\mathbb{F}^\mu$. In a polynomial IOP we also allow index queries to each PCP oracle, viewed as a vector of coefficients (i.e. equivalent to traditional unstructured PCP queries). Index queries are the most basic kind of linear query: an inner product with a standard basis vector. 

\end{definition} 

\emph{Remark:} Connection between polynomial IOPs and point IOPs, RS encoding, STARKs etc. 

\begin{definition}[HVZK for public-coin IOPs]
Let $\textsf{View}_{\langle P(x, w), Q(x) \rangle}(V)$ denote the view of the verifier in the $t$-round $ell$-query interactive protocol described in Definition~\ref{def:linearIOP} on inputs $(x,w)$ with prover algorithm $P$ and query algorithm $Q$, consisting of all public-coin challenges and oracle outputs (i.e. equivalent to the final state $\textsf{st}^V_t$). The interactive protocol has $\delta$-statistical honest verifier zero-knowledge if there exists a probabilistic polynomial time algorithm $S$ such that for every $(x, w) \in \mathcal{R}$, the distribution $S(x)$ is $\delta$-close to $\textsf{View}_{\langle P(x, w), Q(x) \rangle}(V)$ (as distributions over the randomness of $P$ and random public-coin challenges).
\end{definition}

\subsection{Compiling linear IOPs} 
We are now ready to present our main theorems. We formulate two separate theorems: the first pertains only to compiling polynomial IOPs, and the second deals with more general stateless input-oblivious algebraic IOPs. The first result is more practical because it yields interactive arguments with quasi-linear prover time. In fact, there is a concrete instantiation of the polynomial IOP (used in Sonic~\cite{Sonic}) that results in an interactive argument with both quasi-linear prover time and logarithmic communication/verification. The second result is less practical because it only guarantees polynomial prover time, but includes a much broader spectrum of concrete instantiations, including QAP-based IOPs. The prover time in a QAP-based instantiation is quadratic. These instantiations are discussed in more detail in Section~\ref{sec:instantiations}. \\

\noindent \emph{Remark on $(\mu, d)$}: For simplicity, in our general theorems statements we consider $(\mu, d)$ polynomial IOPs where every polynomial PCP oracle is a $\mu$-variate degree $d$ polynomial. This is without loss of generality because $(\mu, d)$ can be viewed as an upper bound on the variables and degree. Of course, when a polynomial IOP involves a combination of oracles with different $\mu$ and $d$, the cryptographic compiler may indeed gain efficiency by taking advantage of this. We could formulate a more fine-grained theorem for $\{\mu_i, d_i\}$ polynomial IOPs where the $i$th round PCP is a $\mu_i$-variate degree $d_i$ polynomial. 
We similarly use a fixed $(\mu, d)$ upper bound on the variables/degree of the query generation polynomials in our theorem concerned with compiling algebraic linear 
IOPs. In Section~\ref{sec:instantiations} we discuss optimizations for concrete instantiations. 

\subsubsection*{Compilation I: Polynomial IOPs} 
Let $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open}, \pro{Eval})$ be a $\mu$-variate polynomial commitment scheme. Given any $t$-round $(\mu, d)$-polynomial IOP for $\mathcal{R}$ over $\mathbb{F}$, construct an interactive protocol as follows: 
\begin{itemize}
\item Run $\params \leftarrow \pro{Setup}(1^\lambda)$
\item Replace each $(\mu, d)$ polynomial proof oracle $\proofO: \mathbb{F}^\mu \rightarrow \mathbb{F}$ with a commitment $c_{\proofO} \leftarrow \pro{Commit}(\params; \proofO)$ 
\item Replace each verifier \emph{evaluation} query $\mathbf{r}$ to proof oracle $\proofO$ with a interactive execution of $\pro{Eval}(\params, c_\pi, \mathbf{z}, y, \mu, d; \proofO)$, where $\proofO(\mathbf{z}) = y$. Replace each index query to the $i$th $\mathbb{F}$-vector component of $\proofO$ with an execution of $\pro{OpenIndex}(\params, c_\pi, i, \pi_i, \mu, d; \proofO)$ where the $i$th coefficient of $\proofO$ is $\pi_i$. 
\end{itemize}

If the verifier does not abort in any of these subprotocols, then it receives a simulated IOP transcript of oracle query outputs. It runs the IOP verifier $V$ on this transcript and outputs the result. 

%We begin with a lemma on using polynomial commitments (that has witness-extended emulation) to compile a public-coin polynomial IOP with negligible knowledge error into a public-coin interactive argument with witness-extended emulation. 

\begin{lemma}
If the polynomial commitment scheme $\Gamma$ has witness-extended emulation and the $t$-round polynomial IOP for $\mathcal{R}$ has negligible knowledge error, then \emph{Compilation I} generates a public-coin interactive argument for $\mathcal{R}$ that has witness-extended emulation. 
\end{lemma}

\begin{proof}[Proof Sketch]

The proof consists of the following steps in bullet format. (This should probably be turned into a series of subclaims).  

\begin{itemize}

\item Without loss of generality, assume IOP makes at least one query to each oracle sent in a given round (i.e. the queries derived from the verifier's random challenge in this round contain at least one per proof oracle). Otherwise, we can modify the IOP to query at an arbitrary point. (The compiled IOP therefore makes at least one query to every polynomial commitment sent to verifier). 
 
\item Given a record oracle $\pro{Record}(P^*, \params, x, \st)$ that produces accepting transcripts with non-negligible probability, the emulator $E$ construct an IOP adversary $P'$ which succeeds also with non-negligible probability on input $x$. Moreover, every successful interaction of $P'$ with the IOP verifier on input $x$ corresponds to a successful transcript of $P^*$ with $V$ on $x$. In showing how $E$ builds $P'$ we also show how $E$ can obtain this corresponding transcript. We will describe how this is done in the later parts of the proof. Accepting that this is true, $E$ can use the IOP knowledge extractor $E_{\pro{IOP}}^{P'}(x)$ in order to output a witness for $x$ along with the corresponding transcript. 

\item The emulator also can run the polynomial commitment evaluation emulator $E_\eval$ for the commitment scheme $\Gamma$. 

\item  \textbf{The IOP prover $\mathbf{P'}$}. We use the descriptive term ``IOP verifier" to distinguish it from the IP verifier $V$, and let $V_{\pro{IOP}}$ denote the IOP verification (decision) algorithm applied to the final IOP transcript. 

$P'$ runs as follows on initial state $\st_0$ and input $x$. In ``its head", it simulates the interaction of $P^*$ and $V$, using the record oracle $\pro{Record}(P^*, \params, x, \st)$. It begins by running this for the first round on state $\st_0$. We already made the assumption that for every message $m$ that $P^*$ sends in this first round, $V$'s random challenge triggers at least one $\eval$ on $m$ (interpreted as a polynomial commitment). Therefore, the record oracle can be used to simulate $E_\eval$'s record oracle for each $m$ evaluated at some point determined by $V$'s challenge.

For each message $m$ that $P^*$ sends to $V$ at the beginning of the first round, $P'$ attempts to extract a polynomial from $m$ by 
running the PPT emulator $E_\eval$, simulating its record oracle as just described. \textbf{If it fails in any extraction it aborts.} 

If $P'$ succeeds in all these extractions, then it uses these extracted polynomials as its first round proof oracles that it gives to the IOP verifier. Upon receiving the first public-coin challenge from the IOP verifier, $P'$ uses the query function to derive the corresponding queries to each of these proof oracles. Before answering, it rewinds $P^*$ and $V$ to the point immediately after $P$ sent its ``commitment" messages, and now substitutes the IOP verifier random challenge in order to simulate $P^*$ and $V$ on the same queries. It checks that $P^*$'s answers are consistent with the answers it can compute on its own from the extracted polynomials. \textbf{If any answers are inconsistent, $P'$ aborts}. Otherwise, it sends the answers to the IOP verifier. 

At the end of this first round (assuming $P'$ has not yet aborted), $P'$ has stored an updated state $\st'$ for $P^*$ based on this simulation. It proceeds to the next round and repeats the same process, using the record oracle $\pro{Record}(P^*, \params, x, \st')$. Finally, if $P'$ makes it through all rounds without aborting, then it has a final state $\st_V$ for $V$ based on its internal simulation of $P^*$ and $V$ up through the end of the last round. The IOP verifier runs the IOP decision algorithm $V_{\pro{IOP}}$, which outputs $\pro{Accept}$ if and only if $V$ outputs $1$ on $\st_V$. (This is due to the fact that the verifier in the compiled IOP runs the same final decision algorithm as the IOP verifier). 

\item We will now analyze the probability that $P'$ is successful. In particular, we claim that if $\pro{Record}(P^*, \params, x, \st_0)$ outputs an accepting transcript $\tr$ with non-negligible probability, then $P'$ succeeds with non-negligible probability. First, observe that for any accepting $\tr$ between $P^*$ and $V$, if $P'$ happens to follow the same exact sequence of query/responses without ever aborting then it succeeds because the IOP verifier and $V$ have the same final decision algorithm. Thus, it remains to take a closer look at what events cause $P'$ to abort, and bound the fraction of accepting $\tr$ for which this occurs. 

As indicated in bold above, there are two kinds of events that cause $P'$ to abort: 
\begin{itemize}
\item It fails to extract from a ``commitment" message $m$ sent by $P^*$
\item After successfully extracting a polynomial $f$ from a commitment, $P^*$ answer queries to $f$ in a way that is inconsistent with $f$. 
\end{itemize}

The second type of event contradicts the evaluation binding property of $\Gamma$, therefore it occurs with negligible probability. To analyze the first type of event, let us define ``bad commitments" for a parameter $B$: a message $m$ in state $\st$ sent by $P^*$ at a particular point in $\tr$ is a ``bad commitment", denoted $\pro{Bad}(m, \st) = 1$ for short, if there is less than a $1/B$ probability (over the randomness of the public-coins) that $\pro{Record}(P^*, \params, x, \st)$ contains a successful execution of $\eval$ on $m$ on the queries defined by $\st$ and the next public coin challenge, where $\st$ is determined by running $\tr$ up until the point $m$ appears. 

The conditional probability that a transcript $\tr$ is accepting given that it contains a ``bad commitment" is less than $1/B$. To see this, fix $(m, \st)$ with $\pro{Bad}(m, \st) = 1$ and consider ``sampling" a random $\tr$ that contains $m$ at state $\st$. This is done by first choosing randomly from all partial transcripts that result in $(m, \st)$ via brute force, and then running the transcript normally from state $\st$ on random public-coins. The probability the latter part results in an accepting transcript is less than $1/B$ by definition.

Flipping this around with Bayes' law, letting $A(\tr)$ denote the event that $\tr$ is accepting and $P(A(\tr)) > 1/\poly$ the a-priori probability of this event, the probability that $\tr$ contains ``bad commmitments" conditioned on $A(\tr)$ is less than $\frac{1}{B P(A(\tr))} < \poly/B$. In other words, for at least a $1 - \poly/B$ fraction of accepting transcripts, for every message $m$ contained therein, $P'$s simulation of $\eval$ succeeds with probability greater than $1/B$. Setting $B = 2 \poly(\lambda)$, we see than on $1/2$ of acceting transcripts $P$'s simulation succeeds with non-negligible probability. Finally, we can invoke the witness-emulation property of $\eval$ to say that the PPT $E_\Gamma$ emulator extracts a witness from each $m$ with overwhelming probability on $1/2$ of accepting transcripts. 

In conclusion, there is a non-negligible fraction transcripts that are both accepted by $V$ and for which $P'$ never aborts (when following the same sequence of queries/responses), hence $P'$ succeeds with non-negligble probability in its interaction with the IOP verifier. 

\end{itemize}
\end{proof}


\subsubsection*{Compilation II: Algebraic Linear IOPs} 

Let $\Gamma = (\pro{Setup}, \pro{Commit}, \pro{Open}, \pro{Eval}, \pro{InnerProd})$ be a $\mu+1$-variate polynomial commitment scheme with an inner product argument.\footnote{Note, the commitment scheme might have a ``left" and ``right" commitment mode in order to support $\pro{InnerProd}$, where the inner product argument can only be applied to a left commitment paired with a right commitment.} Given any $t$-round $\ell$-query stateless input-oblivious $\mu$-variate degree-$d$ algebraic linear IOP for $\mathcal{R}$ with query length $\mathbf{m} = (m_1,...,m_t)$, construct an interactive protocol as follows: 

\begin{itemize}

\item \underline{Setup}: Run $\params \leftarrow \pro{Setup}(1^\lambda)$

\item \underline{Preprocessing}: For each $i$th round there are $\ell$ query generation functions $P_1,...,P_\ell: \mathbb{F}^\mu \rightarrow \mathbb{F}^{m_i}$, where the $j$th component of $P_k(\mathbf{r}_i)$ is a $\mu$-variate degree $d$ polynomial function $p_{k,j}(\mathbf{r}_i)$, the preprocessor uses $\Gamma$ to generate a commitment $c_{P_k}$ to $(p_{k,1},..., p_{k,m_i})$ as follows:
 
    \begin{itemize}
    \item Encode $(p_{k,1},...,p_{k, m_i})$ as a polynomial in $\mu + 1$ variables. Let $\mathbf{X} = (X_1,...,X_\mu)$ and $Z$ denote the $(\mu+1)$'st indeterminate, then define $\tilde{P}_k(\mathbf{X}, Z) := \sum_{j=1}^{m_i} p_{k,j}(\mathbf{X}) Z^j$.
    
    \item For each $k \in [\ell]$, compute the commitment $c_{P_k} \leftarrow \pro{Commit}(\params, \tilde{P}_k, \mu + 1)$. (If $\Gamma$ has left/right modes to support inner product then compute this as a ``right" mode commitment). 
    \end{itemize}
    
\item Replace each $i$th round proof oracle $\proofO_i$ with $c_{\proofO_i} \leftarrow \pro{Commit}(\params, \proofO_i)$ where the vector $\proofO_i$ is interpreted as the coefficient vector of a univariate polynomial. (If $\Gamma$ has left/right modes, commit to the proof oracle in ``left" mode). 

\item Replace each $i$th round verifier query matrix $\mathbf{Q}_i \in \mathbb{F}^{m_i \times \ell}$ consisting of column query vectors $(\mathbf{q}_1,...,\mathbf{q}_\ell)$ with the following interactive subprotocol for each $k \in [\ell]$: 

\begin{itemize}
 \item Prover sends a univariate polynomial commitment $c_{\mathbf{q}_k}$ to $\mathbf{q}_k$, interpreted as coefficient vector of a univariate polynomial. (In $\Gamma$ with modes it commits in ``right" mode). 
 \item Verifier samples uniform random $\beta \leftarrow_R\mathbb{F}$. 
 \item Prover evaluates $y_1 \leftarrow \mathbf{q}_k(\beta)$ and $y_2 \leftarrow \tilde{P}_k(\mathbf{r}_i, \beta)$ and sends these to the verifier. The verifier aborts if $y_1 \neq y_2$ and returns 0. 
 \item Assume at this point $y = y_1 = y_2$. The prover and verifier run $\eval(\params, c_{\mathbf{q}_k}, \beta, y, m_i; \mathbf{q}_k)$ and $\eval(\params, c_{P_k}, (\mathbf{r}, \beta), y, d; \tilde{P}_k)$. If the verifier returns 0 in either subprotocol, the verifier aborts and outputs 0. 
 \item The prover computes $a_{i,k} = \langle \proofO_i, \mathbf{q}_k \rangle$ and sends $a_{i,k}$ to the verifier. The prover and verifier run $\pro{InnerProduct}(c_{\proofO_i}, c_{\mathbf{q}_k}, a_{i,k}, m_i; \proofO_i, \mathbf{q}_k)$. If the verifier returns 0 in this subprotocol it aborts and outputs 0.
 \end{itemize} 
 
If all substeps succeed the the verifier obtains the vector $\mathbf{a}_i = (a_{i,1},....,a_{i, \ell})$ for each $i$th IOP round. If this succeeds for each round, then the verifier runs the IOP verification algorithm $V$ on this transcript and outputs the result.

\end{itemize}






