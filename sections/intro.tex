
Since the landmark discoveries of \emph{interactive proofs} (IPs)~\cite{STOC:GolMicRac85} and %the ``PCP theorem" on 
\emph{probabilistically checkable proofs} (PCPs)~\cite{STOC:BFLS91,FOCS:ALMSS92} in the 90s, there has been tremendous development in the area of proof systems whereby a prover establishes the correct performance of an arbitrary computation in a way that can be verified much more efficiently than performing the computation itself. Such proof systems are \emph{succinct} if they also have a low communication cost between the prover and the verifier, \emph{i.e.}, the transcript of the protocol is much smaller than a witness to the computation. There are also \emph{zero knowledge} variants of these efficient proof systems, beginning with ZK-IPs~\cite{C:BGGHKMR88} and ZK-PCPs~\cite{STOC:Kilian92}, in which the computation may involve secret information and the prover demonstrates correct performance without leaking the secrets. As a toy example, one could prove that a chess position is winning for white without actually revealing the winning moves themselves. General purpose zero-knowledge proofs~\cite{JACM:GMW91} can be very expensive in terms of proof size and verification time even for computations that would be easy to perform given the secret inputs (\emph{e.g.}, by proving that one decrypted a file properly without leaking the key or the plaintext). The same techniques that are used to build efficient proof systems for expensive computations are also useful for making zero-knowledge proofs more practical. 
%A more practical example  
 
In recent years, there has been a surge of industry interest in verifiable outsourced computation~\cite{WalBlu15} (such as trustless cloud computing) as well as zero-knowledge proofs. In particular, blockchains use efficient zero-knowledge proofs as a solution for balancing privacy and publicly-verifiable integrity: examples include anonymous transactions in ZCash~\cite{SP:BCGGMT14,Zcash, ZcashProtocol} and verifying Ethereum smart contracts over private inputs~\cite{Zokrates}. In these applications, zero-knowledge proofs are posted to the blockchain ledger as a part of transactions and nodes must verify many proofs in the span of a short period of time. Therefore, succinctness and fast verification are necessary properties for the deployment of such proof systems. Verifiable computation is also being explored as a scaling solution for blockhain transactions~\cite{ZK-rollup}, and even as a way to entirely eliminate the need for maintaining historical blockchain data~\cite{Coda}. 
%In recent years, there has been a surge of industry interest in applying proof systems to outsourced verifiable computation~\cite{Sources}. These proof systems are particularly relevant to blockchains, which use efficient zero-knowledge proofs as a solution for balancing privacy and publicly-verifiable integrity: examples include anonymous transaction in ZCash~\cite{SP:BCGGMT14,Zcash}, and verifying Ethereum smart contracts over private inputs~\cite{ZKContracts}. Verifiable computation is also used as a way to synchronize more efficiently with the current state of a blockchain~\cite{Rollup}, or even entirely eliminate the need for maintaining historical blockchain data~\cite{Coda}. 

Following this pragmatic interest, there has also been a surge of research focused on obtaining proof systems with better concrete efficiency characteristics: \emph{succinctness} (the proof size is sublinear in the original computation length $T$), \emph{non-interactivity} (the proof is a single message), \emph{prover-scalability} (proof generation time scales linearly or quasi-linearly in $T$), and \emph{verifier-scalability} (verification time is sublinear in $T$). Proof systems that achieve all of these properties for general NP statements %\footnote{NP statements can be verified deterministically in polynomial time given a suitable \emph{witness}. More formally, a language $L \subseteq \{0,1\}^*$ is in $NP$ if there is a non-determinstic polynomial time decision algorithm $V_L$ for $L$: for every $x \in \{0,1\}^*$ there exists a witness $w$ such that $V_L(x, w) = 1$ iff $x \in L$. If $C$ is a circuit, the statement that $C(x) = y$ can be expressed as an NP statement $(C, x, y)$ with a witness $w$ that assigns correct values to all the internal wires of $C$ producing the output $y$ on input $x$.}
are called SNARGs (``succinct non-interactive arguments''). 
The proof is called an \emph{argument} when it is only sound assuming the prover is computationally bounded, \emph{i.e.}, \emph{computationally sound} as opposed to statistically sound. 
Succinct statistically sound proofs are unlikely to exist~\cite{CC:GolVadWig02,ICALP:Wee05}.

Currently, there are numerous constructions that achieve different tradeoffs between proof size, proof time, and verification time, but also under different \emph{trust} models as well as cryptographic assumptions. %There is a distinction between \emph{proofs} and \emph{arguments}, the latter offering soundness only against a computationally bounded prover. 
Some constructions also achieve better efficiency by relying on a \emph{preprocessing model} in which a one-time expensive setup procedure is performed in order to generate a compact verification key \pro{VK}, which is later used to verify proof instances efficiently.
%More precisely, a fresh \pro{VK} must be generated for each computation that will be proven, e.g. represented as an arithmetic circuit $C$ that takes inputs $x \in \ZZ^n$ over a prime field $\ZZ$. Thereafter, succinct proofs may be generated for the evaluation of $C$ on arbitrary inputs $x$ and verified efficiently with \pro{VK}. 
Somewhat unfortunately, the best performing proof systems to date (considering proof size and verification time) require a \emph{trusted} preprocessing. These are the pairing-based SNARKs extending from GGPR~\cite{EC:GGPR13,ES:SBVBPW13,TCC:BCIOP13,C:BCGTV13,EC:Groth16}, which have been implemented in numerous libraries~\cite{C:BCGTV13,bellman}, and even deployed in live systems such as the ZCash~\cite{Zcash} cryptocurrency.
%The preprocessing involves secret information that must be discarded, else it provides the prover with a trapdoor that breaks the integrity of the proof system. 
The trusted setup can be performed via \emph{multi-party computation} (MPC) by a committee of parties, such that trust in only one of the parties is sufficient. This has been done on two occasions for the ZCash blockchain, involving elaborate ``ceremonies" to engender public trust in the process~\cite{ZcashCeremony}. 

A proof system is called \emph{transparent} if it does not involve any trusted setup. Recent progress has yielded transparent proof systems for special types of computations: zk-\textsf{STARK}s~\cite{C:BBHR19} generate zero-knowledge proofs of size $O(\log^2 T)$ for a uniform computation\footnote{A uniform computation is expressed as a RAM program $P$ and a time bound $T$ on the running time of the program. A uniform computation depends on the size of $P$'s description but not on the time bound $T$.}, and the GKR protocol produces interactive proofs with communication $O(d \log T)$ for computations expressed as low-depth circuits of total size $T$ and depth $d$~\cite{STOC:GolKalRot08}. In both cases, non-interactivity can be achieved in the random oracle model with the Fiat-Shamir heuristic~\cite{C:FiaSha86,STOC:CCHLRRW19}.
These transparent proof systems perform significantly worse than SNARKs based on preprocessing. For computations expressed as an arithmetic circuit of $1$-million gates, \textsf{STARK}s~\cite{C:BBHR19} report a proof size of $600$KB, whereas preprocessing SNARKs achieve $200$ bytes~\cite{EC:Groth16}. Bulletproofs~\cite{SP:BBBPWM18, EPRINT:BCCGP16} is a transparent zero-knowledge proof system whose proofs are much smaller than those of \textsf{STARK}, but these proofs have a verification time that scales linearly in the size of the circuit; for an arithmetic circuit of one million gates the verification time is close to 1 minute, more than 1,000 times more expensive than verifying a \textsf{STARK} proof for the same computation. 
% The original GKR protocol was not zero-knowledge, but there are more recent zero-knowledge variants that have communication $O( \sqrt{n} + d \log T)$ where $n$ is the size of the (secret) input~\cite{SP:WTSTW18,EPRINT:ZGKPP17b}. 


Another thread of research has produced proof systems that remove trust from the circuit preprocessing step, and instead have a \emph{universal} (trusted) setup: a one-time trusted setup that can be reused for \emph{any} computation~\cite{Sonic,Libra,Plonk}. All of these systems build SNARKs by combining an underlying reduction of circuit satisfiability to probabilistic testing of polynomials (with degree at most linear in the circuit size) together with \emph{polynomial commitment schemes}. In a polynomial commitment scheme, a prover commits to a $\mu$-variate polynomial $f$ over $\FF$ of total degree at most $d$ with a message that is much smaller than sending all the coefficients of $f$. The prover can later produce a non-interactive argument that $f(z) = y$ for arbitrary $z \in \FF^\mu$ and $y \in \FF$. %It should be infeasible for the prover to claim $f(z) = y'$ and $f(z) = y$ for $y \neq y'$. Universal SNARK constructions also require this evaluation protocol to itself be a knowledge argument, \emph{i.e.}, a successful prover must know the coefficients of the committed polynomial. 
The trusted portion of the universal SNARK is entirely confined to the polynomial commitment scheme's setup. These constructions use variants of the Kate~\emph{et al.} commitment scheme for univariate polynomials~\cite{AC:KatZavGol10}, which requires a trusted setup.% trusted party to generate a length $d$ vector of group elements of the form $g^{s^i}$ for a secret point $s \in \FF$. 

%According to a concrete comparison~\cite{Libra} of proof systems' performance (prior to the present work) on a computation that derives the root of a SHA-256 Merkle tree with 256 leaves\footnote{This computation involves 511 calls to SHA-256.}, STARKs are the only transparent non-interactive proof system capable of producing a proof (in a practical\footnote{The STARK computation cited here takes about 30 minutes to generate.}  amount of time) that can be verified in under 9 seconds, and yet the proof size is nearly 400 KB. 

\subsection{Summary of contributions} 
Following the observations of the recent universal SNARK constructions~\cite{Plonk,Sonic,Libra}, SNARKs can be built from polynomial commitment schemes where all the trust is confined to the setup of the commitment scheme. The main technical contribution of our work is thus a new polynomial commitment scheme without trusted setup (\emph{i.e.}, a transparent polynomial commitment scheme), which we can use to construct transparent SNARKs. The observation that transparent polynomial commitments imply transparent SNARKs was also implicit in the recent works that build transparent SNARKs from multi-round classical PCPs, and specifically interactive oracle proofs of proximity (IOPPs)~\cite{ICALP:BBHR18}. As a secondary contribution, we present a framework that unifies all existing approaches to constructing SNARKs from polynomial commitments using the language of \emph{interactive oracle proofs} (IOPs)~\cite{STOC:ReiRotRot16,TCC:BenChiSpo16}. We view polynomial commitment schemes as a compiler for \emph{Polynomial IOPs}, and re-characterize the results of prior works as providing a variety of Polynomial IOPs for NP. 

\paragraph{New polynomial commitment scheme} We construct a new polynomial commitment scheme for $\mu$-multivariate polynomials of total degree $d$ with optional zero-knowledge arguments of knowledge for correct evaluation that have $O(\mu \log d)$ size proofs and are verifiable in $O(\mu \log d)$ time. The commitment scheme requires a group of unknown order: two candidate instantiations are RSA groups and class groups of an imaginary quadratic order. Using RSA groups, we can apply the scheme to obtain universal preprocessing SNARKs with \emph{constant-size}  %\footnote{The security parameters are technically size $O(\lambda)$ where $\lambda$ is a security parameter.}
setup parameters, as opposed to the linear-size parameters from previous attempts. Using class groups, we can remove the trusted setup from trusted-setup SNARKs altogether, thereby making them \emph{transparent}. Our polynomial commitment scheme leverages the power of integer commitments and \emph{Diophantine Arguments of Knowledge}~\cite{AC:Lipmaa03a}; accordingly, we classify this tool (and others of its kind) as a \emph{DARK} proof system.
%obtain the first transparent SNARKs with $O(\log d)$ proof size and $O(\log d)$ verification time.

\paragraph{Polynomial IOP formalism} %As a secondary contribution, we present a framework that unifies all existing approaches to constructing SNARKs from polynomial commitments. This framework is based on interactive oracle proofs
All SNARK constructions can be viewed as combining an underlying information-theoretic statistically-sound protocol with a ``cryptographic compiler'' that transforms the underlying protocol into a succinct argument at the cost of computational soundness. 
We define a \emph{Polynomial IOP} as a refinement of algebraic linear IOPs~\cite{CC:IKO07,TCC:BCIOP13,C:BBCGI19}, where in each round of interaction the prover provides the verifier with oracle access to a multivariate polynomial function of bounded degree. The verifier may then query this oracle to evaluate the polynomial on arbitrary points of its choice. The existing universal and transparent SNARK constructions provide a variety of statistically-sound Polynomial IOPs for circuit satisfiability (or RAM programs, in the case of \textsf{STARK}s); these are then cryptographically compiled using some form of a polynomial commitment, typically using Merkle trees or pairing groups.

The linear PCPs underlying GGPR and its successors (\emph{i.e.}, based on QAPs and R1CS) can also be transformed into Polynomial IOPs.\footnote{This observation was also implicit in the paper by Ben-Sasson \emph{et al.} introducing the system \pro{Aurora}~\cite{EC:BCRSVW19}.} This transformation helps highlight the fundamental paradigm shift between constructions of non-transparent non-universal SNARKs that combine linear PCPs and \emph{linear-only encodings} versus the more recent ones based on polynomial commitments: given the lack of efficient\footnote{Lai and Malavota~\cite{C:LaiMal19} provide a $n$-dimensional \emph{linear-map} commitment based on bilinear pairings, extending techniques in functional commitments~\cite{ICALP:LibRamYun16}, but verifying claimed evaluations of the committed function on query points takes $O(n)$.} \emph{linear function} commitment schemes, the compilation of linear PCPs \emph{necessarily} involves a trusted preprocessing step that preselects the verifier's linear PCP queries, and hides them inside a linear-only encoding. This linear-only encoding forces the prover to homomorphically output an (encoded) linear tranformation of the query, upon which the verifer performs several homomorphic checks (\emph{e.g.}, using pairings).
The shift towards Polynomial IOPs, which can be compiled more directly with efficient polynomial commitments, avoids the involvement of a trusted party to place hidden queries in the preprocessing. The only potential need for non-transparent setup is in the instantiation of polynomial commitment itself.

The precise definition of Polynomial IOPs as a central and standalone notion raises the question about its exact relation to other IOP notions. We present a univariate Polynomial IOP for extracting an indicated coefficient of a polynomial. 
%This construction establishes that adding point queries to univariate Polynomial IOPs does not make them more powerful. 
Furthermore, we present a univariate Polynomial IOP for proving that the inner product between the coefficient vectors of two polynomials equals a given value. This proof system is of independent interest. Together with an offline pre-processing phase during which the correctness of a multivariate polynomial is ascertained, these two tools enable us to show that \emph{any} algebraic linear IOP can be realized with a multivariate Polynomial IOP. 



\paragraph{Polynomial IOP compiler} 
We present a generic compilation of any public-coin Polynomial IOP into a doubly-efficient public-coin interactive argument of knowledge using an abstract polynomial commitment scheme. We prove that if the commitment scheme's evaluation protocol has witness-extended emulation, then the compiled interactive argument has this knowledge property as well. If the commitment scheme is hiding and the evaluation is honest-verifier zero knowledge (HVZK), then the compiled interactive argument is HVZK as well. Finally, public-coin interactive arguments may be cryptographically compiled into SNARKs using the Fiat-Shamir heuristic.\footnote{Security for Fiat-Shamir has been proven secure in the random oracle model for constant-round protocols, for multi-round protocols satisfying \emph{soundness against restoration attacks}, and in some cases using correlation-intractable hash functions~\cite{C:FiaSha86,TCC:BenChiSpo16,C:KalRotRot17,EC:CCRR18,STOC:CCHLRRW19}.}
%\cite{C:FiaSha86,CCS:BelRog93,EC:PoiSte96,CSproofs,TCC:HalMyeRac08,TCC:BenChiSpo16,EC:AABN02,C:KalRotRot17,EC:CCRR18,FOCS:HolLom18,STOC:CCHLRRW19}.}

\paragraph{New SNARK without Trusted Setup}
The main practical outcome of this work is a new transparent proof system (\pro{Supersonic}) for computations represented as arbitrary arithmetic circuits, obtained by cryptographically compiling the Polynomial IOPs underlying \textsf{Sonic}~\cite{Sonic}, \textsf{PLONK}~\cite{Plonk}, and \textsf{Marlin}\cite{Marlin} using the DARK polynomial commitment scheme. \pro{Supersonic} improves the proof size by an order of magnitude over \textsf{STARK}s without compromising on verification time. For one million gates, \pro{Supersonic}'s proofs are just 7.8KB and take around 75ms to verify. Using the notation $O_\lambda(\cdot)$ to hide multiplicative factors dependent on the security parameter $\lambda$, \textsf{STARK}s have size and verification complexity $O_\lambda(\log^2 T)$ whereas \pro{Supersonic} has size and verification complexity $O_\lambda(\log T)$. (The additional multiplicative factors dependent on $\lambda$ are actually better for \pro{Supersonic} as well.) 
As a caveat, while the prover time in \pro{Supersonic} is asymptotically on par with \textsf{STARK}s (\emph{i.e.}, quasilinear in $T$), the concrete efficiency is much worse due to the use of heavy-weight ``crypto operations'' over 1200 bit class group elements in contrast to the light-weight FFTs and hash functions in \textsf{STARK}s. Furthermore, \pro{Supersonic} is not quantum-secure due to its reliance on groups of unknown order, whereas \textsf{STARK}s are a candidate quantum-secure SNARK. 

\subsection{Related Work}

\paragraph{Arguments based on hidden order groups} 
Fujisaki and Okamoto~\cite{C:FujOka97} proposed homomorphic integer commitment schemes based on the RSA group. They also provide protocols to prove that a list of committed integers satisfy modular polynomial equations as opening a commitment bit by bit. Damgård and Fujisaki~\cite{AC:DamFuj02} patched the soundness proof of that protocol and were the first to suggest using class groups of an imaginary quadratic order as a candidate group of unknown order. Lipmaa drew the link between zero-knowledge proofs constructed from integer commitment schemes and Diophantine complexity~\cite{AC:Lipmaa03a}, coining the term \emph{Diophantine Arguments of Knowledge}. Recently, Couteau~\emph{et al.} study protocols derived from integer commitments specifically in the RSA group to reduce the security assumptions needed; in the process they develop proofs for polynomial evaluation modulo a prime $\pi$ that is not initially known to the verifier, in addition to a proof showing that an integer $X$ lies in the range $[a,b]$ by showing that $1+4(X-a)(b-X)$ decomposes as the sum of 3 squares~\cite{EC:CouPetPoi17}.

Pietrzak~\cite{ITCS:Pietrzak18} developed an efficient proof of repeated squaring, \emph{i.e.}, proving that $x^{2^T} = y$ with $O(\log T)$ proof size and verification time in order to build a conceptually simple verifiable delay function~\cite{C:BBBF18} based on the RSW time-lock puzzle~\cite{RivShaWag96}. Wesolowski~\cite{EC:Wesolowski19} improves on this result by proposing a single-round protocol to prove correct repeated squaring in groups of unknown order with a constant size proof. Boneh~\emph{et al.}~\cite{C:BonBunFis19} observe that this protocol generalizes to arbitrary exponents (PoE) and develop a proof of knowledge of an integer exponent (PoKE), as well as a zero-knowledge variant. They use both PoE and PoKE to construct efficient accumulators and vector commitment schemes.

\paragraph{Transparent polynomial commitments} 
Whaby \emph{et al.} constructed a transparent polynomial commitment scheme~\cite{SP:WTSTW18} for multilinear polynomials by combining a matrix commitment of Bootle~\emph{et al.}~\cite{EC:BCCGP16} with the inner-product argument of B\"{u}nz~\emph{et al.}~\cite{SP:BBBPWM18}. For polynomials of degree $d$ it has commitments of size  $O(\sqrt{d})$ and evaluation arguments with $O(\sqrt{d})$ communication.
The  FRI (Fast Reed Solomon IOPP)~\cite{ICALP:BBHR18} and DEEP-FRI~\cite{ECCC:BGKS19} protocols are also implicitly a transparent polynomial commitment scheme that has $O(\lambda)$ size commitments and evaluation arguments with $O(\log^2 d)$ communication. This connection is described in a manuscript by Vlasov and Panarin~\cite{MatterLabs}, as well as in a S\&P 2020 paper by Zhang~\emph{et al.}~\cite{eprint/ZhangX0S19}.

\paragraph{Polynomial IOP formalism}
In concurrent work Chiesa~\emph{et al.}~\cite{Marlin} introduce an information theoretic framework called \emph{algebraic holographic proofs (AHP)}. They also show that with a polynomial commitment scheme an AHP can be compiled to a preprocessing SNARK. The AHP framework is essentially equivalent to our Polynomial IOP framework. %We additionally show how any Algebraic Linear IOP can be transformed into a Polynomial IOP, and hence an AHP. 
In other concurrent work, Chiesa, Ojha, and Spooner show interesting connections between algebraic holographic proofs and recursive proof composition. In the same work, the authors develop an AHP-based transparent SNARK called \textsf{Fractal}~\cite{Fractal}.



\if 0  
\section{Introduction}

A polynomial commitment scheme enables a prover to bind himself to a polynomial in much less bandwidth than transmitting all coefficients would require. A skeptical verifier can subsequently test the commitment for certain algebraic relations as though he were in possession of the polynomial's full description, except at a much smaller work cost. Indeed, polynomial commitments lie at the heart of a host of efficiently verifiable interactive proof systems.

Of particular interest to this paper are proof systems whereby the prover establishes the correct performance of an arbitrary computation (that may or may not involve secret information) in such a way that the communication or verification complexity scales asymptotically better than performing the computation naïvely. Without exception, these proof systems rely on a technique called \emph{arithmetization}: characterizing the computation in question as a collection of arithmetic operations over a finite field. The utility of polynomial commitments stems from their capacity to succinctly capture a canonical representation of such collections while retaining the algebraic properties that make arithmetization work in the first place.

The literature on proof systems for arbitrary computations focuses on two techniques to achieve polynomial commitments. First: Merkle trees --- here every leaf represents the polynomial's evaluation in a given point, and the Merkle root represents the commitment to the polynomial. The verifier needs to verify the authentication paths of selected points, which can be done in logarithmic space and time (as a function of the number of points). Second: groups equipped with bilinear maps --- in this case a structured reference string (SRS)\footnote{Previously known as \emph{common reference string}, CRS.} provides the values of all monomials up to a given degree when evaluated in an unknown point. By computing a weighted sum of these monomial values, the prover obtains the evaluation of his polynomial in the unknown point. The verifier performs the pairing operation to verify that multiplicative relations hold between committed polynomials.

This paper provides a third option for generating polynomial commitment schemes, namely by relying on groups of unknown order --- such as the group of integers with multiplication modulo an RSA modulus of unknown factorization, or the ideal class group of an order of an imaginary quadratic number field. These groups have seen relatively little adoption or even attention from the cryptographic community because the only known constructions thereof have subexponential attack algorithms. As a result, for a practical security level, elements of groups of unknown order typically require several hundreds of bytes to represent, in contrast to the tens of bytes needed for elements of elliptic curves for which no subexponential algorithms exist. 

Nevertheless, groups of unknown order provide a property that groups of known order, such as elliptic curve groups, cannot match: they enable homomorphic  commitments to an \emph{infinite} domain, namely the integers. Indeed, if the prover were capable of reducing a large integer to a smaller one without sacrificing the homomorphic properties, then he must know the group's order. The power of integer commitments was already noted by Lipmaa~\cite{AC:Lipmaa03b} who characterizes proof systems arising therefrom as \emph{Diophantine} --- a reference to the family of languages for which such proof systems establish. Specifically, a set $S \subset \mathbb{Z}^n$ is called \emph{Diophantine} if it is the projection onto the first $n \leq m$ coordinates of the set of roots to a polynomial $P(X_1, \ldots, X_m) \in \mathbb{Z}[X_1, \ldots, X_m]$.% Much more recently, Wesolowski produced a conceptually simple verifiable delay function (VDF) which builds on a proof of correct exponentiation in groups of unknown order. Building on this result, Boneh \emph{et al.} developed accumulators and vector commitments (with batch openings) from groups of unknown order~\cite{}. 

\alaninline{Todo: \\
 - applications (trustless snarks etc) \\
 - implications (no unfalsifiable assumptions) \\
 - overview of techniques \\
 - related work}

\vspace{0.25cm}
\textsc{Contributions.} The contributions of this paper are divisible into three rubrics:
\begin{itemize}
    \item[] \textbf{Tools.} We start with an encoding scheme that represents polynomials over a prime field $\mathbb{F}_p$ as integers, by encoding the polynomial's coefficients into the integer's base-$q$ expansion. Adjoined with a group of unknown order and a designated base element $g \in \mathbb{G}$, this encoding scheme naturally gives rise to a polynomial commitment scheme that inherits its somewhat homomorphic properties. Next, we provide protocols for proving the correct evaluation of a committed polynomial, and showing that two polynomials have the same coefficients but flipped or rotated. We also present a protocol for extracting the $i$th coefficient, thereby promoting the commitment scheme to one that also provides vector commitment functionality. Building on this observation, we provide another protocol for showing that a commitment represents the inner product between two vectors of which at least one is represented by its vector commitment. Another protocol establishes that two vector commitments represent the same vector up to an arbitrary but known permutation of the coefficients.
    \item[] All the proof systems mentioned so far have logarithmic communication complexity and logarithmic verification time. Moreover, with the exception of the inner product proof and the permutation proof, the prover's complexity is quasi-linear. If one is willing to sacrifice this scalability for the prover, we also provide counterparts to all the above proofs with constant communication and verification complexity.
    \item[] \textbf{Applications.} To illustrate the usefulness and the versatility of the enumerated tools, we join them straightforwardly to construct a simple succinct non-interactive argument of knowledge (SNARK) based on quadratic arithmetic programs (QAPs). To the best of our knowledge, this is the first SNARK for circuits without trusted setup (when instantiated with the class group) or with an SRS whose size is independent of the circuit (when instantiated with the RSA group).\footnote{This classification takes note of the \textsf{STARK} proof system of Ben Sasson \emph{et al.}~\cite{C:BBHR19} whose verification time is polylogarithmic but as a function of the \emph{running time} of some program and not of any circuit; as well as of Hyrax~\cite{SP:WTTW17} and Spartan~\cite{eprint:Setty19}, which do apply to circuits but whose verification times are not polylogarithmic and thus fail to satisfy the definition of SNARKs as set forth in the paper that coined the term~\cite{JC:BCCGLRT17}.}
    \item[] \alan{deprecated} We follow up this conceptually simple QAP-based proof system with a survey of popular communication-efficient proof systems for arbitrary computations, in which we replace their constituent components with tools developed earlier in this paper. In this light we analyze Sonic, Spartan, Hyrax, Bulletproofs, and \textsf{STARK}. In all cases we find that using our techniques leads to different trade-offs; improving on some metrics while degrading others.
\end{itemize}
\fi 
