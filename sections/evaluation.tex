We now evaluate \textsf{\textbf{Supersonic}}, the trustless-setup SNARK built on the Polynomial IOPs underlying \textsf{Sonic}~\cite{Sonic} and \textsf{PLONK}~\cite{Plonk} and compiled using our DARK polynomial commitment scheme. As explained in Section \ref{subsec:optimization}, the commitment scheme has several batching properties that can be put to good use here. It is possible to evaluate $k$ polynomials of degree at most $d$ using only $2$ group elements and $(k+1)$ field elements. To take advantage of this we delay the evaluation until the last step of the protocol (see Section \ref{subsec:compiling}). We present the proof size for both the compilation of \textsf{Sonic}, \textsf{PLONK} and \textsf{Marlin} in Table~\ref{tab:proofsize}. We use 1200 bits as the size of class group elements (\cite{PKC/BucHam01}) and $\lambda=120$. This leads to proof sizes of $11$KB for \textsf{Sonic}, $8.4$KB using \textsf{PLONK} and $9.6$KB using \textsf{Marlin} for circuits with a million gates. Using 2048-bit RSA groups the proof sizes become $17$KB and $13.6$KB respectively. 

The comparison is slightly misleading because for \textsf{Sonic} one million is the number of multiplication gates whereas for \textsf{PLONK} it is the sum of multiplication and addition gates. For \textsf{Marlin} it is the number of non-zero entries in the R1CS description of the circuit. A more careful analysis is therefore necessary, but this shows that there are Polynomial IOPs that can be compiled using the DARK polynomial commitment scheme to SNARKS of roughly $10$ kilobytes in size. These numbers stand in contrast to \textsf{STARK}s which achieve proofs of $600$KB for computation of similar complexity~\cite{C:BBHR19}. 
\vspace{-1em}

\begin{table}
\begin{mdframed}
\centering
\begin{tabular}{l|c|c|c|c}
Polynomial IOP &Polynomials  & \eval{} points & $|$SNARK$|$ & concrete size \\
\hline

 \multirow{2}{*}{\textsf{Sonic}~\cite{Sonic}} & \multirow{2}{*}{12 in $\params$ + 15} & \multirow{2}{*}{$12$}  & $(15+2\log_2(n))\GG$ &\; \multirow{2}{*}{11.3 KB} \\
 & & & $+(12+13\log_2(n))\ZZ_p$ &  \\
  \multirow{2}{*}{\textsf{PLONK}~\cite{Plonk}} & \multirow{2}{*}{$7$ in $\params$ + 7} & \multirow{2}{*}{$2$} & $7+2\log_2(n)\GG$& \; \multirow{2}{*}{8.3 KB} \\
  & & & + $(2+3\log_2(n)) \ZZ_p$\\
    \multirow{2}{*}{\textsf{Marlin}~\cite{Marlin}} & \multirow{2}{*}{$9$ in $\params$ + 10} & \multirow{2}{*}{$3$} & $10+2\log_2(6n)\GG$& \; \multirow{2}{*}{9.6 KB} \\
  & & & + $(4+4\log_2(3n)) \ZZ_p$
	\end{tabular}
\end{mdframed}
\caption{Proof size for $\textsf{\textbf{Supersonic}}$. Column 2 says how many polynomials are committed to in the SRS (offline oracles) and how many are sent by the prover (online oracles). Column 3 states the number of distinct evaluation points. The proof size calculation uses $|\ZZ_p|=120$ and $|\GG|=1200$ for $n=2^{20}$ gates.}
\label{tab:proofsize}
\end{table}

\paragraph{Prover and Verifier cost}
%With pre-computation the prover time consists of a linear number of group operations. 
The main cost for the \textsf{\textbf{Supersonic}} prover consist of computing the commitments to the polynomial oracles and producing the single combined $\eval$ proof.
This proof requires calculating the commitments to the polynomials $f_L(q)$ and $f_R(q)$ in each round and performing the $\textsf{PoE}(\gr{C}_R,\gr{C}/\gr{C}_L,q^{d'+1})$. Using precomputation, \emph{i.e.}, computing $\gr{g}^{q^i}$ for all $i$ and using multi-exponentiation, the commitments can be computed in $O_\lambda(\frac{d}{\log(d)})$ group operations. The same techniques can be used to reduce the number of group operations for the $\textsf{PoE}$s to $O_\lambda(d)$. The total number of group operations is therefore linear in the maximum degree of the polynomial oracles and the number of online oracles. Interestingly, the number of offline oracles hardly impacts the prover time and proof size.
 
The verifier time is dominated by the group operations for exponentiation in various places in the single combined $\eval$ protocol. It consists of 3 $\lambda$-bit exponentiations in each round: 1 for combining $\gr{C}_L$ and $\gr{C}_R$ and two for verifying the \textsf{PoE}. In the final round the verifier does another $\log_2(d+1)\lambda$-bit exponentiation to open the commitment but this could also be outsourced to the prover using yet another $\textsf{PoE}$. The total verifier time therefore consists of roughly an exponentiation of $3 \log_2(d+1) \lambda$ group operations. 
Using $10\mu$s per group operation (estimated using OpenSSL's 2048-bit RSA implementation), this gives us for $\lambda=120$ and $n=2^{20}$ a verification time of around 72ms. 
