We now evaluate \textsf{\textbf{Supersonic}} the compiled trust-less setup SNARK built on the polynomial IOPs from Sonic\cite{Sonic} and Plonk\cite{Plonk} and compiled using our new polynomial commitment scheme.
As explained in
\ifappendix
Appendix
\else
Section
\fi \ref{subsec:optimization} the commitment scheme has several batching properties. It is possible to evaluate $k$ polynomials of degree at most $d$ using only $2$ group elements and $(k+1)$ field elements. To take advantage of this we delay the evaluation until the last step of the protocol (see Section \ref{subsec:compiling}). We present the proof size for both the compilation of Sonic and Plonk in Table~\ref{tab:proofsize}. We use 1200 bits as the size of the class group (\cite{PKC/BucHam01}) and $\lambda=120$. This leads to proof sizes of $11KB$ for Sonic and $8.4$KB using Plonk for circuits with a million gates. Using 2048-bit RSA groups the proof sizes become $17KB$ and $13.6KB$ respectively. 

The comparison is slightly off as for Sonic this is multiplication gates and for Plonk these are both multiplication and addition gates. A more careful analysis is therefore necessary but this shows that there exists polynomial-IOPs that can be compiled to roughly $10-20$-KB SNARKs using the DARK polynomial commitment scheme. This stands in contrast to STARKs which achieve proofs of $600$KB for computation of similar complexity\cite{C:BBHR19}. 

\begin{table}

\begin{mdframed}


\begin{tabular}{l|l|l|l|l}
Poly-IOP &Polynomials  & \eval{} at& $|SNARK|$&$n=2^{20},\lambda=120,|\GG|=1200$ \\
\hline

 \multirow{2}{*}{Sonic\cite{Sonic}} & 12 in $\crs$+ 15 & \multirow{2}{*}{$27$  & $(15+2\log_2(n))\GG$ &\; \multirow{2}{*}{11.3 KB} \\
 & & & $+(27+9\log_2(n))\ZZ_p$ &  \\
  \multirow{2}{*}{Plonk\cite{Plonk}} & $6$ in $\crs$ + 6 & $2$& $6+2\log_2(3n)\GG$& \; \multirow{2}{*}{8.4 KB} \\
  & & & + $(10+3\log_2(3n))$
	\end{tabular}
\end{mdframed}
\caption{Proof size for $\textsf{\textbf{Supersonic}}$. Column 2 says how many polynomials are committed to in the CRS (offline oracles) and how many are sent by the prover (online oracles). Column 3 states the number of evaluation points. The proof size calculation uses $|\ZZ_p|=120$ and $|\GG|=1200$ for $n=2^{20}$ gates.}
\label{tab:proofsize}
\end{table}
\paragraph{Prover and Verifier cost}
%With pre-computation the prover time consists of a linear number of group operations. 
The main prover cost for the \textsf{\textbf{Supersonic}} consist of producing the commitments to the polynomial oracles and producing the single combined $\eval$ proof.
Producing the eval proof consists of producing commitments to the polynomials $f_L(q)$ and $f_R(q)$ in each round and performing the $\textsf{PoE}(\gr{C}_R,\gr{C}/\gr{C}_L,q^{d'+1})$. Using pre-computation, i.e. computing $\gr{g}^{q^i}$ for all $i$ and multi-exponentiation the commitments can be produced in $O_\lambda(\frac{d}{\log(d)})$ group operations. The same techniques can be used to reduce the number of group operations for the $\textsf{PoE}$s to $O_\lambda(d)$. The total number of group operations are, therefore, linear in the maximum degree of the polynomial oracles and the number of online oracles. Interestingly the number of offline oracles hardly impacts the prover time and proof size.
 
 The verifier time is dominated by the group operations in the single combined $\eval$ protocol.
It consists of 3 $\lambda$-bit exponentiations in each round, 1 for combining $\gr{C}_L$ and $\gr{C}_R$ and two for verifying the \textsf{PoE}. In the final round the verifier does another $\log(d)\lambda$-bit exponentiation which could also be outsourced to the prover using yet another $\textsf{PoE}$. The total verifier time consists therefore of roughly an exponentiation of $3 \log_2(d+1) \lambda$ group operations. 
Using $10\mu s$ per group operation (estimated using OpenSSL's 2048-bit RSA implementation), this gives us for $\lambda=120$ and $n=2^{20}$ a verification time of around 72 $ms$. 

