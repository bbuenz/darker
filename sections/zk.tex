This section sketches how to make the polynomial commitment scheme zero knowledge. 

\paragraph{Hiding and Zero-knowledge.} For many applications it is important the polynomial commitment is hiding, and that the evaluation protocol is zero-knowledge, i.e. it reveals nothing about the polynomial other than the evaluation at the requested point.
Towards this end we construct a Pedersen commitment for groups of unknown order.
The commitment key are two random group elements $\gr{g}$ and $\gr{h}$ with unknown discrete logarithm. If computing the logarithm is hard then the commitment is binding.
 The polynomial commitment changes such that $\gr{g}^{\bar{f}(q)}$ we get $\gr{g}^{\bar{f}(q)}\gr{h}^{r}$ for random $r \sample [0, B\cdot 2^{2\lambda}]$, where $B$ is an upper bound on the order of the unknown order group $\GG$.  
The commitment is computationally hiding under a \emph{subgroup indistinguishability assumption}, as formulated by Brakerski and Goldwasser~\cite{C:BraGol10}. This assumption states that the groups generated by any two non-trivial elements are computationally indistinguishable. Under this assumption $\gr{g}^{\bar{f}(q)}\gr{h}^r$ is statistically indistinguishable from a random group element.
This basic subgroup indistinguishability assumption holds in generic groups of unknown order. 

In class groups we need to ensure that the order is guaranteed to be odd~\cite{PKC/BucHam01}. If not then Gauss's square root algorithm could be used to distinguish subgroups of even and of odd order.
% For class groups, we assume the subgroup indistinguishability assumption applies in $NQR$, the subgroup of non-quadratic residues. It is easy to convert the deterministic $H$ into a PPT hash function onto $NQR$ by iterating until hitting the first quadratic non-residue (succeeding in an expected constant number of iterations). 

We can now use the general Cramer Damgard\cite{C:CraDam98} transform to turn the evaluation scheme into an honest verifier zero-knowledge scheme.  
To do this all the prover messages are replaced by a hiding commitments and the verification checks by zero-knowledge proofs. For the polynomial commitments we use the hiding commitments described above. For the evaluations we use Pedersen commitments\cite{C:Pedersen91} in a prime order group of known order $p$. To use the Pedersen commitment we require that computing discrete logarithms is hard in these groups. 
We use the ${UO}$ subscript for the group of unknown order and $PO$ for the prime order group, i.e. $\GG_{UO}$ and $\GG_{PO}$.
Similarly $\commit_{UO}:\ZZ^2 \rightarrow\GG_{UO}=f(X),r \rightarrow \gr{g}^{f(q)}\gr{h}^{r}$ and $\commit_{PO}:\ZZ_p^2\rightarrow \GG_{PO}$ are the commitment functions.
The transformation is as follows: 

\begin{itemize}
\item To commit to the polynomial $f(X)$ the prover computes $\gr{C}\gets \commit_{UO}(f(q);r)$ for a random blinding factor $r$. 
The prover computes $\gr{Y}\gets \commit_{PO}(y;0)$ a non hiding commitment to $y$.

\item In every round the prover sends $\gr{C}_L\gets\commit_{UO}(f_L(q);r_L)$ and $\gr{C}_R\gets\commit_{UO}(f_R(q);r_R)$ for $r_L,r_R \sample [0,B\cdot 2^{\lambda}]$. Additionally the prover sends $\gr{Y}_R\gets\commit_{PO}(f_R(z),r_y)$ for $r_Y\sample \ZZ_p$. 
The verifier directly computes a commitment to the value $y_L$ as $\gr{Y}_L\gets\gr{Y}/\gr{Y}_R^{q^{d'+1}} \in \GG_{PO}$ (just as in the optimized protocol, Section~\ref{subsec:optimization}). The prover sends $\gr{C}'\gets \gr{C}_L\gr{C}_R^{q^{d'+1}}$ and proves that it was computed correctly with a PoE. 

\item The prover must show that $\gr{C}'$ and $\gr{C}$ commit to the same value. This can be done using a $\Sigma$ proof to show knowledge of the discrete log of $\gr{C}' / \gr{C}$ base $\gr{h}$. One such protocol (ZK-PoKE) is outlined in Boneh et al.\cite{C:BonBunFis19}.
 
\item Finally let $\gr{C}'\in \GG_{UO}$ and $\gr{Y}'\in \GG_{PO}$ denote the commitments in the final round, i.e. when $d=0$. The prover now needs to convince the verifier, in zero-knowledge, that $\gr{C}'$ and $\gr{Y}'$ commit to the same integer modulo $p$, and additionally, that $\gr{C}$ commits to a bounded integer. Both of these can be achieved simultaneously using a single $\Sigma$ proof of discrete logarithm equality outlined below.
\end{itemize}

In the protocol $b$ is the bound on the size of $f$ and $B$ an independent upper bound on the order of $\GG_{UO}$.
 \noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	\pro{$\Sigma$ Proof of Equality} for Relation: $\mathcal{R}_{EQUAL}$\\
	Input: $\gr{C} \in \GG_{UO}, \gr{Y}\in \GG_{PO}, b,B\in \ZZ$, Witness: $f \in \ZZ(b),r_C \in \ZZ,r_Y \in \ZZ_p$\\
	Statement: $\gr{C}=\commit_{UO}(f;r_C)$ and $\gr{Y}=\commit_{PO}(f \bmod p;r_Y)$
	\begin{enumerate}[nolistsep]
		    \item \prover samples $k_f,k_C \sample [0,2^{2\lambda} B]$ and $k_Y \sample \ZZ_P$ and computes $\gr{R}_C\gets \commit_{UO}(k_f;k_C)$ and $\gr{R}_Y\gets \commit_{PO}(k_f \bmod p;k_C)$.
		    \item \prover sends $\gr{R}_C,\gr{Y}$ to $\verifier$
		    \item \verifier samples random $\alpha\in [0,2^\lambda]$ and sends it to $\prover$
		    \item \prover computes $s_f\gets k_f + \alpha \cdot f, s_C=k_C+ \alpha \cdot r_C \in \ZZ$, as well as $s_Y\gets k_Y+ \alpha\cdot r_Y \bmod p$. \prover sends $s_f,s_C,s_Y$ to \verifier.
		    \item \verifier checks that $s_f\in [-b,b\cdot 2^{\lambda}+2^{2\lambda}B]$, $\commit_{UO}(s_f;s_C)=\gr{R}_C C^{\alpha}$ and $\commit_{PO}(s_f \bmod p;s_Y)=\gr{R}_Y Y^{\alpha}$
		    \item \pcif{}check passes \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
 The protocol is zero-knowledge if the commitments are hiding and is an argument of knowledge for $\mathcal{R}_{EQUAL}$.
 \paragraph{Proof sketch}
 We show that the protocol is zero-knowledge by showing that we can build an efficient simulator that can create valid looking transcripts without knowing the witness. The simulator samples a challenge $\alpha$ as well as random $s_Y$, $s_C$ and $s_f$ in the appropriate domains. Then it computes $\gr{R}_C$ and $\gr{R}_Y$ directly from the verification equations and the sampled elements. Note that $\gr{R}_C$ is a random group element in both the honest and the simulated transcripts. $\gr{R}_C$ and $\gr{R}_Y$ are computationally indistinguishable from random group elements under the subgroup indistinguishability assumption as shown in \cite{AC:DamFuj02,C:BraGol10}. This shows that the simulated transcripts are computationally indistinguishable from honestly generated transcripts.
 
 To show that the protocol is extractable we first show special soundness. The extractor receives two transcripts $\tr=(\gr{R}_C,\gr{R}_Y,\alpha,s_f,s_C,s_Y)$ and $\tr'=(\gr{R}_C,\gr{R}_Y,\alpha',s_f',s_C',s_Y')$ for $\alpha \neq \alpha'$. The extractor computes $\commit(s_f-s_f',s_C-s_C')=\gr{C}^{\alpha-\alpha'}$. Boneh et al. \cite{C:BonBunFis19} show that the probability that $s_f-s_f'$ and $s_C-s_C'$  are not divisible by $\alpha-\alpha'$ is negligible assuming $\GG$ is modeled as a generic group.\footnote{Can replace with falsifiable assumption...} The extractor therefore obtains the witnesses $f^* \leftarrow \frac{ s_f-s_f'}{\alpha-\alpha'}$ and $r_C^* \leftarrow \frac{ s_C-s_C'}{\alpha-\alpha'}$ such that $\commit_{UO}(f^*; r_C^*)=\gr{C}$. Additionally, the extractor obtains $r_Y^* \leftarrow \frac{s_y-s_y'}{\alpha-\alpha'}$ such that $\commit_{PO}( f^* \bmod p; r_Y^*)=\gr{Y}$. %This shows that $f* \bmod p$ is equal to $y$ mod $p$.
 Additionally the bound on $s_f$ (checked in the protocol) implies an upper bound on the size of the extracted $f^*$. 
 Given a sufficiently large $q$ this shows that the overall polynomial commitment scheme still has witness extended emulation.