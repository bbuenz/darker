\if 0 
\section{Deprecated witness extended emulation for OpenIndex queries} 

We can show that if $\pro{Eval}$ has witness-extended emulation, then so does $\pro{OpenIndex}$ as an interactive argument for the relation: 

\[ 
\mathcal{R_\textsf{Index}}(\params) = \left\{
\langle (c, a, i, d), (f(X), r) \rangle
: 
\begin{array}{l} 
f \in R[X] \ \text{has degree at most} \ d \ \text{with} \ f_i = a \\ 
 \text{and} \ \pro{Open}(\params, c, f(X), r) = 1 \\
\end{array}
\right\}
\] 


\begin{lemma} 
If $\pro{Eval}$ is an interactive argument for $\mathcal{R_\textsf{Eval}}(\params)$ with witness-extended emulation then $\pro{OpenIndex}$ is an interactive argument for $\mathcal{R_\textsf{Index}}(\params)$ with witness-extended emulation. 
\end{lemma}

\begin{proof}[Proof sketch]
Let $E_{\eval}$ be an emulator for $\pro{Eval}$. We construct an emulator $E$ for $\pro{OpenIndex}$ that makes calls to $E_{\eval}$. At a high level, $E$ will invoke $E_{\eval}$ in order to extract witness polynomials $f_R(X)$, $f_L(X)$, $f(X)$ of appropriate degrees from the respective successful executions of $\pro{Eval}$ and also piece together a consistent emulation transcript. We then argue that if $f(X) - a X^i \neq X^{i+1} f_R(X) + f_L(X)$, then the evaluation binding of the polynomial commitment $\eval$ is broken. $E$ could rewind the protocol to the second step after receiving commitments $c, c_R, c_L$ and rerun on a fresh challenge $\beta' \leftarrow_R \FF$, doing this until it gets another accepting transcript (in expected polynomial time) with succesful openings of $f(\beta') = y'$, $f_L(\beta') = y'_L$, and $f_R(\beta') = y'_R$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta^i \bmod p$. Yet, $f(\beta') - a X^i \neq X^{i+1} f_R(\beta') + f_L(\beta')$ except with probability $\poly / |\FF|$ (union bound over the $\poly$ rewindings), which implies that one of the claimed evaluations was incorrect. The full proof is in the appendix. 

\ben{TODO move to appendix}

Given adversarial prover $P^*$ and transcript oracle $\pro{Record}(P^*, \params, (c, a, i, d), \st)$, $E$ does the following: 

\begin{itemize} 
\item Run $\pro{Record}$ from the start until the first $\pro{Eval}$. $E$ obtains a transcript containing $c, c_R, c_L, y, y_R, y_L$ and $\beta$. 

\item Invoke $E_{\eval}$ by simulating its transcript oracle $\pro{Record}(P^*, \params, c, \beta, y, d, \st)$. ($E$ simulates this transcript oracle for $E_{\eval}$ by consulting its own transcript oracle, which is running $\eval$ as a subprotocol). $E_{\eval}$ returns an output $(\tr_1, f^*)$, and w.l.o.g. interpret $f^*$ as giving a canonical encoding of an integer polynomial $f^*(X)$. Do the same for the subprotocol $\eval$ executions on $(c_R, \beta, y_R, d - i - 1)$ and $(c_L, \beta, y_L, i-1)$ respectively, which returns $(\tr_2, f_L^*)$ and $(\tr_3, f_R^*)$. 

\item Piece together the transcript obtained from running $\pro{Record}$ in the first step (i.e. up until the first $\eval$ together with the transcripts $\tr_1, \tr_2, \tr_3$ into a complete transcript $\tr^*$. This $\tr$ is an ``accepting transcript" if and only if the verifier in the last step would output $1$. 

\item Output $(\tr^*, f^*)$.  
\end{itemize}

We now argue that for any PPT $\mathcal{A}$ and $\params \leftarrow \pro{Setup}(1^\lambda)$, if the experiment sampling $(X, \st) \leftarrow \mathcal{A}(\params)$ and $\tr \leftarrow \pro{Record}(P^*, \params, x, \st)$, where $x$ is a tuple of the form $(c, a, i, d)$, produces an ``accepting transcript" $\tr$ with probability $\delta$, then the modified experiment that samples $(\tr^*, f^*) \leftarrow E^{\textsf{Record}(P^*, \params, x, \st)}(\params, x)$ returns an $f^*$ such that $((c, a, i, d), f^*) \in \mathcal{R_\textsf{Index}}(\params)$ with probability $\delta - \negl$. 

If $\delta$ is negligible the claim holds trivially. For now on assume that $\delta$ is non-negligible. 
The fact that $\tr$ is an accepting transcript with probability $\delta$ implies that each $\eval$ subprotocol generates accepting transcripts with probability at least $\delta$. Therefore, by the hypothesis that $\eval$ has witness-extended emulation, if each of the subprotocol transcripts $\tr_1$, $\tr_2$, $\tr_3$ are accepting then with probability $\delta - \negl$: subprotocol witnesses $f^*, f_L^*$ and $f_R^*$ are all valid $\mathcal{R_\textsf{Eval}}(\params)$ witnesses for $(c, \beta, y, d)$, $(c_L, \beta, y_L, i-1)$, and $(c_R, \beta, y_R, d - i - 1)$ respectively. 

We have already shown that the extracted polynomial $f^*(X)$ is valid for $c$ with probability $\delta - \negl$. As a final step, suppose towards contradiction that $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$. Since $\delta$ is non-negligible, $E$ can rewind the transcript oracle to Step 2 (i.e. after receiving the commitments $c, c_L, c_R$), restarting the protocol from this point on a fresh verifier challenge $\beta' \leftarrow_R \FF$. It does this until (in expected polynomial time) it finds a $\beta'$ that produces an accepting transcript, which includes $y', y_L', y_R'$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta'^i \bmod p$.

The probability that $f_L^*(\beta') + \beta'^i f_R^*(\beta') = f^*(\beta') - a \beta'^i$ is less than $\poly / |\FF|$ (the $\poly$ numerator comes from union bound over number of rewindings). In this case, either $y' \neq f^*(\beta')$ or $y_L' \neq f^*_L(\beta')$ or $y_R' \neq f^*_R(\beta')$. Yet, $\eval$ passes on all three, which contradicts the evaluation binding property of $\eval$. Hence, we conclude that except with $\negl$ probability $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$, and thus $f^*_i = a$. 

\end{proof}
\fi 


\if 0 %%Deprecated discussion of vector commitments 
\subsection{Vector Commitments}

A commitment to a polynomial is a commitment to a list of coefficients, and the ability to extract any indicated coefficient from a polynomial commitment effectively upgrades the scheme to a vector commitment scheme. While it is possible to extract an indicated coefficient using only a polynomial commitment scheme (see Section~\ref{section:generic_coefficient_extraction} for a demonstration of this fact), it is possible to achieve this task much more efficiently by exploiting the homomorphic properties of our commitment scheme. For the following description we will identify polynomials $f(X)$ with their coefficient vectors $\mathbf{f}$ and vice versa, and we will switch between notations whenever it is convenient.

We achieve this task in two steps. Protocol $\pro{ExtractCoefficient}(\params, \gr{C}, i, \gr{C}_a; \mathbf{f}) \rightarrow b \in \{0,1\}$ validates that a given commitment really is a commitment to an indicated coefficient of a vector commitment. Next, Protocol $\pro{OpenIndex}$ uses this as a subprotocol to realize the syntax defined in the preliminaries (Section~\ref{subsection:openindex}). 

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{ExtractCoefficient}(\params, \gr{C}, i, \gr{C}_a; \mathbf{f}):$ \pccomment{$\mathbf{f} = (f_0, \ldots, f_d)^\mathsf{T} \in \ZZ^{d+1}$ and $a = f_i$}
		\begin{enumerate}[nolistsep]
		    \item \prover computes $f_L(X) \gets \sum_{j=0}^{i-1} f_j X^j$ and $f_R \gets \sum_{j=i+1}^d f_j X^{j-i-1}$
		    \item \prover computes $\gr{C}_L \gets \gr{g}^{f_L(q)}$, and $\gr{C}_R \gets \gr{g}^{f_R(q)}$
		    \item \prover computes $\gr{C}_a' \gets \gr{C}_a^{q^i}$ and $\gr{C}_R' \gets \gr{C}_R^{q^{i+1}}$
		    \item \prover sends $\gr{C}_L, \gr{C}_a', \gr{C}_R$ to \verifier
		    \item \verifier computes $\gr{C}_R' \gets \gr{C} \gr{C}_L^{-1} {\gr{C}_a'}^{-1}$
		    \item \prover and \verifier run $\pro{PoE}(\gr{C}_a, \gr{C}_a', q^i)$ and $\pro{PoE}(\gr{C}_R, \gr{C}_R', q^{i+1})$
		    \item \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}_L, z, f_L(z), i-1, b; f_L(X))$ for an arbitrary $z$ and any $b$ such that $\max_j f_j \leq b \ll q$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\textit{Note.} Instead of line 7, \prover and \verifier might as well run any range proof that establishes that $\gr{C}_L$ is a commitment to an integer smaller than $q^i$ in absolute value.

\begin{lemma}
    Protocol $\pro{ExtractCoefficient}$ has witness-extended emulation for the relation
    \[
        \mathcal{R}_\mathsf{EC}(\params) = \left\{
            \langle(\gr{C}, i, \gr{C}_a), (\mathbf{f}, r_f, r_a)\rangle \ : \ \begin{array}{l}
                 \mathbf{f} = (f_0, \ldots, f_d)^\mathsf{T} \in \mathbb{Z}_p^{d+1} \\
                 \pro{Open}(\params, \gr{C}, \mathbf{f}, r_f) = 1 \\
                 \pro{Open}(\params, \gr{C}_a, f_i, r_a) = 1
            \end{array}
        \right \} \enspace .
    \]
\end{lemma}
\begin{proof}
Full version/appendix.
\end{proof}

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{OpenIndex}(\params, \gr{C}, a, i; \mathbf{f}):$ \pccomment{$\mathbf{f} \in \ZZ_p^{d+1}$}
		\begin{enumerate}[nolistsep]
		    \item \prover computes $\gr{C}_a \gets \gr{c}^{f_i}$ and sends it to \verifier
		    \item \prover and \verifier run $\pro{ExtractCoefficient}(\params, \gr{C}, i, \gr{C}_a; \mathbf{f})$
		    \item \prover and \verifier run $\pro{Open}(\params, \gr{C}_a, a; f_i)$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\begin{lemma}
    Protocol $\pro{OpenIndex}$ has witness-extended emulation for the relation
    \[
        \mathcal{R}_\mathsf{Index}(\params) = \left\{
            \langle(\gr{C}, a, i, d), (\mathbf{f}, r_f)\rangle \ : \ \begin{array}{l}
                \mathbf{f} = (f_0, \ldots, f_d)^\mathsf{T} \in \mathbb{Z}_p^{d+1} \\
                f_i = a \\
                \pro{Open}(\params, \gr{C}, \mathbf{f}, r_f) = 1
            \end{array}
        \right\} \enspace .
    \]
\end{lemma}

\begin{proof}
Full version/appendix.
\end{proof}
\fi 

\if 0 %%Deprecated discussion of inner products 
\subsection{Inner Products}

The polynomial commitment scheme has a multiplicative homomorphism. Specifically, let $f(X), g(X) \in \ZZ_p[X]$ and let $\gr{C}$ be a commitment to $f(X)$. Then, provided that $q$ is large enough to prevent overflow, $\gr{C}^{g(q)}$ is a commitment to $f(X) \times g(X)$. This feature is particularly useful in the context of vector commitments where the goal is to extract not an indicated coefficient but a linear combination of all coefficients. To see how this might work, consider the coefficient vectors $\mathbf{f} = (f_0, \ldots, f_{d})$ and $\mathbf{g} = (g_0, \ldots, g_d)$. Then $\gr{C}$ is simultaneously a vector commitment to $\mathbf{f}$, and raising this commitment to %the integer encoding of the reciprocal of $g(X)$
the power $\sum_{i=0}^d g_{d-i} q^i$
gives a commitment to a new vector whose middle coefficient contains the inner product $\langle \mathbf{f}, \mathbf{g} \rangle$. To see this, consider the logarithm of $\gr{C}^{\sum\limits_{i=0}^{d} g_{d-i} q^i}$ base $\gr{g}$:
\begin{flalign*}
\left( \sum\limits_{i=0}^d f_i q^i \right) \left( \sum\limits_{i=0}^d g_{d-i} q^i \right) = \sum\limits_{i=0}^d \sum\limits_{j=0}^d f_i g_j q^{d-j+i} = q^d \sum_{i=0}^d f_i g_i \ + o(q^{d+1}) + \omega(q^{d-1}) \enspace .
\end{flalign*}

We use this property to realize protocols for extracting inner products. A minor issue is that the right hand vector commitment must represent the coefficients in reversed order. To circumvent this obstacle we denote by $\mathbf{\bar{g}}$ the vector $\mathbf{g}$ but with its coefficients reversed. For applications where this issue cannot be solved with notational cleverness, Appendix \textbf{[todo]} presents a protocol to establish that two vector commitments represent the same coefficients but in reversed order. 

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{InnerProduct}(\params, \gr{C}_\mathbf{f}, \gr{C}_\mathbf{\bar{g}}, a; \mathbf{f}, \mathbf{\bar{g}}):$ \pccomment{$\mathbf{f}, \mathbf{\bar{g}} \in \ZZ^{d+1}$ and $\gr{C}_\mathbf{\bar{g}} = \gr{g}^{\sum_{i=0}^d g_{d-i} q^i}$}
		\begin{enumerate}[nolistsep]
		    \item \prover computes $\gr{C}_h \gets \gr{C}_\mathbf{f}^{\sum_{i=0}^{d} g_{d-i} q^i}$ and sends it to \verifier
		    \item \verifier samples $z \sample \mathbb{Z}_p$ and sends it to \prover
		    \item \prover computes $h(X) \gets \left(\sum_{i=0}^d f_i X^i\right) \left(\sum_{i=0}^d g_{d-i} X^i\right)$
		    \item \prover computes $y_f \gets f(z)$, $y_g \gets g(z)$, and $y_h \gets h(z)$ and sends $(y_f, y_g, y_h)$ to \verifier
		    \item \verifier checks that $y_h = y_f \times y_g$
		    \item \verifier samples $\beta, \gamma \sample \mathbb{Z}_p$ and sends $(\beta, \gamma)$ to \prover
		    \item \prover computes $\gr{C}' \gets (\gr{C}_\mathbf{f}^\beta \gr{C}_\mathbf{g}^\gamma)^{q^{d-1}}$ and sends $\gr{C}'$ to \verifier
		    \item \prover and \verifier run $\pro{PoE}(\gr{C}_\mathbf{f}^\beta \gr{C}_\mathbf{g}^\gamma, \gr{C}', q^{d-1})$
		    \item \prover and \verifier run $\pro{Eval}(\gr{C}'\gr{C}_h^{-1}, z, {\beta{} z^{d-1} y_f + \gamma{} z^{d-1} y_g - y_h} , {2d-1} ;$ ${\beta{} X^{d-1} f(X) + \gamma{} X^{d-1} g(X) - h(X)})$
		    \item \prover computes $\gr{C}_a \leftarrow \gr{g}^{h_d}$
		    \item \prover and \verifier run $\pro{ExtractCoefficient}(\params, \gr{C}_h, d, \gr{C}_a; h(X))$
		    \item \prover and \verifier run $\pro{Open}(\params, \gr{C}_a, a, h_d)$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\begin{lemma}
    The protocol $\pro{InnerProduct}$ has witness-extended emulation for the relation
\[\mathcal{R}_\mathsf{IP}(\params) = \left\{
    \langle(\gr{C}_\mathbf{f}, \gr{C}_\mathbf{\bar{g}}, a), (\mathbf{f}, \mathbf{\bar{g}}, r_f, r_g)\rangle \ : \     \begin{array}{l}
            \mathbf{f}, \mathbf{\bar{g}} \in \mathbb{Z}_p^{d+1} \\
            \langle \mathbf{f}, \mathbf{g} \rangle = a \\
            \pro{Open}(\params, \gr{C}_\mathbf{f}, \mathbf{f}, r_f) = 1 \\
            \pro{Open}(\params, \gr{C}_\mathbf{\bar{g}}, \mathbf{\bar{g}}, r_g) = 1
        \end{array}
    \right\} \enspace .
\]
\end{lemma}

\begin{proof}
In the full version of the paper.
\end{proof}
\fi 


\section{Protocols for Proving Permutations}

\subsection{Flip}\label{apx:reverse}

The following protocol establishes that two commitments, $c_a$ and $c_b$ represent polynomials $f_a, f_b \in \ZZ_p$ (or vectors, for that matter) whose coefficients are flipped. Specifically, that $f_a = \sum_{i=0}^{d}f_i X^i$ for some coefficients $f_i$, and $f_b = \sum_{i=0}^df_ix^{d-i}$ for the same coefficients $f_i$.
Protocol:
\begin{itemize}
    \item Common knowledge: $c_a, c_b \in \mathbb{G}$.
    \item Verifier chooses $z \sample \ZZ_p \backslash \{0\}$ and sends it to Prover.
    \item Prover and Verifier engage in proofs of correct evaluation producing $f_a(z)$ and $f_b(z^{-1})$, matching $c_a$ and $c_b$, respectively.
    \item Verifier checks that $f_a(z) \stackrel{?}{=} z^d f_b(z^{-1})$.
\end{itemize}

To see why it works, observe that $f_a(X) = X^df_b(X^{-1})$ and we can test this equation probabilistically by choosing a random $z \in \mathbb{F}_p \backslash \{0\}$ to evaluate $f_a$ and $f_b$ in. If $f_a$ is indeed the flipping of $f_b$ then the polynomial $F = f_a(X) - X^df_b(X^{-1})$ is identically zero; but otherwise it has at most $d$ zeros, and so the inequality will be exposed with overwhelming probability $(p-1-d)/(p-1)$.

\subsection{Rotation}

A similar observation gives rise to a proof of correct rotation. If $f(X) = \sum_{i=0}^d f_i X^i \in \mathbb{F}_p$ and $p(X) = \sum_{i=0}^d f_{i+r \, \mathsf{mod} \, d+1} X^i \in \mathbb{F}_p$ are polynomials consisting of the same coefficients but rotated by $r$ positions, then $p(X) = X^r f(X) \, \mathsf{mod} \, X^r - 1$ in all points. More explicitly, $p(X) = X^r f(X) + k(X) (X^r - 1)$ for some $k(X) \in \mathbb{F}_p$. The verifier can test this relation probabilistically.

\begin{itemize}
    \item Common knowledge: $c_f, c_p \in \mathbb{G}$ --- commitments to $f(X)$ and $p(X)$, respectively. Secret knowledge for the prover $f(X), p(X)$.
    \item Prover computes $k(X) = (p(X) - X^r f(X)) / X^r - 1$ and sends the commitment $c_k = g^{\hat{k}(q)}$ to it to Verifier.
    \item Verifier chooses a random point $z \sample \mathbb{F}_p$ and sends it to Prover.
    \item Prover and Verifier engage in proofs of correct evaluation for $f(z)$, $p(z)$, and $k(z)$.
    \item Verifier checks that $z^r f(z) + k(z) (z^r-1) = p(z)$.
\end{itemize}

\subsection{Generic Permutation}

The following protocol establishes that two polynomial commitments have the same coefficients but permuted according to a known permutation $\sigma : \{0,\ldots,d\} \rightarrow \{0,\ldots,d\}$. Specifically, $c_f$ is a commitment to $f(X) = \sum_{i=0}^d f_i X^i$ and $c_p$ is a commitment to $p(X) = \sum_{i=0}^d f_{\sigma(i)} X^i$. The proof makes use of the relation $p(X) = X^{\sigma(0)} f(X^{d+1}) - d(X)$ where $d(X) = \sum_{i=1}^d f_i (X^{i(d+1) + \sigma(0)} - X^{\sigma(i)})$. As $d(X)$ relies on the coefficients of $f(X)$, it is important to establish that $d(X)$ is correctly formed.

\begin{itemize}
    \item Common knowledge: $c_f, c_p, \sigma$ -- commitment to $f(X)$, commitment to $p(X)$, and permutation of coefficients.
    \item Secret knowledge for Prover: $f(X), p(X) \in \mathbb{F}_p$.
    \item Prover computes $n = \hat{f}(q^{d^2})$ and sends $c_n = g^n$ to Verifier.
    \item Prover and Verifier run an inner product protocol between $c_n$ and $(q^{di})_{i=0}^d$, and again between the result and $(q^i)_{i=0}^d$. This establishes that $n$ has the same coefficients as $c_f$ but spaced differently.
    \item Prover and Verifier run an inner product protocol between $c_n$ and $(q^{(i(d+1) + \sigma(0)} - q^{\sigma(i)})_{i=0}^d$ to compute $c_d$, the commitment to $d(X)$ that is well-formed wrt. $f(X)$.
    \item Verifier chooses a random point $z \sample \mathbb{F}_p$.
    \item Prover and Verifier engage in proofs of correct evaluation for $f(z), p(z), d(z)$.
    \item Verifier checks that $p(z) = z^{\sigma(0)} f(z^{d+1}) - d(z)$.
\end{itemize}


\subsection{Reversed Coefficients}

It is quite straightforward to show that two commitments represent polynomials with the same coefficients but in reverse order. Suppose $f(X) = \sum_{i=0}^d f_i X^i$ and $\bar{f}(X) = \sum_{i=0}^d f_{d-i}X^i$ are two polynomials with the same coefficients but in reverse order. Then the relation $\bar{f}(X) = X^d \cdot f(X^{-1})$ holds for all $X \in \mathbb{Z}_p \backslash \{0\}$. This relation can be tested probabilistically by choosing a random $z \sample \mathbb{Z}_p \backslash \{0\}$ and opening the evaluations $f(z)$ and $\bar{f}(z)$. This observation gives rise to the protocol $\pro{Reverse}(\params, \gr{C}_f, \gr{C}_{\bar{f}}; f(X)) \rightarrow b \in \{0,1\}$ which proves that $\gr{C}_f$ and $\gr{C}_{\bar{f}}$ are indeed commitments to polynomials with the same coefficients but in reverse order.

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{Reverse}(\params, \gr{C}_{f}, \gr{C}_{\bar{f}}; {f}(X)):$ \pccomment{$\gr{C}_f = \gr{g}^{\sum f_i q^i}$ whereas $\gr{C}_{\bar{f}} = \gr{g}^{\sum f_{d-i} q^i}$}
		\begin{enumerate}[nolistsep]
		    \item $\verifier$ samples $z \sample \mathbb{Z}_p \backslash \{0\}$ and sends $z$ to $\prover$
		    \item $\prover$ computes $y \leftarrow f(z)$ and $\bar{y} \leftarrow \bar{f}(z^{-1})$ and sends $(y, \bar{y})$ to $\verifier$
		    \item $\prover$ and $\verifier$ run $\pro{Eval}(\gr{C}_f, z, y, d; f(X))$ and $\pro{Eval}(\gr{C}_{\bar{f}}, z, \bar{y}, d; \bar{f}(X))$ \pccomment{$\bar{f}(X) = \sum_i f_{d-i} X^i$}
		    \item $\verifier$ checks that $y = z^d \bar{y}$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\begin{lemma}
    The protocol $\pro{Reverse}$ is an argument of knowledge for the relation 
    \[
        \mathcal{R}_\mathsf{Rev}(\params) = \left\{
            \langle ( \gr{C}_f, \gr{C}_{\bar{f}} ), (\mathbf{f}, r_f, r_{\bar{f}})\rangle \ : \ \begin{array}{l}
                \mathbf{f} \in \mathbb{Z}_p^d \\
                \pro{Open}(\params, \gr{C}_f, \sum_{i=0}^d f_i X^i, r_f) = 1 \\
                \pro{Open}(\params, \gr{C}_{\bar{f}}, \sum_{i=0}^d f_{d-i} X^i, r_{\bar{f}}) = 1 
            \end{array}
        \right\} \enspace .
    \]
\end{lemma}

\begin{proof}
Full version / appendix.
\end{proof}


\section{Zero Knowledge Polynomial Commitment} \label{apx:zeroknowledge}

This section sketches how to make the polynomial commitment scheme zero knowledge. 

\paragraph{Commit} Let $g_1 \sample \GG$ be a random base distinct from $g$. 
The hiding polynomial commitment is $C \leftarrow g^{f(q)}g_1^r$ for $r \sample [-2^\lambda, 2^\lambda]$. 

\paragraph{Open} The opening of the entire polynomial is the same, but additionally gives the blinding factor $r$. 

\paragraph{Eval}

\begin{itemize}
\item In each recursive step we commit to polynomials $f_0$ and $f_1$ using the same hiding commitment scheme, where $f_0 + f_1 q^{d/2} = f$ as integer polynomials. 

\item Note that if $C_0 = g^{f_0(q)}g_1^{r_0}$ and $C_1 = g^{f_1(q)} g_1^{r_1}$ then $C_0 \cdot C_1^{q^{d/2}} = C \cdot g_1^{r'}$ where $r' = r_0 + q^{d/2} r_1$. The prover can give a non-interactive zk proof of this relation to the verifier using a sigma protocol. E.g., the prover provides $C_1' = C_1^{q^{d/2}}$ with a PoE, and then a zk-PoKE of $r'$ such that $g_1^{r'} = C_0 C_1' / C$. 

\item We could then recurse on $C_0^\alpha C_1$ which commits to $\alpha f_0 + f_1$ with the blinding factor $\alpha r_0 + r_1$. BUT we are not done yet, see next bullet point... 

\item The remaining problem is that the evaluation protocol opens $y_0 = f_0(z) \bmod p$ and $y_1 = f_1(z) \bmod p$, which is not zero knowledge. We need $y_0, y_1$ to be independently distributed subject to the constraint $y_0 + z^{d/2} y_1 = y \bmod p$, which the verifier checks. 

A solution is to modify $f_0$ and $f_1$ by adding constant terms $\alpha, \beta$ to each that cancel, i.e. $\alpha + z^{d/2} \beta = 0 \bmod p$, where $\alpha$ is uniformly distributed in $\ZZ_p$. This way the polynomials $f_0' = f_0 + \alpha$ and $f_1' = f_1 + \beta$ satisfy the relation $f_0'(z) + z^{d/2}f_1'(z) = f(z) \bmod p$. We end up revealing $y_0' = y_0 + \alpha \bmod p$ and $y_1' = y_1 + \beta \bmod p$, which is uniformly distributed in $\ZZ_p$ subject to $y_0' + y_1' = y \bmod p$. 

Finally, the prover needs to convince the verifier that it modified the $C_0$ and $C_1$ commitments appropriately. (It could not simply choose $f_0'$ and $f_1'$ in the first step because $f_0' + q^{d/2} f_1' \neq f$ as integer polynomials). 

However, the solution is still simple. The prover creates hiding commitments $C_\alpha$ to $\alpha$ and $C_\beta$ to $\beta$ and provides a zero-knowledge proof that $C_\alpha C_\beta ^{z^{d/2}}$ is a commitment to an integer multiple of $p$. This can be done efficiently through a combination of PoE and a PoKE. (Given $g^a$, to prove that $a = 0 \bmod p$ it suffices to provide $Q$ such that $Q^p = g^a$ and a PoKE for $Q$ base g. This can be made zero knowledge w/ the standard tricks). 

The protocol then proceeds on modified commitments $C_0' = C_0 C_\alpha$ and $C_1' = C_1 C_\beta$.

\end{itemize}














\begin{comment}
\section{Vector Commitment}

\subsection{Commitment Scheme}

In the following we denote by $(a_i)_{i=0}^{d-1} \in \ZZ_p^{d}$ a vector of prime field elements. The vector commitment scheme is given by the following algorithms.
\begin{itemize}
\item $\mathsf{vcom} : \ZZ_p^d \rightarrow \mathbb{G} \, , \quad (a_i)_{i=0}^{d-1} \mapsto g^{\sum_{i=0}^{d-1} a_iq^i} \enspace .$
\item $\mathsf{vopen} : \mathbb{G} \times \mathbb{Z} \rightarrow \ZZ_p^d \cup \{\bot\} \, , $
\item[] $\phantom{\mathsf{vopen} :} (C, z = \sum_{i=0}^{d-1} z_iq^i) \mapsto \left\lbrace \begin{array}{ll}
(z_i \, \mathsf{mod} \, p)_{i=0}^{d-1} & \textnormal{\bf if } g^z = C \\
\quad \textnormal{where all } z_i \in \{0,\ldots,q-1\} & \\
\bot & \textnormal{\bf otherwise.}
\end{array} \right.$ 
\end{itemize}

Note: somewhat homomorphic properties: multiplication by constant, additivity. As long as coefficients don't overflow.

\subsection{Coordinate Extraction}

The following protocol enables the prover to extract a commitment to the $i$th component of the vector. Both Prover and Verifier know $i, g, C$. Only the prover knows an integer $z$ such that $g^z = C$ and corresponding to a vector $(a_j)_{j=0}^{d-1}$.
\begin{itemize}
\item Prover computes (or already knows) the $q$-ary expansion of $z$, \emph{i.e.}, $(z_j)_{j=0}^{d-1}$ such that $\sum_{j=0}^{d-1} z_j q^j = z$ and all $z_j \in \{0,\ldots, q-1\}$. He then sends to Verifier:
\begin{itemize}
\item $C_l = g^{\sum_{j=0}^{i-1} z_jq^j}, C_i = g^{z_i}, C_r = g^{\sum_{j=i+1}^{d-1} z_j q^{j-i-1}}$
\item $C_i^{q^i}, C_r^{q^{i+1}}$
\end{itemize}
\item Prover and Verifier run a proof of correct exponentiation to establish that $C_m^{q^i}, C_r^{q^{i+1}}$ were computed correctly.
\item Verifier checks that $C_l \times C_i^{q^i} \times C_r^{q^{i+1}} \stackrel{?}{=} C$ and aborts if false.
\item Prover and Verifier run a range proof to establish that the discrete logarithm of $C_l$ base $g$ is within the range $\{0, \ldots, q^i-1\}$.
\end{itemize}

Correctness, soundness, etc. (todo)

\subsection{Inner Product}
\label{section:inner_product}

The following protocol enables the prover to extract a commitment to the inner product $\mathbf{a}^\mathsf{T} \mathbf{s}$, where $\mathbf{a} = (a_i)_{i=0}^{d-1}$ is the vector to which $C$ is a commitment. The vector $\mathbf{s} \in \ZZ_p^d$ is known to the verifier in the basic protocol, but later on we show how to hide this vector and simultaneously reduce the verifier's running time.
\begin{itemize}
\item Prover and Verifier flip $\mathbf{s}$ to obtain $\bar{\mathbf{s}} = (s_{d-1-i})_{i=0}^{d-1}$ and the matching integer encoding $z_{\bar{\mathbf{s}}} = \sum_{i=0}^{d-1} s_{d-1-i} q^i$.
\item Prover computes $C^{z_{\bar{\mathbf{s}}}}$ and sends this value to the verifier.
\item Prover and Verifier engage in a proof of correct exponentiation.
\item Prover and Verifier extract a commitment to coordinate $d$, which is exactly $\sum_{i=0}^{d-1} a_is_i$ modulo $p$.
\end{itemize}

Correctness, soundness, etc. (todo) Special attention for coefficient size.

Note that the Verifier must process all of $z_{\bar{\mathbf{s}}}$ in order to verify the exponentiation, which in particular is linear in $d$. However, it is possible to reduce this complexity and simultaneously hide the value of $z_{\bar{\mathbf{s}}}$. To do this, the prover must have committed to $z_{\bar{\mathbf{s}}}$ by sending $g^{z_{\bar{\mathbf{s}}}}$ (possibly with respect to a different base). At this point, a batched proof of knowledge of exponent establishes that the discrete logarithms of $C^{z_{\bar{\mathbf{s}}}}$ base $C$ and of $g^{z_{\bar{\mathbf{s}}}}$ base $g$ are equal.

\section{Illustration: QAP-based SNARK}

The next protocol describes an efficiently verifiable proof system for rank-one constraint satisfaction problems. Specifically, we start from a list of $m$ constraints of the form
\begin{equation} \label{equation:r1cs}
    \mathbf{a_i}^\mathsf{T} \mathbf{s} \times \mathbf{b}_i^\mathsf{T} \mathbf{s} = \mathbf{c_i}^\mathsf{T} \mathbf{s} \enspace ,
\end{equation}
where $\mathbf{s} \in \ZZ_p^n$ is the secret witness and the $m$ triples $(\mathbf{a_i}, \mathbf{b_i}, \mathbf{c_i})_{i=0}^{m-1} \in \ZZ_p^{3 \times m \times n}$ are the known parameters that define the constraints. Furthermore, $s_0 = 1$.

Translate this to a quadratic arithmetic program (QAP) by selecting $m$ arbitrary but different elements $\{e_0, \ldots, e_{m-1}\} \subset \ZZ_p$ and defining $\mathbf{a}(X) \in \ZZ^n[X]$ such that $\mathbf{a}(e_i) = \mathbf{a_i}$, and similarly for $\mathbf{b}(X)$ and $\mathbf{c}(X)$. Furthermore, set $h(X) = \prod_{i=0}^{m-1} (X-e_i)$. Then Equation~\ref{equation:r1cs} becomes
\begin{equation} \label{equation:qap_modular}
    \mathbf{a}(X)^\mathsf{T}\mathbf{s} \times \mathbf{b}(X)^\mathsf{T}\mathbf{s} \equiv \mathbf{c}(X)^\mathsf{T}\mathbf{s} \,\, \mathsf{mod} \,\, h(X) \enspace .
\end{equation}
Moreover, a prover knowledgeable of $\mathbf{s}$ can produce another polynomial $t(X)$ such that
\begin{equation} \label{equation:qap_explicit}
    \mathbf{a}(X)^\mathsf{T}\mathbf{s} \times \mathbf{b}(X)^\mathsf{T}\mathbf{s} = \mathbf{c}(X)^\mathsf{T}\mathbf{s} + t(X) \times h(X) \enspace .
\end{equation}

The proof establishes that the prover knows a vector $\mathbf{s}$ and a polynomial $h(X)$ such that Equation~\ref{equation:qap_explicit} is satisfied. Specifically:
\begin{itemize}
    \item Common input to Prover and Verifier: $A = \mathsf{vcom}(\mathbf{a}(X))$, $B = \mathsf{vcom}(\mathbf{b}(X))$, $C = \mathsf{vcom}(\mathbf{c}(X))$, $H = \mathsf{com}(h(X))$, and $D = \mathsf{vcom}((1 \, 0 \, \cdots \, 0)^\mathsf{T})$.
    \item Prover produces commitments $A_\mathbf{s} = \mathsf{com}(\mathbf{a}(X)^\mathsf{T} \mathbf{s})$, and similarly for $B_\mathbf{s}, C_\mathbf{s}$ with the inner product protocol of Section~\ref{section:inner_product}. Additionally, $D_\mathbf{s}$ is computed. All four inner product protocols are performed simultaneously, thereby establishing that the $\mathbf{s}$ used is the same in all four cases.
    \item Prover opens $D_\mathbf{s}$ to $1$, showing that $s_0$ is $1$.
    \item Prover multiplies $t(X)$ into $H$, thereby obtaining $H_t = \mathsf{com}(t(X) \times h(X))$.
    \item Prover and Verifier run a proof of knowledge of exponent.
    \item Prover multiplies $\mathbf{b}(X)^\mathsf{T} \mathbf{s}$ into $A_\mathbf{s}$, thereby obtaining $A_{\mathbf{s}B\mathbf{s}} = \mathsf{com}(\mathbf{a}(X)^\mathsf{T} \mathbf{s} \times \mathbf{b}(X)^\mathsf{T} \mathbf{s})$.
    \item Prover and Verifier run a proof of equal discrete logarithms showing that $A_{\mathbf{s}B\mathbf{s}}$ is to $A_\mathbf{s}$ as $B$ is to $g$.
    \item Verifier selects a random point, $z \sample \ZZ_p$ and sends it to the prover.
    \item Prover and Verifier compute the weighted commitment $K = A_{\mathbf{s}B\mathbf{s}} \times C^{-1} \times H_T^{-1} = \mathsf{com}(\mathbf{a}(X)^\mathsf{T} \mathsf{s} \times \mathbf{b}(X)^\mathsf{T} \mathbf{s} - \mathbf{c}(X)^\mathsf{T} \mathbf{s} - h(X) \times t(X)) = \mathsf{com}(k(X))$
    \item Prover and Verifier run an evaluation proof establishing that $k(z) = 0$.
\end{itemize}

Note: we need to pay special attention to the size of the coefficients of $\mathbf{s}$ and of $t(X)$ are not too big. It is possible that the random selection of $z$ makes the prover who cheats by choosing larger coefficients overwhelmingly unlikely to succeed. Alternatively, we can devise a proof of small coefficients or something like that.
\end{comment}




\if 0 %%Deprecated coefficient extraction and inner product 
\subsection{Coefficient Extraction} \label{section:generic_coefficient_extraction}

Given a polynomial commitment scheme as a black box, one can generate protocol to open the $i$th coefficient of a committed polynomial. Specifically, protocol $\pro{OpenIndex}(\params, c, a, i, d; f(X)) \rightarrow b \in \{0,1\}$ verifies that $a$ is the $i$th coefficient of $f(X)$, which is the polynomial of degree at most $d$ that $c$ commits to.

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{OpenIndex}(\params, c, a, i, d; f(X)):$ \pccomment{$f_i = a$}
		\begin{enumerate}[nolistsep]
		    \item $\prover$ computes $f_L(X) \gets \sum_{j=0}^{i-1} f_jX^j$ and $f_R(X) \gets \sum_{j=i+1}^d f_j X^{j-i-1}$
		    \item \prover computes $c_L \gets \pro{Commit}(\params, f_L(X))$ and $c_R \gets \pro{Commit}(\params, f_R(X))$ and sends these commitments to \verifier
		    \item \verifier samples $\beta \sample \mathbb{F}$ and sends $\beta$ to \prover
		    \item \prover evaluates $y_L \gets f_L(\beta)$ and $y_R \gets f_R(\beta)$ and $y \gets f(\beta)$ and sends $(y, y_L, y_R)$ to \verifier
		    \item \verifier checks that $y = y_L + \beta^{i+1} y_R - \beta^i a$
		    \item \prover and \verifier run $\eval(\params, c_L, \beta, y_L, i-i; L(X))$ and $\eval(\params, c_R, \beta, y_R, d-i; f_R(X))$ and $\eval(\params, c, \beta, y, d; f(X))$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

We can show that if $\pro{Eval}$ has witness-extended emulation, then so does $\pro{OpenIndex}$ as an interactive argument for the relation
\[ 
\mathcal{R_\textsf{Index}}(\params) = \left\{
\langle (c, a, i, d), (f(X), r) \rangle
: 
\begin{array}{l} 
f \in R[X] \ \text{has degree at most} \ d \ \text{with} \ f_i = a \\ 
 \text{and} \ \pro{Open}(\params, c, f(X), r) = 1 \\
\end{array}
\right\} \enspace .
\] 

\begin{lemma} 
If $\pro{Eval}$ is an interactive argument for $\mathcal{R_\textsf{Eval}}(\params)$ with witness-extended emulation then $\pro{OpenIndex}$ is an interactive argument for $\mathcal{R_\textsf{Index}}(\params)$ with witness-extended emulation. 
\end{lemma}

\begin{proof}[Proof sketch]
Let $E_{\eval}$ be an emulator for $\pro{Eval}$. We construct an emulator $E$ for $\pro{OpenIndex}$ that makes calls to $E_{\eval}$. At a high level, $E$ will invoke $E_{\eval}$ in order to extract witness polynomials $f_R(X)$, $f_L(X)$, $f(X)$ of appropriate degrees from the respective successful executions of $\pro{Eval}$ and also piece together a consistent emulation transcript. We then argue that if $f(X) - a X^i \neq X^{i+1} f_R(X) + f_L(X)$, then the evaluation binding of the polynomial commitment $\eval$ is broken. $E$ could rewind the protocol to the second step after receiving commitments $c, c_R, c_L$ and rerun on a fresh challenge $\beta' \leftarrow_R \mathbb{F}$, doing this until it gets another accepting transcript (in expected polynomial time) with succesful openings of $f(\beta') = y'$, $f_L(\beta') = y'_L$, and $f_R(\beta') = y'_R$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta^i \bmod p$. Yet, $f(\beta') - a X^i \neq X^{i+1} f_R(\beta') + f_L(\beta')$ except with probability $\poly / |\mathbb{F}|$ (union bound over the $\poly$ rewindings), which implies that one of the claimed evaluations was incorrect. The full proof is in the appendix. 

\ben{TODO move to appendix}

Given adversarial prover $P^*$ and transcript oracle $\pro{Record}(P^*, \params, (c, a, i, d), \st)$, $E$ does the following: 

\begin{itemize} 
\item Run $\pro{Record}$ from the start until the first $\pro{Eval}$. $E$ obtains a transcript containing $c, c_R, c_L, y, y_R, y_L$ and $\beta$. 

\item Invoke $E_{\eval}$ by simulating its transcript oracle $\pro{Record}(P^*, \params, c, \beta, y, d, \st)$. ($E$ simulates this transcript oracle for $E_{\eval}$ by consulting its own transcript oracle, which is running $\eval$ as a subprotocol). $E_{\eval}$ returns an output $(\tr_1, f^*)$, and w.l.o.g. interpret $f^*$ as giving a canonical encoding of an integer polynomial $f^*(X)$. Do the same for the subprotocol $\eval$ executions on $(c_R, \beta, y_R, d - i - 1)$ and $(c_L, \beta, y_L, i-1)$ respectively, which returns $(\tr_2, f_L^*)$ and $(\tr_3, f_R^*)$. 

\item Piece together the transcript obtained from running $\pro{Record}$ in the first step (i.e. up until the first $\eval$ together with the transcripts $\tr_1, \tr_2, \tr_3$ into a complete transcript $\tr^*$. This $\tr$ is an ``accepting transcript" if and only if the verifier in the last step would output $1$. 

\item Output $(\tr^*, f^*)$.  
\end{itemize}

We now argue that for any PPT $\mathcal{A}$ and $\params \leftarrow \pro{Setup}(1^\lambda)$, if the experiment sampling $(X, \st) \leftarrow \mathcal{A}(\params)$ and $\tr \leftarrow \pro{Record}(P^*, \params, x, \st)$, where $x$ is a tuple of the form $(c, a, i, d)$, produces an ``accepting transcript" $\tr$ with probability $\delta$, then the modified experiment that samples $(\tr^*, f^*) \leftarrow E^{\textsf{Record}(P^*, \params, x, \st)}(\params, x)$ returns an $f^*$ such that $((c, a, i, d), f^*) \in \mathcal{R_\textsf{Index}}(\params)$ with probability $\delta - \negl$. 

If $\delta$ is negligible the claim holds trivially. For now on assume that $\delta$ is non-negligible. 
The fact that $\tr$ is an accepting transcript with probability $\delta$ implies that each $\eval$ subprotocol generates accepting transcripts with probability at least $\delta$. Therefore, by the hypothesis that $\eval$ has witness-extended emulation, if each of the subprotocol transcripts $\tr_1$, $\tr_2$, $\tr_3$ are accepting then with probability $\delta - \negl$: subprotocol witnesses $f^*, f_L^*$ and $f_R^*$ are all valid $\mathcal{R_\textsf{Eval}}(\params)$ witnesses for $(c, \beta, y, d)$, $(c_L, \beta, y_L, i-1)$, and $(c_R, \beta, y_R, d - i - 1)$ respectively. 

We have already shown that the extracted polynomial $f^*(X)$ is valid for $c$ with probability $\delta - \negl$. As a final step, suppose towards contradiction that $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$. Since $\delta$ is non-negligible, $E$ can rewind the transcript oracle to Step 2 (i.e. after receiving the commitments $c, c_L, c_R$), restarting the protocol from this point on a fresh verifier challenge $\beta' \leftarrow_R \mathbb{F}$. It does this until (in expected polynomial time) it finds a $\beta'$ that produces an accepting transcript, which includes $y', y_L', y_R'$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta'^i \bmod p$.

The probability that $f_L^*(\beta') + \beta'^i f_R^*(\beta') = f^*(\beta') - a \beta'^i$ is less than $\poly / |\mathbb{F}|$ (the $\poly$ numerator comes from union bound over number of rewindings). In this case, either $y' \neq f^*(\beta')$ or $y_L' \neq f^*_L(\beta')$ or $y_R' \neq f^*_R(\beta')$. Yet, $\eval$ passes on all three, which contradicts the evaluation binding property of $\eval$. Hence, we conclude that except with $\negl$ probability $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$, and thus $f^*_i = a$. 

\end{proof}

\subsection{Inner Product}

Using the $\pro{Reverse}$ and $\pro{OpenIndex}$ protocols as subprotocols, it is straightforward to construct a protocol to prove that a given scalar is the inner product of the coefficient vectors of two committed polynomiails. To see this, observe that if $\bar{g}(X)$ is the polynomial with the same coefficients as $g(X)$ but in reverse order, and if both $\bar{g}(X)$ and $f(X)$ have degree $d$, then the coefficient of the monomial $X^d$ in the polynomial $f(X) \cdot \bar{g}(X)$ is exactly the inner product between $\mathbf{f}$ and $\mathbf{g}$. This gives rise to the protocol $\pro{InnerProduct}(\params, \gr{C}_{f}, \gr{C}_{\bar{g}}, a; {f}(X), {\bar{g}}(X)) \rightarrow b \in \{0,1\}$, which proves that $a = \langle \mathbf{f}, \mathbf{g} \rangle$. Note that this protocol assumes that $\gr{C}_{\bar{g}}$ is a commitment to the polynomial $\bar{g}(X)$, which has the same coefficients as $g(X)$ but in reverse order. Protocol $\pro{Reverse}$ can be used to establish that two commitments $\gr{C}_g$ and $\gr{C}_{\bar{g}}$ represent two polynomials with the same coefficients but in reversed order.

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{InnerProduct}(\params, \gr{C}_{{f}}, \gr{C}_{\bar{g}}, a; f(X), \bar{g}(X)):$ 
		\begin{enumerate}[nolistsep]
		    \item $\prover$ computes $h(X) \gets f(X) \cdot \bar{g}(X)$ and $(\gr{C}_h; r_h) \gets \pro{Commit}(\params, h(X))$
		    \item \prover sends $\gr{C}_h$ to \verifier
		    \item \verifier samples $z \sample \mathbb{Z}_p$ and sends $z$ to \prover
		    \item \prover computes $y_f \gets f(z)$ and $y_{\bar{g}} \gets \bar{g}(z)$ and $y_h \gets h(z)$ and sends $(y_f, y_{\bar{g}}, y_h)$ to \verifier
		    \item \prover and \verifier run $\pro{Eval}(\params, \gr{C}_f, z, y_f, d; f(X))$ and $\pro{Eval}(\params, \gr{C}_{\bar{g}}, z, y_{\bar{g}}, d; \bar{g}(X))$ and $\pro{Eval}(\params, \gr{C}_h, z, y_f, d; h(X))$
		    \item \verifier checks that $y_f \cdot y_{\bar{g}} = y_h$
		    \item \prover and \verifier run $\pro{OpenIndex}(\params, \gr{C}_h, a, d; h(X))$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\begin{lemma}
    Protocol $\pro{InnerProduct}$ is an argument of knowledge for the relation
\[\mathcal{R}_\mathsf{IP}(\params) = \left\{
    \langle(\gr{C}_{f}, \gr{C}_{\bar{g}}, a), ({f}(X), \bar{g}, r_f, r_{\bar{g}})\rangle \ : \     \begin{array}{l}
            \mathbf{f}, \mathbf{\bar{g}} \in \mathbb{Z}_p^{d+1} \\
            \langle \mathbf{f}, \mathbf{g} \rangle = a \\
            \pro{Open}(\params, \gr{C}_{f}, {f}(X), r_f) = 1 \\
            \pro{Open}(\params, \gr{C}_{\bar{g}}, {\bar{g}}(X), r_{\bar{g}}) = 1
        \end{array}
    \right\} \enspace .
\]
\end{lemma}

\begin{proof}
Full version / appendix.
\end{proof}
\fi 
