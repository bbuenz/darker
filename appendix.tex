\if 0 
\section{Deprecated witness extended emulation for OpenIndex queries} 

We can show that if $\pro{Eval}$ has witness-extended emulation, then so does $\pro{OpenIndex}$ as an interactive argument for the relation: 

\[ 
\mathcal{R_\textsf{Index}}(\params) = \left\{
\langle (c, a, i, d), (f(X), r) \rangle
: 
\begin{array}{l} 
f \in R[X] \ \text{has degree at most} \ d \ \text{with} \ f_i = a \\ 
 \text{and} \ \pro{Open}(\params, c, f(X), r) = 1 \\
\end{array}
\right\}
\] 


\begin{lemma} 
If $\pro{Eval}$ is an interactive argument for $\mathcal{R_\textsf{Eval}}(\params)$ with witness-extended emulation then $\pro{OpenIndex}$ is an interactive argument for $\mathcal{R_\textsf{Index}}(\params)$ with witness-extended emulation. 
\end{lemma}

\begin{proof}[Proof sketch]
Let $E_{\eval}$ be an emulator for $\pro{Eval}$. We construct an emulator $E$ for $\pro{OpenIndex}$ that makes calls to $E_{\eval}$. At a high level, $E$ will invoke $E_{\eval}$ in order to extract witness polynomials $f_R(X)$, $f_L(X)$, $f(X)$ of appropriate degrees from the respective successful executions of $\pro{Eval}$ and also piece together a consistent emulation transcript. We then argue that if $f(X) - a X^i \neq X^{i+1} f_R(X) + f_L(X)$, then the evaluation binding of the polynomial commitment $\eval$ is broken. $E$ could rewind the protocol to the second step after receiving commitments $c, c_R, c_L$ and rerun on a fresh challenge $\beta' \leftarrow_R \FF$, doing this until it gets another accepting transcript (in expected polynomial time) with succesful openings of $f(\beta') = y'$, $f_L(\beta') = y'_L$, and $f_R(\beta') = y'_R$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta^i \bmod p$. Yet, $f(\beta') - a X^i \neq X^{i+1} f_R(\beta') + f_L(\beta')$ except with probability $\poly / |\FF|$ (union bound over the $\poly$ rewindings), which implies that one of the claimed evaluations was incorrect. The full proof is in the appendix. 

\ben{TODO move to appendix}

Given adversarial prover $P^*$ and transcript oracle $\pro{Record}(P^*, \params, (c, a, i, d), \st)$, $E$ does the following: 

\begin{itemize} 
\item Run $\pro{Record}$ from the start until the first $\pro{Eval}$. $E$ obtains a transcript containing $c, c_R, c_L, y, y_R, y_L$ and $\beta$. 

\item Invoke $E_{\eval}$ by simulating its transcript oracle $\pro{Record}(P^*, \params, c, \beta, y, d, \st)$. ($E$ simulates this transcript oracle for $E_{\eval}$ by consulting its own transcript oracle, which is running $\eval$ as a subprotocol). $E_{\eval}$ returns an output $(\tr_1, f^*)$, and w.l.o.g. interpret $f^*$ as giving a canonical encoding of an integer polynomial $f^*(X)$. Do the same for the subprotocol $\eval$ executions on $(c_R, \beta, y_R, d - i - 1)$ and $(c_L, \beta, y_L, i-1)$ respectively, which returns $(\tr_2, f_L^*)$ and $(\tr_3, f_R^*)$. 

\item Piece together the transcript obtained from running $\pro{Record}$ in the first step (i.e. up until the first $\eval$ together with the transcripts $\tr_1, \tr_2, \tr_3$ into a complete transcript $\tr^*$. This $\tr$ is an ``accepting transcript" if and only if the verifier in the last step would output $1$. 

\item Output $(\tr^*, f^*)$.  
\end{itemize}

We now argue that for any PPT $\mathcal{A}$ and $\params \leftarrow \pro{Setup}(1^\lambda)$, if the experiment sampling $(X, \st) \leftarrow \mathcal{A}(\params)$ and $\tr \leftarrow \pro{Record}(P^*, \params, x, \st)$, where $x$ is a tuple of the form $(c, a, i, d)$, produces an ``accepting transcript" $\tr$ with probability $\delta$, then the modified experiment that samples $(\tr^*, f^*) \leftarrow E^{\textsf{Record}(P^*, \params, x, \st)}(\params, x)$ returns an $f^*$ such that $((c, a, i, d), f^*) \in \mathcal{R_\textsf{Index}}(\params)$ with probability $\delta - \negl$. 

If $\delta$ is negligible the claim holds trivially. For now on assume that $\delta$ is non-negligible. 
The fact that $\tr$ is an accepting transcript with probability $\delta$ implies that each $\eval$ subprotocol generates accepting transcripts with probability at least $\delta$. Therefore, by the hypothesis that $\eval$ has witness-extended emulation, if each of the subprotocol transcripts $\tr_1$, $\tr_2$, $\tr_3$ are accepting then with probability $\delta - \negl$: subprotocol witnesses $f^*, f_L^*$ and $f_R^*$ are all valid $\mathcal{R_\textsf{Eval}}(\params)$ witnesses for $(c, \beta, y, d)$, $(c_L, \beta, y_L, i-1)$, and $(c_R, \beta, y_R, d - i - 1)$ respectively. 

We have already shown that the extracted polynomial $f^*(X)$ is valid for $c$ with probability $\delta - \negl$. As a final step, suppose towards contradiction that $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$. Since $\delta$ is non-negligible, $E$ can rewind the transcript oracle to Step 2 (i.e. after receiving the commitments $c, c_L, c_R$), restarting the protocol from this point on a fresh verifier challenge $\beta' \leftarrow_R \FF$. It does this until (in expected polynomial time) it finds a $\beta'$ that produces an accepting transcript, which includes $y', y_L', y_R'$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta'^i \bmod p$.

The probability that $f_L^*(\beta') + \beta'^i f_R^*(\beta') = f^*(\beta') - a \beta'^i$ is less than $\poly / |\FF|$ (the $\poly$ numerator comes from union bound over number of rewindings). In this case, either $y' \neq f^*(\beta')$ or $y_L' \neq f^*_L(\beta')$ or $y_R' \neq f^*_R(\beta')$. Yet, $\eval$ passes on all three, which contradicts the evaluation binding property of $\eval$. Hence, we conclude that except with $\negl$ probability $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$, and thus $f^*_i = a$. 

\end{proof}
\fi 


\if 0 %%Deprecated discussion of vector commitments 
\subsection{Vector Commitments}

A commitment to a polynomial is a commitment to a list of coefficients, and the ability to extract any indicated coefficient from a polynomial commitment effectively upgrades the scheme to a vector commitment scheme. While it is possible to extract an indicated coefficient using only a polynomial commitment scheme (see Section~\ref{section:generic_coefficient_extraction} for a demonstration of this fact), it is possible to achieve this task much more efficiently by exploiting the homomorphic properties of our commitment scheme. For the following description we will identify polynomials $f(X)$ with their coefficient vectors $\mathbf{f}$ and vice versa, and we will switch between notations whenever it is convenient.

We achieve this task in two steps. Protocol $\pro{ExtractCoefficient}(\params, \gr{C}, i, \gr{C}_a; \mathbf{f}) \rightarrow b \in \{0,1\}$ validates that a given commitment really is a commitment to an indicated coefficient of a vector commitment. Next, Protocol $\pro{OpenIndex}$ uses this as a subprotocol to realize the syntax defined in the preliminaries (Section~\ref{subsection:openindex}). 

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{ExtractCoefficient}(\params, \gr{C}, i, \gr{C}_a; \mathbf{f}):$ \pccomment{$\mathbf{f} = (f_0, \ldots, f_d)^\mathsf{T} \in \ZZ^{d+1}$ and $a = f_i$}
		\begin{enumerate}[nolistsep]
		    \item \prover computes $f_L(X) \gets \sum_{j=0}^{i-1} f_j X^j$ and $f_R \gets \sum_{j=i+1}^d f_j X^{j-i-1}$
		    \item \prover computes $\gr{C}_L \gets \gr{g}^{f_L(q)}$, and $\gr{C}_R \gets \gr{g}^{f_R(q)}$
		    \item \prover computes $\gr{C}_a' \gets \gr{C}_a^{q^i}$ and $\gr{C}_R' \gets \gr{C}_R^{q^{i+1}}$
		    \item \prover sends $\gr{C}_L, \gr{C}_a', \gr{C}_R$ to \verifier
		    \item \verifier computes $\gr{C}_R' \gets \gr{C} \gr{C}_L^{-1} {\gr{C}_a'}^{-1}$
		    \item \prover and \verifier run $\pro{PoE}(\gr{C}_a, \gr{C}_a', q^i)$ and $\pro{PoE}(\gr{C}_R, \gr{C}_R', q^{i+1})$
		    \item \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}_L, z, f_L(z), i-1, b; f_L(X))$ for an arbitrary $z$ and any $b$ such that $\max_j f_j \leq b \ll q$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\textit{Note.} Instead of line 7, \prover and \verifier might as well run any range proof that establishes that $\gr{C}_L$ is a commitment to an integer smaller than $q^i$ in absolute value.

\begin{lemma}
    Protocol $\pro{ExtractCoefficient}$ has witness-extended emulation for the relation
    \[
        \mathcal{R}_\mathsf{EC}(\params) = \left\{
            \langle(\gr{C}, i, \gr{C}_a), (\mathbf{f}, r_f, r_a)\rangle \ : \ \begin{array}{l}
                 \mathbf{f} = (f_0, \ldots, f_d)^\mathsf{T} \in \mathbb{Z}_p^{d+1} \\
                 \pro{Open}(\params, \gr{C}, \mathbf{f}, r_f) = 1 \\
                 \pro{Open}(\params, \gr{C}_a, f_i, r_a) = 1
            \end{array}
        \right \} \enspace .
    \]
\end{lemma}
\begin{proof}
Full version/appendix.
\end{proof}

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{OpenIndex}(\params, \gr{C}, a, i; \mathbf{f}):$ \pccomment{$\mathbf{f} \in \ZZ_p^{d+1}$}
		\begin{enumerate}[nolistsep]
		    \item \prover computes $\gr{C}_a \gets \gr{c}^{f_i}$ and sends it to \verifier
		    \item \prover and \verifier run $\pro{ExtractCoefficient}(\params, \gr{C}, i, \gr{C}_a; \mathbf{f})$
		    \item \prover and \verifier run $\pro{Open}(\params, \gr{C}_a, a; f_i)$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\begin{lemma}
    Protocol $\pro{OpenIndex}$ has witness-extended emulation for the relation
    \[
        \mathcal{R}_\mathsf{Index}(\params) = \left\{
            \langle(\gr{C}, a, i, d), (\mathbf{f}, r_f)\rangle \ : \ \begin{array}{l}
                \mathbf{f} = (f_0, \ldots, f_d)^\mathsf{T} \in \mathbb{Z}_p^{d+1} \\
                f_i = a \\
                \pro{Open}(\params, \gr{C}, \mathbf{f}, r_f) = 1
            \end{array}
        \right\} \enspace .
    \]
\end{lemma}

\begin{proof}
Full version/appendix.
\end{proof}
\fi 

\if 0 %%Deprecated discussion of inner products 
\subsection{Inner Products}

The polynomial commitment scheme has a multiplicative homomorphism. Specifically, let $f(X), g(X) \in \ZZ_p[X]$ and let $\gr{C}$ be a commitment to $f(X)$. Then, provided that $q$ is large enough to prevent overflow, $\gr{C}^{g(q)}$ is a commitment to $f(X) \times g(X)$. This feature is particularly useful in the context of vector commitments where the goal is to extract not an indicated coefficient but a linear combination of all coefficients. To see how this might work, consider the coefficient vectors $\mathbf{f} = (f_0, \ldots, f_{d})$ and $\mathbf{g} = (g_0, \ldots, g_d)$. Then $\gr{C}$ is simultaneously a vector commitment to $\mathbf{f}$, and raising this commitment to %the integer encoding of the reciprocal of $g(X)$
the power $\sum_{i=0}^d g_{d-i} q^i$
gives a commitment to a new vector whose middle coefficient contains the inner product $\langle \mathbf{f}, \mathbf{g} \rangle$. To see this, consider the logarithm of $\gr{C}^{\sum\limits_{i=0}^{d} g_{d-i} q^i}$ base $\gr{g}$:
\begin{flalign*}
\left( \sum\limits_{i=0}^d f_i q^i \right) \left( \sum\limits_{i=0}^d g_{d-i} q^i \right) = \sum\limits_{i=0}^d \sum\limits_{j=0}^d f_i g_j q^{d-j+i} = q^d \sum_{i=0}^d f_i g_i \ + o(q^{d+1}) + \omega(q^{d-1}) \enspace .
\end{flalign*}

We use this property to realize protocols for extracting inner products. A minor issue is that the right hand vector commitment must represent the coefficients in reversed order. To circumvent this obstacle we denote by $\mathbf{\bar{g}}$ the vector $\mathbf{g}$ but with its coefficients reversed. For applications where this issue cannot be solved with notational cleverness, Appendix \textbf{[todo]} presents a protocol to establish that two vector commitments represent the same coefficients but in reversed order. 

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{InnerProduct}(\params, \gr{C}_\mathbf{f}, \gr{C}_\mathbf{\bar{g}}, a; \mathbf{f}, \mathbf{\bar{g}}):$ \pccomment{$\mathbf{f}, \mathbf{\bar{g}} \in \ZZ^{d+1}$ and $\gr{C}_\mathbf{\bar{g}} = \gr{g}^{\sum_{i=0}^d g_{d-i} q^i}$}
		\begin{enumerate}[nolistsep]
		    \item \prover computes $\gr{C}_h \gets \gr{C}_\mathbf{f}^{\sum_{i=0}^{d} g_{d-i} q^i}$ and sends it to \verifier
		    \item \verifier samples $z \sample \mathbb{Z}_p$ and sends it to \prover
		    \item \prover computes $h(X) \gets \left(\sum_{i=0}^d f_i X^i\right) \left(\sum_{i=0}^d g_{d-i} X^i\right)$
		    \item \prover computes $y_f \gets f(z)$, $y_g \gets g(z)$, and $y_h \gets h(z)$ and sends $(y_f, y_g, y_h)$ to \verifier
		    \item \verifier checks that $y_h = y_f \times y_g$
		    \item \verifier samples $\beta, \gamma \sample \mathbb{Z}_p$ and sends $(\beta, \gamma)$ to \prover
		    \item \prover computes $\gr{C}' \gets (\gr{C}_\mathbf{f}^\beta \gr{C}_\mathbf{g}^\gamma)^{q^{d-1}}$ and sends $\gr{C}'$ to \verifier
		    \item \prover and \verifier run $\pro{PoE}(\gr{C}_\mathbf{f}^\beta \gr{C}_\mathbf{g}^\gamma, \gr{C}', q^{d-1})$
		    \item \prover and \verifier run $\pro{Eval}(\gr{C}'\gr{C}_h^{-1}, z, {\beta{} z^{d-1} y_f + \gamma{} z^{d-1} y_g - y_h} , {2d-1} ;$ ${\beta{} X^{d-1} f(X) + \gamma{} X^{d-1} g(X) - h(X)})$
		    \item \prover computes $\gr{C}_a \leftarrow \gr{g}^{h_d}$
		    \item \prover and \verifier run $\pro{ExtractCoefficient}(\params, \gr{C}_h, d, \gr{C}_a; h(X))$
		    \item \prover and \verifier run $\pro{Open}(\params, \gr{C}_a, a, h_d)$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\begin{lemma}
    The protocol $\pro{InnerProduct}$ has witness-extended emulation for the relation
\[\mathcal{R}_\mathsf{IP}(\params) = \left\{
    \langle(\gr{C}_\mathbf{f}, \gr{C}_\mathbf{\bar{g}}, a), (\mathbf{f}, \mathbf{\bar{g}}, r_f, r_g)\rangle \ : \     \begin{array}{l}
            \mathbf{f}, \mathbf{\bar{g}} \in \mathbb{Z}_p^{d+1} \\
            \langle \mathbf{f}, \mathbf{g} \rangle = a \\
            \pro{Open}(\params, \gr{C}_\mathbf{f}, \mathbf{f}, r_f) = 1 \\
            \pro{Open}(\params, \gr{C}_\mathbf{\bar{g}}, \mathbf{\bar{g}}, r_g) = 1
        \end{array}
    \right\} \enspace .
\]
\end{lemma}

\begin{proof}
In the full version of the paper.
\end{proof}
\fi 

\section{Proof of Theorem~\ref{thm:dyadicpolysecurity}}
\label{apx:dyadic}
We begin by stating and proving the combining lemma, (Lemma~\ref{lem:intrandomcombine}) for dyadic rational witnesses.
%PROOF FOR DYADIC RATIONALS
\begin{lemma}[Combining for Dyadic Rational Witnesses]
\label{lem:dyadiccombining}
Let $\tr$ and $\tr'$ be two transcripts as specified in Lemma \ref{lem:intrandomcombine} with the difference that $f,f'\in \mathbb{D}$ are dyadic rationals such that $f(X)\gets \dec(f)$ and $f'(X)\gets \dec(f')$ are degree $d$ bounded dyadic rational polynomials with coefficients' numerators bounded by $N$ and denominators bounded by $D$, i.e. $f(X),f'(X)\in\mathbb{D}(N,D)$.
Assume that there exists a PPT algorithm for taking square roots of any element in $\GG$ and that the order of $\GG$ is odd, then there exists a PPT algorithm $\mathcal{X}$ that given these transcripts computes either (1) $y_L,y_R\in \ZZ_p,f_L(X),f_R(X)\in \mathbb{D}(N\cdot (p-1),D\cdot (p-1))[X]$  such that $f_L(z)=y_L\bmod p$ and $f_R(z)=y_R \bmod p$ or (2) an element in $\GG$ of known order or (3) a non-dyadic root of $\gr{g}$.
\end{lemma}
\begin{proof}
The proof follows a similar structure to the proof of Lemma~\ref{lem:intrandomcombine}. 
		
	Using the transcripts we get $\Delta_\alpha\gets\alpha-\alpha'$ and $\Delta_f\gets f-f'$ such that $\gr{C}_{L}^{\Delta_\alpha}=\gr{g}^{\Delta_f}$. 
 If $\frac{\Delta_f}{\Delta_\alpha}$ is not a dyadic rational then this gives us a non-dyadic root of $\gr{g}$, that is the tuple $(\Delta_f,\Delta_\alpha,\gr{C}_{L})$.  
 If $\frac{\Delta_f}{\Delta_\alpha}$ on the other hand is a dyadic rational then we can compute $\gr{D}\gets\gr{g}^{\frac{\Delta_f}{\Delta_\alpha}}$. This may requires taking a power of $2$ root. By assumption the group order is odd, so every element has a square root and there exists an efficient algorithm for taking square roots. This implies that taking higher power of $2$ roots is also efficient.
  
  Now either $\gr{D} = \gr{C}_L=\gr{g}^{f_L}$ or we can extract an element of known order. Additionally $\gr{C}_R=\gr{g}^{f_R}$ for $f_R\gets f-\alpha \cdot f_L$.

 We now compute the corresponding polynomials $f_L(X)\gets \dec(f_L)$ and $f_R(X)\gets \dec(f_R)$.
Now if the coefficients $f_i$ and $f'_i\in \mathbb{D}(N,D)$ and $\alpha,\alpha' \in [-\frac{p-1}{2},\frac{p-1}{2}]$ then by the triangle inequality we have that for the numberator of the $i$th coefficient of $f_L(X)$ is between $[-2N,2N]$. The denominator grows by at most $p-1$. The bound on the denominators is therefore $D\cdot (p-1)$. Additionally we have $f_{R,i}=\frac{f_i'\alpha-f_i \alpha'}{\Delta_\alpha}$. Using the triangle inequality again we have that the numerator of $f_{R,i} \in [-(p-1) \cdot N, (p-1) \cdot N]$. The denominator is bounded by $D\cdot (p-1)$. This gives us $f_L(X),f_R(X)\in \mathbb{D}((p-1) \cdot N,D\cdot (p-1))[X]$

Finally $y_L=f_L(z)$ and $y_R=f_R(z)$ as in Lemma~\ref{lem:intrandomcombine}. It is important that $2$ is co-prime with the odd prime $p$ such that each dyadic rational can be mapped to a field element.

\end{proof}
We now restate the theorem for the security of the protocol with dyadic rational witnesses in groups where taking square roots is easy.
\dyadicmain*
\begin{proof}
The proof largely follows the same structure of the proof of Theorem~\ref{thm:polycommitsecurity}.
	
We will prove security by showing that we can extract a dyadic rational polynomial $f(X)\in \\mathbb{Z}[X]$ such that $f(X)$ has degree at most $d$ and the coefficients of $f(X)$ are dyadic rationals such that the product of the numerator and denominator is bounded by $q/2$. This ensures that $f(q)$ is a unique encoding of $f(X)$. Additionally $\gr{g}^{f(q)}=\gr{C}$ and $f(z) \bmod p=y$. The proof will use the general forking lemma (Lemma \ref{lemma:GFL}) to show that the polynomial commitment scheme has witness-extended emulation. 

We use the same extractor $\mathcal{X}$ as in Theorem \ref{thm:polycommitsecurity} with one key distinction. 
For $d+1$ odd we invoke the extractor described by Lemma~\ref{lem:dyadiccombining} instead of Lemma~\ref{lem:intrandomcombine}. 
This means that at every tree level either bounded dyadic rational witness polynomials are extracted or an element of known order or a non-dyadic root of $\gr{g}$. By assumption the ladder two cases happen only with negligible probability.

We, therefore, now need to compute a bound on the size of the extracted polynomial. 
The check on $f$ ensures that $f\in \ZZ$ and that $|f|\leq b=\frac{(p-1)}{2} (\frac{p+1}{2})^{\lceil \log_2(d+1)\rceil}$. We can write $f\in\mathbb{D}(\frac{(p-1)}{2} (\frac{p+1}{2})^{\lceil \log_2(d+1)\rceil},1)$. By \ref{lem:intrandomcombine} both the numerator and the denominator grow by at most a factor $p-1$ in every round.
Given that the transcript tree has depth $\lceil \log_2(d+1)\rceil$ we get that the final extracted polynomial $f_0(X)\in \mathbb{D}(N,D)[X]$ has coefficients with numerators bounded by $N= \frac{p-1}{2}(\frac{p^2-1}{2})^{\lceil \log_2(d+1)\rceil}$ and denominators bounded by $D=(p-1)^{\lceil \log_2(d+1)\rceil}$

$q$ needs to be large enough such that $f_0(X)$ is uniquely decodable, \emph{i.e.}, $q>2\cdot N\cdot b=(p-1)^{\lceil \log_2(d+1)\rceil+1}(\frac{p^2-1}{2})^{\lceil \log_2(d+1)\rceil}$.

This shows that we can successfully extract either a witness or a non-dyadic root or an element of known order from any tree of valid transcripts.
Under the Non-Dyadic Root Assumption and the Order Assumption, the probability that a polynomial time adversary along with a polynomial time extractor $\mathcal{X}$ can produce such a non-dyadic root or an element of known order is negligible. $\eval'$, therefore, has witness extended emulation and under the Adaptive Root Assumption by Lemma \ref{lemma:poe_security} so does $\eval$.
Lemma \ref{lem:ordertoadaptive} and Lemma \ref{lem:dyadicstrongtorational} show that we can reduce the hardness assumptions to just the Adaptive Root Assumption and the Dyadic Strong RSA Assumption.
\end{proof}



















\if 0 %%Deprecated coefficient extraction and inner product 
\subsection{Coefficient Extraction} \label{section:generic_coefficient_extraction}

Given a polynomial commitment scheme as a black box, one can generate protocol to open the $i$th coefficient of a committed polynomial. Specifically, protocol $\pro{OpenIndex}(\params, c, a, i, d; f(X)) \rightarrow b \in \{0,1\}$ verifies that $a$ is the $i$th coefficient of $f(X)$, which is the polynomial of degree at most $d$ that $c$ commits to.

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{OpenIndex}(\params, c, a, i, d; f(X)):$ \pccomment{$f_i = a$}
		\begin{enumerate}[nolistsep]
		    \item $\prover$ computes $f_L(X) \gets \sum_{j=0}^{i-1} f_jX^j$ and $f_R(X) \gets \sum_{j=i+1}^d f_j X^{j-i-1}$
		    \item \prover computes $c_L \gets \pro{Commit}(\params, f_L(X))$ and $c_R \gets \pro{Commit}(\params, f_R(X))$ and sends these commitments to \verifier
		    \item \verifier samples $\beta \sample \mathbb{F}$ and sends $\beta$ to \prover
		    \item \prover evaluates $y_L \gets f_L(\beta)$ and $y_R \gets f_R(\beta)$ and $y \gets f(\beta)$ and sends $(y, y_L, y_R)$ to \verifier
		    \item \verifier checks that $y = y_L + \beta^{i+1} y_R - \beta^i a$
		    \item \prover and \verifier run $\eval(\params, c_L, \beta, y_L, i-i; L(X))$ and $\eval(\params, c_R, \beta, y_R, d-i; f_R(X))$ and $\eval(\params, c, \beta, y, d; f(X))$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

We can show that if $\pro{Eval}$ has witness-extended emulation, then so does $\pro{OpenIndex}$ as an interactive argument for the relation
\[ 
\mathcal{R_\textsf{Index}}(\params) = \left\{
\langle (c, a, i, d), (f(X), r) \rangle
: 
\begin{array}{l} 
f \in R[X] \ \text{has degree at most} \ d \ \text{with} \ f_i = a \\ 
 \text{and} \ \pro{Open}(\params, c, f(X), r) = 1 \\
\end{array}
\right\} \enspace .
\] 

\begin{lemma} 
If $\pro{Eval}$ is an interactive argument for $\mathcal{R_\textsf{Eval}}(\params)$ with witness-extended emulation then $\pro{OpenIndex}$ is an interactive argument for $\mathcal{R_\textsf{Index}}(\params)$ with witness-extended emulation. 
\end{lemma}

\begin{proof}[Proof sketch]
Let $E_{\eval}$ be an emulator for $\pro{Eval}$. We construct an emulator $E$ for $\pro{OpenIndex}$ that makes calls to $E_{\eval}$. At a high level, $E$ will invoke $E_{\eval}$ in order to extract witness polynomials $f_R(X)$, $f_L(X)$, $f(X)$ of appropriate degrees from the respective successful executions of $\pro{Eval}$ and also piece together a consistent emulation transcript. We then argue that if $f(X) - a X^i \neq X^{i+1} f_R(X) + f_L(X)$, then the evaluation binding of the polynomial commitment $\eval$ is broken. $E$ could rewind the protocol to the second step after receiving commitments $c, c_R, c_L$ and rerun on a fresh challenge $\beta' \leftarrow_R \mathbb{F}$, doing this until it gets another accepting transcript (in expected polynomial time) with succesful openings of $f(\beta') = y'$, $f_L(\beta') = y'_L$, and $f_R(\beta') = y'_R$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta^i \bmod p$. Yet, $f(\beta') - a X^i \neq X^{i+1} f_R(\beta') + f_L(\beta')$ except with probability $\poly / |\mathbb{F}|$ (union bound over the $\poly$ rewindings), which implies that one of the claimed evaluations was incorrect. The full proof is in the appendix. 

\ben{TODO move to appendix}

Given adversarial prover $P^*$ and transcript oracle $\pro{Record}(P^*, \params, (c, a, i, d), \st)$, $E$ does the following: 

\begin{itemize} 
\item Run $\pro{Record}$ from the start until the first $\pro{Eval}$. $E$ obtains a transcript containing $c, c_R, c_L, y, y_R, y_L$ and $\beta$. 

\item Invoke $E_{\eval}$ by simulating its transcript oracle $\pro{Record}(P^*, \params, c, \beta, y, d, \st)$. ($E$ simulates this transcript oracle for $E_{\eval}$ by consulting its own transcript oracle, which is running $\eval$ as a subprotocol). $E_{\eval}$ returns an output $(\tr_1, f^*)$, and w.l.o.g. interpret $f^*$ as giving a canonical encoding of an integer polynomial $f^*(X)$. Do the same for the subprotocol $\eval$ executions on $(c_R, \beta, y_R, d - i - 1)$ and $(c_L, \beta, y_L, i-1)$ respectively, which returns $(\tr_2, f_L^*)$ and $(\tr_3, f_R^*)$. 

\item Piece together the transcript obtained from running $\pro{Record}$ in the first step (i.e. up until the first $\eval$ together with the transcripts $\tr_1, \tr_2, \tr_3$ into a complete transcript $\tr^*$. This $\tr$ is an ``accepting transcript" if and only if the verifier in the last step would output $1$. 

\item Output $(\tr^*, f^*)$.  
\end{itemize}

We now argue that for any PPT $\mathcal{A}$ and $\params \leftarrow \pro{Setup}(1^\lambda)$, if the experiment sampling $(X, \st) \leftarrow \mathcal{A}(\params)$ and $\tr \leftarrow \pro{Record}(P^*, \params, x, \st)$, where $x$ is a tuple of the form $(c, a, i, d)$, produces an ``accepting transcript" $\tr$ with probability $\delta$, then the modified experiment that samples $(\tr^*, f^*) \leftarrow E^{\textsf{Record}(P^*, \params, x, \st)}(\params, x)$ returns an $f^*$ such that $((c, a, i, d), f^*) \in \mathcal{R_\textsf{Index}}(\params)$ with probability $\delta - \negl$. 

If $\delta$ is negligible the claim holds trivially. For now on assume that $\delta$ is non-negligible. 
The fact that $\tr$ is an accepting transcript with probability $\delta$ implies that each $\eval$ subprotocol generates accepting transcripts with probability at least $\delta$. Therefore, by the hypothesis that $\eval$ has witness-extended emulation, if each of the subprotocol transcripts $\tr_1$, $\tr_2$, $\tr_3$ are accepting then with probability $\delta - \negl$: subprotocol witnesses $f^*, f_L^*$ and $f_R^*$ are all valid $\mathcal{R_\textsf{Eval}}(\params)$ witnesses for $(c, \beta, y, d)$, $(c_L, \beta, y_L, i-1)$, and $(c_R, \beta, y_R, d - i - 1)$ respectively. 

We have already shown that the extracted polynomial $f^*(X)$ is valid for $c$ with probability $\delta - \negl$. As a final step, suppose towards contradiction that $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$. Since $\delta$ is non-negligible, $E$ can rewind the transcript oracle to Step 2 (i.e. after receiving the commitments $c, c_L, c_R$), restarting the protocol from this point on a fresh verifier challenge $\beta' \leftarrow_R \mathbb{F}$. It does this until (in expected polynomial time) it finds a $\beta'$ that produces an accepting transcript, which includes $y', y_L', y_R'$ such that $y' = y_L' + \beta'^{i+1} y'_R - a \beta'^i \bmod p$.

The probability that $f_L^*(\beta') + \beta'^i f_R^*(\beta') = f^*(\beta') - a \beta'^i$ is less than $\poly / |\mathbb{F}|$ (the $\poly$ numerator comes from union bound over number of rewindings). In this case, either $y' \neq f^*(\beta')$ or $y_L' \neq f^*_L(\beta')$ or $y_R' \neq f^*_R(\beta')$. Yet, $\eval$ passes on all three, which contradicts the evaluation binding property of $\eval$. Hence, we conclude that except with $\negl$ probability $f_L^*(X) + X^i f_R^*(X) \neq f^*(X) - a X^i$, and thus $f^*_i = a$. 

\end{proof}

\subsection{Inner Product}

Using the $\pro{Reverse}$ and $\pro{OpenIndex}$ protocols as subprotocols, it is straightforward to construct a protocol to prove that a given scalar is the inner product of the coefficient vectors of two committed polynomiails. To see this, observe that if $\bar{g}(X)$ is the polynomial with the same coefficients as $g(X)$ but in reverse order, and if both $\bar{g}(X)$ and $f(X)$ have degree $d$, then the coefficient of the monomial $X^d$ in the polynomial $f(X) \cdot \bar{g}(X)$ is exactly the inner product between $\mathbf{f}$ and $\mathbf{g}$. This gives rise to the protocol $\pro{InnerProduct}(\params, \gr{C}_{f}, \gr{C}_{\bar{g}}, a; {f}(X), {\bar{g}}(X)) \rightarrow b \in \{0,1\}$, which proves that $a = \langle \mathbf{f}, \mathbf{g} \rangle$. Note that this protocol assumes that $\gr{C}_{\bar{g}}$ is a commitment to the polynomial $\bar{g}(X)$, which has the same coefficients as $g(X)$ but in reverse order. Protocol $\pro{Reverse}$ can be used to establish that two commitments $\gr{C}_g$ and $\gr{C}_{\bar{g}}$ represent two polynomials with the same coefficients but in reversed order.

\begin{figure}[!htp]
\noindent\begin{mdframed}[userdefinedwidth=\textwidth]
\begin{minipage}{\textwidth}
	\begin{flushleft}
	$\pro{InnerProduct}(\params, \gr{C}_{{f}}, \gr{C}_{\bar{g}}, a; f(X), \bar{g}(X)):$ 
		\begin{enumerate}[nolistsep]
		    \item $\prover$ computes $h(X) \gets f(X) \cdot \bar{g}(X)$ and $(\gr{C}_h; r_h) \gets \pro{Commit}(\params, h(X))$
		    \item \prover sends $\gr{C}_h$ to \verifier
		    \item \verifier samples $z \sample \mathbb{Z}_p$ and sends $z$ to \prover
		    \item \prover computes $y_f \gets f(z)$ and $y_{\bar{g}} \gets \bar{g}(z)$ and $y_h \gets h(z)$ and sends $(y_f, y_{\bar{g}}, y_h)$ to \verifier
		    \item \prover and \verifier run $\pro{Eval}(\params, \gr{C}_f, z, y_f, d; f(X))$ and $\pro{Eval}(\params, \gr{C}_{\bar{g}}, z, y_{\bar{g}}, d; \bar{g}(X))$ and $\pro{Eval}(\params, \gr{C}_h, z, y_f, d; h(X))$
		    \item \verifier checks that $y_f \cdot y_{\bar{g}} = y_h$
		    \item \prover and \verifier run $\pro{OpenIndex}(\params, \gr{C}_h, a, d; h(X))$
		    \item \pcif{}all checks pass \textbf{then} \textbf{return} 1 \textbf{else} \textbf{return} 0
		\end{enumerate}
	\end{flushleft}
\end{minipage}
\end{mdframed}
\end{figure}

\begin{lemma}
    Protocol $\pro{InnerProduct}$ is an argument of knowledge for the relation
\[\mathcal{R}_\mathsf{IP}(\params) = \left\{
    \langle(\gr{C}_{f}, \gr{C}_{\bar{g}}, a), ({f}(X), \bar{g}, r_f, r_{\bar{g}})\rangle \ : \     \begin{array}{l}
            \mathbf{f}, \mathbf{\bar{g}} \in \mathbb{Z}_p^{d+1} \\
            \langle \mathbf{f}, \mathbf{g} \rangle = a \\
            \pro{Open}(\params, \gr{C}_{f}, {f}(X), r_f) = 1 \\
            \pro{Open}(\params, \gr{C}_{\bar{g}}, {\bar{g}}(X), r_{\bar{g}}) = 1
        \end{array}
    \right\} \enspace .
\]
\end{lemma}

\begin{proof}
Full version / appendix.
\end{proof}
\fi 
