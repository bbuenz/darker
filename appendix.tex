\clearpage
\section*{\scalebox{1.25}{\appendixphrase}}
\section{Security proof new (Added April 2022)}


Although DARK does not satisfy \emph{special soundness}, it does satisfy a property that we will call \emph{DARK special soundness}, which turns out to be sufficient (i.e., using our new forking lemma we can prove that such protocols are knowledge sound). DARK special soundness is a weaker property than special soundness, as all protocols that satisfy special soundness also satisfy DARK special soundness. 

\section{Preliminaries and Notations}

\subsection{Integer polynomials} If $f$ is a multivariate polynomial, then $||f||_\infty$ denotes the maximum over the absolute values of all coefficients of $f$. 

\begin{lemma}[Evaluation Bound]\label{lem:evalbound} For any $\mu$-linear integer polynomial $f$ and $m \geq 2$:
 $$\Prob_{\mathbf{x} \gets [0,m)^\mu} [|f(\mathbf{x})|\leq \frac{1}{m^\mu} \cdot ||f||_\infty]\leq \frac{3\mu}{m}$$
 \end{lemma} 
 \begin{proof}
 Let $f^{(0)}:=f$. 
 Given a vector $\mathbf{x} = (x_1,..,x_\mu)$, for each $j\in[1,\mu]$ define $f_{\mathbf{x}}^{(j)}$ to be the $\mu-j$-variate partial evaluation $f_{\mathbf{x}}^{(j)}:= f(x_1,...,x_j, X_{j+1},...,X_\mu)$. Then we can rewrite the lemma statement as:
    $$P_{\mathbf{x} \gets [0,m)^\mu} [||f_{\mathbf{x}}^{(\mu)}||_\infty\leq  \frac{1}{m^\mu} \cdot ||f^{(0)}||_\infty ]\leq\frac{ 3\mu}{m}$$	
 
We will bound the probability for random $\mathbf{x}$ that there exists any $j$ for which $||f_{\mathbf{x}}^{(j)}|| < \frac{1}{m} \cdot ||f_{\mathbf{x}}^{(j-1)}||$. If no such $j$ exists, then $||f^{(\mu)}|| \geq \frac{1}{m^\mu} \cdot ||f^{(0)}||$. 

For any $j$, we can write $f_{\mathbf{x}}^{(j)} = g(X_{j+1},...,X_\mu) + x_{j}\cdot h(X_{j+1},...,X_\mu)$ where $g,h$ are $\mu-j$ variate multilinear integer polynomials and $||f_{\mathbf{x}}^{(j-1)}|| = \max(||g||, ||h||)$ because the coefficients of $g$ and $h$ are a partition of the coefficients of $f_{\mathbf{x}}^{(j-1)}$.  Suppose now that $||f_{\mathbf{x}}^{(j)}|| < \frac{1}{m} \cdot ||f_{\mathbf{x}}^{(j-1)}||$, i.e. that $||g + x_j \cdot h|| < \frac{1}{m} \cdot \max(||g||, ||h||)$ and consider two cases: \\

\emph{Case 1: $||h|| = \max(||g||, ||h||)$}.  For any integer $\Delta \neq 0$, using the triangle inequality: 
$$||g+(x_j +\Delta) h ||=||g + x_j h +\Delta h||\geq  ||\Delta h|| -  ||g + x_j h|| >  (1 - \frac{1}{m}) \cdot ||h|| \geq \frac{1}{m} \cdot ||h||   $$

The last part of the inequality holds because $1 - \frac{1}{m} \geq \frac{1}{m}$ for any $m \geq 2$. \\

\emph{Case2: $||g|| = \max(||g||, ||h||)$}. Using the triangle inequality, 

$$\frac{1}{m} ||g|| > ||g+x_j \cdot h || \geq  ||g|| - ||x_j \cdot h||$$ 

This implies, for $m \geq 2$, that $||h|| > \frac{1}{m} \cdot ||g||$ because:

$$||x_j \cdot h|| > (1 - \frac{1}{m}) \cdot ||g||\implies ||h||> \frac{m-1}{x_j \cdot m} \cdot ||g||\geq \frac{1}{m} ||g||$$
The last step uses that $x_j\in [1,m)$. For $x_j=0$, $||g +x_j h||=||g||$. 
Finally, for any integer $\Delta$, by the triangle inequality: 

$$||g + (x_j + \Delta) \cdot h|| \geq || \Delta h|| - ||g + x_j \cdot h|| > \frac{|\Delta|}{m} \cdot ||g||  - \frac{1}{m} \cdot ||g||  = \frac{|\Delta| -1}{m} \cdot ||g||$$ 

When $|\Delta| \geq 2$ this implies that $||g + (x_j + \Delta) \cdot h|| > \frac{1}{m} \cdot ||g||$.  

In both cases, we conclude that for any choice of $(x_1,...,x_{j-1})$ for the first $j-1$ components of the random $\mathbf{x}$, which define $g$ and $h$, there are at most three choices of $x_j$ such that the event $||f_{\mathbf{x}}^{(j)}|| < \frac{1}{m} \cdot ||f_{\mathbf{x}}^{(j-1)}||$ holds true  (i.e., if true for $x_j$, then it is also true for at most $x_j + 1$ and $x_j - 1$). Thus this event occurs with probability at most $\frac{3}{m}$. Finally, by a union bound over $j$, the probability this event occurs for some index $j$ is at most $\frac{3\mu}{m}$. 


 \end{proof}
 
 \begin{lemma}[Multilinear Composite Schwartz-Zippel\cite{cryptoeprint:2022:458} ]
 \label{lem:CSZ}
 For all $m \geq 2$, any $\mu$-linear integer polynomial $f$, and $N \in \mathbb{Z}$ coprime to $f$, if either $\mu = 1$ and $ \log_2 N \geq \lambda$ or $\mu \geq 2$ and $\log_2 N\geq 8 \mu^2 + \log_2(2\mu)\cdot \lambda$ then:
 $$\Prob_{x\gets [0,m)^\mu} [f(x)\equiv 0 \bmod N]\leq \frac{1}{2^{\lambda}} + \frac{\mu}{m}$$
% In particular, setting $m = \mu\cdot 2^{\lambda}$ gives the probability bound $2^{-\lambda + 1}$. 
 \end{lemma} 
 
   \begin{lemma}[Concrete MCSZ for 120-bit security\cite{cryptoeprint:2022:458}] \label{lem:cCSZ}
For the following table of values for $( \mu, \beta_\mu)$ s.t. for any $\mu$-linear integer polynomial $f$ and integer $N \geq 2^{\beta_\mu}$ co-prime to $f$: 
 $$\Prob_{x\gets [0,m)^\mu} [f(x)\equiv 0 \bmod N]\leq 2^{-120}+\frac{\mu}{m}$$
\begin{mdframed}
 \begin{center}

\begin{tabular}{l||l}

$\mu$ &  $\lambda=120$ \\
\hline
\hline
1 & 120\\
2 & 156\\
3 & 175\\
4 & 197\\
5 & 212\\
6 & 234\\
7 & 244\\
8 & 260\\
9 & 277\\
10 & 289\\

\end{tabular}
\begin{tabular}{l||l}

$\mu$ &  $\lambda=120$ \\
\hline
\hline
11 & 301\\
12 & 315\\
13 & 331\\
14 & 344\\
15 & 354\\
16 & 366\\
17 & 381\\
18 & 391\\
19 & 407\\
20 & 416\\
\end{tabular}
\begin{tabular}{l||l}

$\mu$ &  $\lambda=120$ \\
\hline
\hline
21 & 429\\
22 & 437\\
23 & 448\\
24 & 464\\
25 & 472\\
26 & 481\\
27 & 492\\
28 & 506\\
29 & 516\\
30 & 527\\

\end{tabular}
\end{center}	
\end{mdframed}
 \end{lemma} 

\begin{fact}
\label{fact:encoding}
Let $q \in \ZZ$ be any positive integer. For any integer $E \in \ZZ$ such that $|E|\leq \frac{q^{d+2} - q}{2(q-1)}$ there exists a unique integer polynomial $f \in \ZZ[X]$ with $||f||_\infty \leq q/2$ such that $f(q) = E$. 
\end{fact} 

\begin{lemma}[Rational Encoding]
\label{lem:encoding}
Let $q \in \ZZ$ be any positive integer. Consider any $\beta_1, \beta_2 \in \mathbb{N}$ such that $\beta_1 \cdot \beta_2 \leq \frac{q}{2}$. Let $Z = \{z \in \ZZ: |z| \leq \beta_1 \}$, let $\mathcal{F} = \{ f \in \ZZ[X]: ||f||_\infty \leq \beta_2\}$, and let $\mathcal{H} = \{f/z \in \mathbb{Q}[X]: f \in \mathcal{F} \wedge z \in Z \}$. Then for any $h_1, h_2 \in \mathcal{H}$,  if $h_1(q) = h_2(q)$ then $h_1 = h_2$. 
\end{lemma}
\begin{proof}
Let $h_1 = \frac{f_1}{z_1}$ and $h_2 = \frac{f_2}{z_2}$. If $h_1(q) = h_2(q)$ then $z_1 f_2(q) = z_2 f_1(q)$. Since $||z_2 \cdot f_1||_\infty \leq \beta_1 \cdot \beta_2 \leq \frac{q}{2}$ and  likewise $||z_1\cdot f_2||_\infty \leq \frac{q}{2}$, it follows from Fact~\ref{fact:encoding} that if $z_1 f_2(q) = z_2 f_1(q)$ then $z_1 f_2 = z_2 f_1$, or equivalently, $h_1 = h_2$.
\end{proof}

\subsection{Assumptions}

\begin{assumption}[RSA assumption, \cite{RivShaAdl78,EC:CouPetPoi17}]
	The RSA assumption states that an efficient adversary cannot compute a random root (co-prime with the order of the group) for a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\benedikt{The GCD requirement is a bit weird.}
	\[
    \Pr\left[
    \begin{array}{l}
    \ell \cdot \gr{U} = \Generator \, \wedge \\
    \gcd(\ell,|\GG|)=1
    \end{array} :
    \begin{array}{l}
         \GG, N \leftarrow \ggen(\lambda)  \\
         \Generator \sample \GG, \ell \sample [N]  \\
         \gr{U} \in \mathbb{G} \leftarrow \adv(\mathbb{G}, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
\]

\end{assumption}

\begin{assumption}[Random Order Assumption]
\label{assum:randomorder}
	The random order assumption states that an efficient adversary cannot compute a multiple of the order of a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\[
    \Pr\left[a\cdot \Generator =0:
    \begin{array}{l}
         \GG, N \leftarrow \ggen(\lambda)  \\
         \Generator, \sample \GG\\
         a \in \NN \leftarrow \adv(\mathbb{G},N, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
    \]
\end{assumption}
\begin{lemma}
\label{lem:roa-to-rsa}
	The RSA Assumption for $\ggen$ implies the Random Order Assumption
	\end{lemma}
\begin{proof}
	Given an efficient adversary $\adv_{\textsf{Order}}$ for the random order assumption we will construct an efficient adversary $\adv_{\textsf{RSA}}$ for the RSA assumption. On input $\GG,\Generator,\ell$ to $\adv_{\textsf{RSA}}$ we will forward $\GG,\Generator$ to $\adv_{\textsf{Order}}$. $\adv_{\textsf{Order}}$ outputs $a$ such that $a\cdot \Generator=0$ with non-negligible probability $\epsilon$. 
	$\adv_{\textsf{RSA}}$ computes computes $a'\gets \frac{a}{\gcd(a,\ell^k)}$ for $k=\lceil\log_\ell(a)\rceil$. Note that since $\ell$ is co-prime to the order of $\GG$ and thus also the order of $\Generator$ and $a$ is a multiple of the order of $\Generator$ we have that $a'$ is still a multiple of the order of $\Generator$. Now $\adv_{\textsf{RSA}}$ computes $w\gets \ell^{-1} \bmod a'$ and outputs $\gr{U} \gets w\cdot \Generator$. Now we have $\ell \cdot \gr{U}=\Generator$ so $\adv_{\textsf{RSA}}$ succeeds with probability $\epsilon$.
\end{proof}
\subsection{DARK commitments} 
Given the security parameter $\lambda$, the commitment scheme setup selects a group $\GG$ for which the random order assumption holds (with  $\lambda$-bit security) and a random generator $\gr{G} \in \GG$. A parameter $q \in \mathbb{N}$ determines a commitment message space $\mathcal{M} = \{f(X): ||f||_\infty \leq q/2\}$. The commitment to $f(X) \in \mathcal{M}$ is $f(q) \cdot  \gr{G}$. Commitments are binding over $\mathcal{M}$ because if $f(q) \cdot \gr{G} = f'(q) \cdot \gr{G}$ then $(f'(q) - f(q)) \gr{G} = 0$. This breaks the order assumption for $\GG$ unless $ f'(q) =  f(q)$, in which case $f' = f$ by Fact~\ref{fact:encoding}. 

If we expand the valid openings of the commitment scheme to include rational polynomials of the form $f/z$, where $f \in \ZZ[X]$, $z \in \ZZ$, so that $(f,D)$ is an opening of $\gr{C}$ to $f/z$ iff $z \cdot \gr{C} = f(q) \cdot \gr{G}$, then the scheme is binding over the message space $\mathcal{M}(\beta_n, \beta_d) =  \{f(X)/z: f \in \ZZ[X], z \in \ZZ, gcd(f,z) = 1, ||f||_\infty \leq \beta_n, |z| \leq \beta_d \}$ so long as $\beta_n \cdot \beta_d \leq \frac{q}{2}$. 

\begin{lemma}[DARK commitment Security]
	The commitment scheme $(\setup,\open)$ to rational polynomials $h=\frac{f}{N}\in \mathcal{M}(\beta_n,\beta_d)$ 
	$$\setup(1^\secpar,\beta_n,\beta_d)\rightarrow \GG=\ggen(1^\secpar) ,\Generator\gets \GG ,q:=\beta_n\cdot \beta_d\cdot 2$$
	$$\open(C,h=f/N)\rightarrow N\cdot \Commitment:=f(q)\cdot \Generator $$ 
	such that $f(q)\Generator=N\cdot \Commitment$ is binding under the random order assumption (\cref{assum:randomorder}), i.e. for any polynomial time adversary $\adv$ $$P\left[\begin{array}{c} 
	\open(C,h)=\open(C,h')=1\\
	h\neq h' 
\end{array}
 \middle|\begin{array}{c}
(h,h',C) \in \mathcal{M}(\beta_n,\beta_d)^2 \times \GG  \gets \adv(\crs)\\	
\crs=\setup(1^\secpar,\beta_n,\beta_d)
\end{array}
	 \right]=\negl$$
\end{lemma}
%The commitment scheme is binding over $\mathcal{M}$, but only provides an efficient way to commit to integer polynomials in $\mathcal{M}$. The commitment to $f(X) \in \mathcal{M}$ is $f(q) \cdot  \gr{G}$, while $f(X)/z$ is a valid opening of $\gr{C}$ iff $z \cdot \gr{C} = f(q) \cdot \gr{G}$. 
\begin{proof}
To see why this is binding over $\mathcal{M}(\beta_n, \beta_h)$, suppose that both $h=\frac{f}{N}$ and $h'=\frac{f'}{N'}$ are valid openings of a commitment $\gr{C}$ to distinct rational polynomials $h, h' \in \mathcal{M}(\beta_n, \beta_d)$. This implies that $N\cdot \gr{C} = f(q) \cdot \gr{G}$ and $z' \cdot \gr{C} = f'(q) \cdot \gr{G}$. Hence, $v =  z \cdot f'(q) - z' \cdot f(q)$ is a multiple of the order of $\gr{G}$, i.e. $v \cdot \gr{G} = 0$. Moreover, by Lemma~\ref{lem:encoding}, $h(q) \neq h'(q)$, which implies $v \neq 0$. This breaks the random order assumption for $\GG$. It is important to note that the openings $(f, z)$ and $(f', z')$ need not be co-prime elements of bounded norm; it suffices that $h = f/z$ and $h' = f'/z'$ have bounded norm numerators and denominators in reduced fraction form, i.e. $h, h' \in \mathcal{M}(\beta_n, \beta_d)$. 
\end{proof}



\subsection{IP transcript trees} 

Let $(P,V)$ be a $\mu$-round public coin interactive protocol. A $\mu$-round public-coin protocol $(P,V)$ consists of $\mu$-rounds of messages between the prover and verifier, where in each round the prover sends a message to the verifier and the verifier responds with $x \leftarrow \mathcal{X}$ sampled uniformly from the challenge space $\mathcal{X}$. At the end of the protocol the verifier outputs either $accept$ or $reject$. By convention, the protocol starts with the prover's first message and ends with the prover's last message. A \emph{transcript} thus contains $\mu+1$ prover messages and $\mu$ challenges. We will denote transcripts by a $\mu \times 2$ matrix $A$ such that $A(0,0)$ is the protocol input $\mathsf{x}$, $A(0, 1)$ is the prover's first message, and for all $i â‰¥ 1$, $A(i, 0)$ is the verifier's $ith$ round challenge and $A(i,1)$ is the prover's $ith$ round response.  We restrict our attention to protocols in which the verifier's decision is a deterministic function $D_V$ of the transcript, which is true of the DARK protocol, but is also without loss of generality. An \emph{accepting transcript} is an array $A$ such that $D_V(A) = accept$. 

A $k$-ary \emph{transcript tree} for $(P,V)$ is a labelling of a $\mu$-depth $k$-ary tree such that the labels on every root-to-leaf path forms an accepting $(P,V)$ transcript. It will be convenient to order the nodes of the tree according to a depth-first reverse topological sort (aka post-order tree traversal). This is a topological sorting of the tree with directed edges flowing from leaves to root which places left subtrees before right subtrees. This ordering associates each node with an index in $[1,N]$ where $N = \textsf{size}(\mu, k) = \frac{k^{\mu+1} - 1}{k-1}$.

A \emph{post-order labelling} of the tree is a function $L:[1,N] \rightarrow \mathcal{X} \times \mathcal{M}$ where $\mathcal{X}$ is the verifier's challenge set and $\mathcal{M}$ is the space of prover messages. We can think of the first component as a label on the node's incoming edge and the second component as a label on the node itself. The root has no incoming edge, but the root label's first component is the protocol input. For any root-to-leaf path of nodes with indices $\{v_0,...,v_\mu\}$ the labelling $L$ defines the matrix $A$ such that $L(v_i) = (A(i, 0), A(i, 1))$ and $A$ is an accepting transcript. Given a label $L(v)$ for $v > 1$ we will use the notation $L(v)_0$ to denote the first component of the label containing the verifier's challenge and $L(v)_1$ the second component containing the prover's response.

We may refer to the \emph{level} of a node in the tree. The root of a tree is always at \emph{level 0} and the leaves of a depth $\mu$ tree are at \emph{level $\mu$}. The \emph{height} of node at level $\ell$ within a $\mu$-depth tree is $\mu - \ell$. For each $v \in [1,N]$ let $v^*$ denote the largest index $v^* < v$ such that the node at index $v^*$ does not belong to the subtree extending from $v$. For each $v \in [1,N]$ let $L_v:[1,v] \rightarrow \mathcal{X} \times \mathcal{M}$ denote the restriction of $L$ to the subset $[1,v^*]$. 
Similarly, for any $S \subseteq [1,N]$ let $L_S: S \rightarrow \mathcal{X} \times \mathcal{M}$ denote the restriction of the labelling $L$ to the subset of node indices $S$. For any $v \in [1, N]$ let $S_v \subseteq [1,N]$ denote the indices of all nodes in the subtree rooted at node $v$. $L_{S_v}$ thus denotes the labelling of the subtree $S_v$. Note that $L_{v^*}$ is not the same as $L_{S_{v^*}}$. 

\subsection{Forking Lemma}
The standard forking lemma for $\mu$-round public coin interactive protocols characterizes the efficiency of generating a $k$-ary $\mu$-depth transcript tree for which the challenges labeling the children within the tree \emph{fork}, i.e. are distinct. More precisely, the forking lemma says that given any adversarial prover $\mathcal{A}$ that may deviate from the honest protocol but causes the verifier to accept with probability $\epsilon > \negl$, there is a tree generation algorithm that has only black-box access to $\mathcal{A}$, runs in time $O(\frac{\lambda}{\epsilon} \cdot k^\mu)$, and succeeds with probability $1 - \negl/\epsilon$ in producing a transcript tree with the forking property. 

 Our forking lemma generalizes the property of the transcript tree that can be generated. The lemma considers predicates for each node $v \in [1,N]$ at level $\ell_v$ of the form $\pi_v: (\mathcal{X}\times \mathcal{M})^{[1,v^*]} \times \mathcal{X}^{\mu - \ell_v} \rightarrow \{0,1\}$, i.e. each predicate $\pi_v$ takes as input a labelling function $L_{v^*}$ for the partial set of nodes $[1,v^*]$ and a vector of challenges $\mathbf{x} \in \mathcal{X}^{\mu - \ell_v}$. The vector of challenges will represent a path down the tree starting from $v$ that is independent of the partial labeling. As a convention, we choose this path to be the rightmost path, but any choice of path would do. We denote the indices of the rightmost path from $v$ to the leaves as $\textsf{rpath}_v$ and the challenge labels along this path assigned by $L$ as $L(\textsf{rpath}_v)_0$. The lemma says that if $\pi_v(L_{v^*}, \mathbf{x}) = 1$ with overwhelming probability $1 - \negl$ for any post-order labeling $L:[1,N] \rightarrow \mathcal{X} \times \mathcal{M}$ of the $k$-ary $\mu$-depth tree, any node $v$ in the tree, and $\mathbf{x}$ sampled randomly, then the transcript generation algorithm produces a transcript tree represented by some post-order labeling $L$ for which $\pi_v(L_{v^*}, L(\textsf{rpath}_v)_0) = 1$ for all $v$ in the tree. In fact, the lemma is even more general as it has a weaker requirement that $\pi_v(L_v^*, \mathbf{x}) = 1$ with overwhelming probability conditioned on $\pi_u(L_u^*, L(\textsf{rpath}_u)_0) = 1$ for all $u \leq v^*$. The standard forking lemma is a special case where $\pi_v$ checks that the challenge label on $v$ is distinct from the challenge labels on any of its left siblings. The challenge label $L(v)_0$ on $v$ is the first component of $L(\textsf{rpath}_v)_0$ and the challenge labels on the left sibling(s) of $v$, assuming $v$ is not the first child, are included in $L_{v^*}$. 
 
 \begin{lemma}[Generalized Forking Lemma]
 Let $(P, V)$ be a $\mu$-round public-coin protocol with prover message space $\mathcal{M}$ and verifier challenge space $\mathcal{X}$. For each node $v \in [1,N]$ of a $\mu$-depth $k$-ary balanced tree on $N = \textsf{size}(\mu, k)$ nodes, let $h_v$ denote the height of $v$. Let $\{\pi_v: v \in [1,N]\}$ denote a set of predicates, where $\pi_v(L_{v^*}, \mathbf{x})$ is a function of the partial labelling $L_{v^*}$ and challenge vector $\mathbf{x} \in \mathcal{X}^{h_v}$, with the property that for any post-order labelling function $L:[1,N] \rightarrow \mathcal{X} \times \mathcal{M}$ and any $v \in [1,N]$: 

$$Pr_{\mathbf{x} \leftarrow \mathcal{X}^{h_v}}[ \pi_v(L_{v^*}, \mathbf{x}) = 1 \ | \ \forall_{u \leq v^*} \pi_u(L_{u^*},L(\textsf{rpath}_u)_0) = 1] \geq 1 - negl(\lambda)$$

There is an algorithm $\textsf{Tree}^\mathcal{A}(\mathsf{x})$ that, given oracle access to any adversarial prover $\mathcal{A}$ that runs for time at most $T_\mathcal{A}$ and causes $V$ to accept with probability $\epsilon > negl(\lambda)$ on public input $\mathsf{x}$, runs in time $poly(\lambda)\cdot T_\mathcal{A}/\epsilon$ and with probability $1 - negl(\lambda)/\epsilon^2$ outputs a $k$-ary transcript tree with post-order labelling $L:[1,N] \rightarrow \mathcal{X}\times \mathcal{M}$ such that $\pi_v(L_{v^*}, L(\textsf{rpath}_v)_0) = 1$ for all $v \in [1,N]$.  	
 \end{lemma}



\section{DARK Special Soundness Theorems} 
\begin{definition}[DARK Special Soundness]\label{def:darkspecialsoundness} A $\mu$-round public-coin interactive proof for relation $R(x,w)$ with challenge space of size $2^\lambda$ is \textbf{DARK $(k^{(\mu)}, \epsilon(\cdot))$-special sound} if it satisfies the following conditions with respect to some commitment scheme $(\textsf{Commit}, \textsf{Verify})$ with message space $\mathcal{M}$ and opening space $\mathcal{W}$, two predicates $\phi_a, \phi_b:[\mu] \times \mathcal{M}  \rightarrow \{0,1\}$, and negligible functions $\epsilon: \mathbb{N} \rightarrow \mathbb{R}$:


\begin{enumerate} 
\item  In any accepting transcript, the prover's $i$th round message for $i \in [1,\mu)$ is a valid commitment $\mathcal{C}_i$ for the scheme $(\textsf{Commit}, \textsf{Verify})$, and the final prover message is a commitment $\mathcal{C}_\mu$ together with a valid opening $(m_\mu, o_\mu)$ (i.e. $\textsf{Verify}(C_\mu, m_\mu, o_\mu) = 1$) such that $\phi_a(\mu, m_\mu) = 1$. 


\item  There is a $poly(\lambda)$ time algorithm $\textsf{Extract}(i, \nu, C_\nu, \textsf{openSubtree}) \rightarrow (m, o)$ where $i \in [1,\mu]$ and $\textsf{openSubtree}$ is a list of openings for the commitments on all internal nodes (excluding the root and leaves) of a $k$-ary depth $\mu - i$ subtree of a transcript tree rooted at a node $\nu$ on the $i$th level with commitment label $C_\nu$. If the challenge labels on the first two children of any node in the subtree are distinct, and the openings for all internal (non-root) nodes of the subtree satisfy predicate $\phi_a$ (i.e., for any $j > i$ and node $u$ on the $j$th level of the transcript tree that is a member of this subtree, its opening $(m_u, o_u)$ in $\textsf{openSubtree}$ satisfies $\phi_a(j, m_u)= 1$) then the algorithm returns a valid opening $(m,o)$ for $c_\nu$ such that $\phi_b(i, m) = 1$.  

\item  $\textsf{Extract}(0,x,\textsf{openTree}) \rightarrow w$ takes as inputs openings for the commitments on all nodes in an entire transcript tree satisfying predicate $\phi_a$ (same condition as above for subtrees) and returns a witness $\mathsf{w}$ for the public input $\mathsf{x}$ such that $R(\mathsf{x},\mathsf{w})=1$. 

\item  $\textsf{Extend}(i, m, r_1,..,r_{\mu-i})$ is a deterministic $\poly$-time algorithm that is given an index $i \in [\mu-1]$, a message $m$ in the message space of the commitment scheme $(\textsf{Commit}, \textsf{Verify})$, $\mu-i$ challenges from $\mathcal{X}$, and outputs $\mu-i$ messages $m'_1,...,m'_{\mu-i}$ in the message space of the commitment scheme. 
\item For any $i \in [\mu-1]$ and $m$ where $\phi_a(i,m) = 0$, the probability over $r_i,...,r_\mu$ sampled uniformly i.i.d. from $\mathcal{X}$ that the last message $m'_{\mu-i}$ in the list returned by $\textsf{Extend}(i, m)$ satisfies $\phi_a(\mu, m'_{\mu-i}) = 1$ is bounded by $\epsilon(\lambda)$.   

\item $\textsf{Break}(i, m, r_1,...,r_\mu, C_0,...,C_\mu, (m_i, o_i),...,(m_{\mu}, o_{\mu}))$ first runs $\textsf{Extend}(i, m, r_i,..,r_{\mu})$, which returns messages $m'_1,...,m'_{\mu-i}$. If  either $\phi_b(i, m_i) = 0$ or $\forall_j$ $m'_j = m_{i + j -1}$ then it outputs $\bot$. Otherwise it outputs an attempted opening $(m', o')$ of $C_j$ for some index $j \geq i$ where $m' \neq m_j$. %\benedikt{Change break to output bot if phib is 0.}


%\item For any $i \in [\mu-1]$ and algorithm $\mathcal{A}$ that runs in time at most $t_\mathcal{A} \in O(\poly)$ to generate a valid (accepting) transcript with commitments $(C_0,...,C_\mu)$ and openings $((m_{i+1},o_{i+1}),...,(m_\mu, o_\mu))$ to the last $\mu-i$ commitments, where $\phi_b(j, m_j, o_j) = 1$ for all $j \in [i+1,\mu]$, then $\textsf{Extend}(i, m_i)$ returns $m_{i+1},...,m_{\mu}$ in time $t_E$ with overwhelming probability $1 - \delta(t_\mathcal{A} + t_E)$ over the internal randomness of $\mathcal{A}$ (and randomness of the commitment scheme setup if applicable).  

\item For any $i \in [\mu-1]$, given a valid (accepting) transcript with commitments $\mathbf{C} = (C_0,...,C_\mu)$, round challenges $\mathbf{r} = (r_1,...,r_{\mu})$, and openings $\mathbf{open} = ((m_{i},o_{i}),...,(m_\mu, o_\mu))$ to the last $\mu-i+1$ commitments, where $\phi_b(i, m_i) = 1$ and $\phi_a(j, m_j) = 1$ for all $j \in [i+1,\mu]$, either $\textsf{Extend}(i, m_i, r_{i+1},...,r_\mu)$ returns $m_{i+1},...,m_{\mu}$ or $\textsf{Break}(i, m_i, \mathbf{r}, \mathbf{C}, \mathbf{open})$ returns an opening $(m', o')$ of some $C_j$ to a conflicting message $m' \neq m_j \in \mathcal{M}$, which breaks the binding of the commitment scheme over $\mathcal{M}$.
\end{enumerate} 

\end{definition} 

\textsf{Note:} Any special sound protocol satisfies DARK special soundness as 3) essentially captures the special soundness definition. More precisely a $k^{(\mu)}$-special sound satisfies $k^{(\mu)}$-DARK special soundness by setting the commitment scheme to be trivial (i.e., identity function) and the $i$th round commitment $C_i$ to the prover's $i$th round message and setting the predicates $\phi_a=1, \phi_b=0$ to be trivial as well (i.e., always return 1 and 0 respectively). The algorithm $\textsf{Extend}$ can output an arbitrary set of messages because the condition on the algorithm is vacuously true as $\phi_a(i,m) \neq 0$ for any $(i,m)$. The algorithm $\textsf{Extract}(i, \nu, C_\nu, *)$ is trivial because $C_\nu$ is the message itself. The algorithm $\textsf{Break}$ is also trivial as $\phi_b$ is always $0$. The algorithm $\textsf{Extract}(0, x, openTree) \rightarrow w$ exists by the definition of $k^{(\mu)}$-special soundness. %\benedikt{For break do nothing and for phib it needs to ouput 0 otherwise this doesn't work.}

\begin{theorem} Let $\CSZ = 8 \mu^{2} + \log_2 (2 \mu) \lambda$. Let $\EBL=\lambda\cdot \mu$ and $\CorrectnessBound=\lambda\cdot \mu+\log_2 p$. 
The $\mu$-round DARK polynomial commitment evaluation protocol with $\lambda$-bit challenges, group $\GG$, and $\log q \geq 1 + 4(\lambda + 1 + \max(\EBL+ \CorrectnessBound, \CSZ))$ is DARK $(2^{(\mu)}, \frac{3\mu}{2^\lambda})$-special sound.
\end{theorem} 
\textbf{Remark:} $\mathsf{CSZ}_{\mu, \lambda}$ is derived from the Multilinear Composite Schwartz Zippel Lemma (\cref{lem:CSZ}). $\mathsf{EBL}_{\mu, \lambda}$ is derived from the Evaluation Bound Lemma (\cref{lem:evalbound}) and $\mathsf{CB}$ refers to the final round check bound in the DARK protocol. We can also substitute any value for $\mathsf{CSZ}_{\mu,\lambda}$ using the table of concrete bounds in Lemma~\ref{lem:cCSZ} for fixed $120$-bit security in place of the analytical bound from Lemma~\ref{lem:CSZ}).% which gives the same result for $\log q \geq 1 + 4(121 + \max(\EBL+ \CorrectnessBound , \mathsf{CSZ}_{\mu,\lambda}))$ and $\epsilon(\lambda) = \max(\frac{3\mu}{2^\lambda}, 2^{-120})$. \ben{This should be $\lambda$-bit security not 120-bit?}  
\begin{proof} 

For any $\beta_1, \beta_2 \in \mathbb{R}$, let $\mathcal{M}(\beta_1, \beta_2) = \{f/N \in \QQ[X]: gcd(f, N) = 1, ||f||_\infty \leq \beta_1, |N| \leq \beta_2\}$. In the relation $R(\mathsf{x}, \mathsf{w})$ for the DARK evaluation protocol, the input $\mathsf{x} = (C, z, y)$ consists of a DARK commitment $C$ and two integers $z, y \in \ZZ$, while the witness $\mathsf{w}$ is an opening of $C$ to a rational polynomial $h \in \mathcal{M}(\sqrt{\frac{q}{2}}, \sqrt{\frac{q}{2}})$ such that $h(z) = y \bmod p$. Setup parameters include $p$ and $q$. 

\medskip 

We begin by defining $(\textsf{Commit}, \textsf{Verify})$ and predicates $\phi_a$ and $\phi_b$ for DARK special-soundness (Definition~\ref{def:darkspecialsoundness}). %We use the simplified notation $\phi_a, \phi_b: [\mu] \times \mathcal{M} \rightarrow \{0,1\}$ because in this case the predicates will only be functions of the messages and not the opening hints. 
 
\begin{itemize} 
\item The commitments of the scheme $(\textsf{Commit}, \textsf{Verify})$ are pairs $\mathcal{C} = ((C_L, y_L), (C_R, y_R)$ where $C_L, C_R$ are DARK commitments and $y_L, y_R \in \QQ$. Recall that $(f, N) \in \mathbb{Z}[X] \times \ZZ$ is an opening of a DARK commitment $C$ to the rational polynomial $h = f/N$ provided that  $f(q) \cdot \gr{G} = N \cdot C$, where $q$ is a parameter of the DARK commitment scheme. This is binding to rational polynomials in the set $\mathcal{M}(\sqrt{\frac{q}{2}}, \sqrt{\frac{q}{2}})$.

We define a valid opening of $\mathcal{C} = ((C_L, y_L), (C_R, y_R))$ to a rational polynomial $h \in \mathbb{Q}[X]$ of even degree $d = \deg(h)$ as a pair $(f, N) \in \ZZ[X] \times \ZZ$ where $f = f_L + X^{\frac{d}{2}} f_R$ for $\deg(f_L), \deg(f_R) < \frac{d}{2}$ such that $(f_L, N)$ and $(f_R, N)$ are valid openings of the DARK commitments $C_L$ and $C_R$ respectively, provided that $N \cdot h = f$, $f_L(z) = N \cdot y_L \bmod p$, $f_R(z) = N \cdot y_R \bmod p$. This also implies that $(f, N)$ is a valid opening of the homomorphically derived DARK commitment $C = C_L + q^{\frac{d}{2}} C_R$ to $h$ and $h(z) = y_L + z^{\frac{d}{2}} y_R \bmod p$, i.e. $N \cdot C = f(q) \cdot \gr{G}$ and $h \in \mathcal{M}(\sqrt{\frac{q}{2}}, \sqrt{\frac{q}{2}})$ %Such an opening may be derived from individual openings of $C_L$ to $h_L$ and $C_R$ to $h_R$ where $h_L(z) = y_L \bmod p$ and $h_R(z) = y_R \bmod p$. 
 %DARK openings of $C_L$ to $h_L$ and $C_R$ to $h_R$ such that $deg(h_L), deg(h_R) < \frac{d}{2}$ and $h = h_L +  X^{\frac{d}{2}} h_R$.  These commitments and openings also can be used to derive an opening of the DARK commitment 

Additionally, a rational number is also considered a valid (trivial) commitment to itself. In the DARK protocol the prover's messages are commitments of the first kind for all but its last message, which is a single integer. 

\item We define the bounds $B_0\geq \cdots \geq B_\mu \in \mathbb{N}$ such that $B_\mu = \CorrectnessBound =2^{\lambda \mu} \cdot p$ is the verification bound on the prover's final integer message in the DARK protocol and $\log B_i = \max(\EBL[\mu-i]+\CorrectnessBound, \CSZ[\mu-i])$.  For $i \in [\mu-1]$ and any $h \in \QQ[X]$, we define $\phi_a(i, h) = 1$ if and only if $\deg(h) < 2^{\mu - i}$ \benedikt{Let's maybe use a functional notation, i.e. $\phi_a(i,h)= \mathbf{1}[\deg(h)<2^{\mu-1}$} and $h \in \mathcal{M}(B_i, B_i)$. We define $\phi_a(\mu, h) = 1$ iff $h \in \mathbb{Z}$ and $|h| \leq B_\mu$. 

\if 0 
\textbf{Remark:} If using Lemma~\ref{lem:CSZ}, $\mathsf{CSZ}_{\mu - i} = 8 (\mu-i)^2+ \log_2 (2 \cdot(\mu -i))\cdot \lambda$ for $i < \mu -1$ and $\mathsf{CSZ}_1 = \lambda$. Clearly $\log B_{\mu} = \mu \lambda + \log p$ and $\log B_{\mu - 1} = (\mu + 1) \lambda + \log p$, but the values of $B_{\mu - i}$ at larger $i > 1$ depends on the relative size of $\lambda$ and $\mu$.

 If $\lambda \geq \frac{8 i^2}{\mu -1 + i - \log i}$ for all $i \in [2, \mu)$ then $\log B_{\mu-i} = (\mu + i) \lambda + \log p$ for all $i \in [1, \mu]$. As this expression is increasing in $i$, it suffices that $\lambda \geq \frac{8\mu^2}{2\mu -1 - \log \mu}$. Otherwise, let $i$ denote the first index such that $(\mu + i) \lambda + \log p < 8 i^2  + (1 + \log i) \lambda$,  and consequently $\log B_{\mu - i} = 8i^2 + (1 + \log i) \lambda$. This implies that $8[(i+1)^2 - i^2] = 8(2i +1)> \lambda (1 - \log (i+1) + \log i)$, and thus, $\log B_{\mu - i - 1} =  8(i+1)^{2} + (1 + \log i) \lambda$. This will continue to be true for all $j \geq i$. Therefore, it follows that: 
$$ \log B_0 = \max (2\mu \lambda + \log p, 8 \mu^{2} + (1 + \log \mu) \cdot \lambda) $$

Now suppose that using Lemma~\ref{lem:cCSZ} gives tighter (i.e., lower) values for $\mathsf{CSZ}_{\mu - i}$ than Lemma 2 for some indices.  In the first case where $\lambda + \log B_{i-1}$ always dominates $\mathsf{CSZ}_{\mu - i}$ the resulting $B_0$ is the same, i.e. $\log B_0 = 2 \mu \lambda + \log p$. However, in the second case where at some point $\log B_i = \mathsf{CSZ}_{\mu - i} > \lambda + \log B_{i-1}$, it is possible that the final $B_0$ has value $\log B_0 = \mathsf{CSZ}_{\mu - j} + j \cdot \lambda$ for some $j \in [1, \mu)$. Thus: 

$$ \log B_0 \leq \max(2\mu \lambda + \log p, \max_{j \in [\mu]} \mathsf{CSZ}_{\mu - j} + j \cdot \lambda ) \leq \max(2\mu \lambda + \log p, \mathsf{\mu \lambda + CSZ}_\mu)$$
\fi 

\item For $i \in [\mu-1]$ and an opening $h \in \QQ[X]$ define $\phi_b(i, h) = 1$ iff $\deg(h) < 2^{\mu - i}$ and $h \in \mathcal{M}(2^{\lambda + 1} B_i^2, 2^{\lambda + 1} B_i^2)$. 

 \item By setting $q$ sufficiently large so that $2 \cdot (2^{\lambda + 1} B_0)^4 \leq  q$, for any $i \in [\mu]$, $\phi_b(i, h) = 1$ implies that $2^{\lambda + 1} \cdot h \in \mathcal{M}(\sqrt{\frac{q}{2}},\sqrt{\frac{q}{2}})$.  
\end{itemize} 

Next, we define the algorithms $\textsf{Extract}$ and $\textsf{Extend}$. 

\begin{itemize} 
\item $\textsf{Extract}(i, \nu, C_\nu, \textsf{openSubtree})$ for $i < \mu$ operates as follows. Let $\mathcal{C}_\nu = (C_L, C_R)$. The node $\nu$ has two children. Let $r_1$ denote the label on the edge to the first child and $r_2$ the label on the edge to the second child. For $j \in \{1,2\}$, let $\mathcal{C}_j = ((C_{j,L}, y_{j, L}), (C_{j,R}, y_{j,R}))$ denote the commitment label of the $i$th child with openings $(f_j, N_j)$ to $h_j = f_j/N_j$ where $f_j = f_{j, L} + X^{2^{\mu - i - 2}} f_{j, R}$, and $h_j(z) = y_{j,L} + z^{2^{\mu - i -2}} y_{j,R} \bmod p$. Set $N = (r_2 - r_1) N_1 N_2$, $f_L = r_2 N_2 f_1 - r_2 N_1 f_2$, and $f_R = N_1 f_2 - N_2 f_1$. Set $f = f_L + X^{2^{\mu - i -1}} f_R$. Return $(f, N)$ as the opening for $C_\nu$ to $h = f/N$. 


 %Solve for $(f_L, N_L)$ and $(f_R, N_R)$ such that $h_j = \frac{f_L}{N_L} + r_j \frac{f_R}{N_R}$ and $N_L \cdot C_L= f_L(q) \cdot \gr{G}$ and $N_R \cdot C_R = f_R(q)\cdot \gr{G}$ for $j \in \{1,2\}$, which has a solution so long as $r_1 \neq r_2$. Let $N = lcm(N_L, N_R)$ and $f = \frac{N}{N_L} f_L + X^{2^{\mu - i}} \frac{N}{N_R} f_R$. Return $(f, N)$ as the opening for $C_\nu$.

%$\textsf{Extract}(i, \nu, C_\nu, \textsf{openSubtree})$ for $i < \mu$ operates as follows. Let $\mathcal{C}_\nu = (C_L, C_R)$. The node $\nu$ has three children. Let $r_1$ denote the label on the edge to the first child and $r_2$ the label on the edge to the second child. For $j \in \{1,2\}$, let $\mathcal{C}_j = (C_{j,L}, C_{j,R})$ denote the commitment label of the $i$th child with openings $h_{j,L}, h_{j,R} \in \mathbb{Q}[X]$. Let $d_i = 2^{\mu - i -1}$. Let $h_j  = h_{j, L}+ X^{d_i/2} \cdot h_{j, R}$. Solve uniquely for $h_L$ and $h_R$ such that $h_j = h_L + r_j h_R$ for $j \in \{1,2\}$, which has a unique solution over $\mathbb{Q}[X]$ so long as $r_1 \neq r_2$. Return $(h_L, h_R)$ as the opening for $C_\nu$. 

%$(f_{j,L}/N_{j,L}, f_{j,R}/N_{j,R})$. Let $d_i = 2^{\mu - i -1}$. Let $h_j  = f_{j, L}/N_{j,L} + X^{d_i/2} \cdot f_{j, R}/N_{j,R}$. Solve uniquely for reduced form rational polynomials $f_L/N_L$ and $f_R/N_R$ such that $h_j = f_L/N_L + r_j f_R/N_R$ for $j \in \{1,2\}$, which has a unique solution over $\mathbb{Q}[X]$ so long as $r_1 \neq r_2$. Return $(f_L/N_L, f_R/N_R)$ as the opening for $C_\nu$. 

%\textbf{Notes:} Let $h_{j,L} = f_{j,L}/N_{j,L}$, $h_{j, R} = f_{j, R}/N_{j,R}$, $h_L = f_L/N_L$, and $h_R = f_R/N_R$ in reduced form.  If $deg(f_{j,L}), deg(f_{j,R}) < d_i/2$ then $deg(f_L), deg(f_R) < d_i$. Since $C_L \cdot C_R^{\alpha_j} = C_{j,L} \cdot C_{j, R}^{q^{d_i/2}}$ and $C_{j, L}^{N_{j,L}}= g^{f_{j,L}(q)}$ and $C_{j, R}^{N_{j,R}} = g^{f_{j,R}(q)}$ it follows that $C_L^{N_L} = g^{f_L(q)}$ and $C_R^{N_R} = g^{f_R(q)}$. Write out the matrices to show this. Furthermore, let $\ell = lcm (N_{1,L}, N_{1,R}, N_{2, L}, N_{2, R}) \leq B_i^4$ then $|N_L| \leq \alpha_2 \cdot\ell$ and $|N_R| \leq |\alpha_1 - \alpha_2| \cdot \ell$. Bound on $||f_L||$ and $||f_R||$? At most $2^{\lambda+1} B_i^3 \cdot max \{||f_{1,L}|| + ||f_{2,L}||, ||f_{1, R}|| + ||f_{2,R}||\} $. 

\item \textsf{Extract}(0, (C, z, y), \textsf{openTree}) simply returns the opening $(f, N)$ for the root level commitment $((C_L, y_L), (C_R, y_R))$ to $h = f/N$, which satisfies $N \cdot C = f(q) \cdot \gr{G}$ and $h(z) = y$, since in a valid transcript tree $C = C_L + q^{2^{\mu -1}} C_R$ and $y_L + z^{2^{\mu -1}} y_R = y$.  Furthermore, if $\phi_a(0, h) = 1$ then $h \in \mathcal{M}(B_0, B_0) \subseteq \mathcal{M}(\sqrt{\frac{q}{2}}, \sqrt{\frac{q}{2}})$, and hence $\mathsf{w} = (f, N)$ is a witness for $\mathsf{x} = (C, z, y)$ such that $R(\mathsf{x}, \mathsf{w}) = 1$. 

%\textbf{Notes:} Let $f_L/N_L = h_L$ and $f_R/N_R = h_R$ denote the reduced forms. Since $C_L^{N_L} = g^{f_L(q)}$ and $C_R^{N_R} = g^{f_R(q)}$ and $C = C_L \cdot C_R^{q^{d/2}}$ it follows that $C^N = g^{f(q)}$. Furthermore, $N \leq lcm(N_L, N_R) \leq B_0^2$ and $||f|| \leq B_0^2 \cdot max(||f_L||, ||f_R||)$. 


\item $\textsf{Extend}(i, h, r_{i+1},...,r_\mu)$ on $h \in \mathbb{Q}[X]$ returns $\bot$ if $\deg(h) > 2^{\mu - i}$, and otherwise sets $h_i := h$ and runs the following iterative algorithm: for $j = i$ to $\mu-1$ set $h_{j+1} := h_{j, L} + r_{j+1} \cdot h_{j,R}$ where, treating each $h_j$ as a degree $2^{\mu - j} -1$ polynomial (padding with zero coefficients), $h_{j,L}$ and $h_{j, R}$ are each degree $2^{\mu -j - 1} - 1$ consisting of the left/right coefficients of $h_j$, i.e. $h_j = h_{j,L} + X^{2^{\mu - j - 1}} h_{j,R}$; return $h_i,...,h_\mu$. 

\textbf{Notes:} 
The runtime is $O(\lambda \cdot 2^{\mu - i})$. 

If $h_{i,L}, h_{i,R}  \in \mathbb{Z}[X]$ are the prover's committed polynomials in the $i$th round of the (honest) interactive DARK protocol and $r_{i+1},...,r_\mu$ are the last $\mu - i$ round challenges then $h_\mu$ is the last prover's message sent to the verifier in the interactive DARK protocol. 

 Let $\mu' = \mu - i$. For $b = (b_1,...,b_{\mu'}) \in \{0,1\}^{\mu'}$ let $\sigma(b) = \sum_{j =1}^{\mu'} b_j \cdot 2^{\mu' - j + 1}$, i.e. $b$ is the binary big-endian representation of $\sigma(b)$. Then $h_\mu = g(r_{i+1},...,r_\mu)$ where $g(X_1,...,X_{\mu'}) = \sum_{b \in \{0,1\}^{\mu'}} h_{\sigma(b)} \prod_{j=1}^{\mu'}X_j^{b_i}$ where $h_j$ is the $j$th coefficient of $h \in \mathbb{Q}[X]$. 
 
 \item $\textsf{Break}(i, h, r_1,...,r_\mu, C_0,...,C_\mu, (f_i, N_i),...,(f_\mu, N_\mu))$\footnote{For simplicity, we omit the messages $h_i = f_i/N_i$ from the inputs because it can be computed from the opening $(f_i, N_i)$.}  first runs $\textsf{Extend}(i, h, r_i,..,r_{\mu})$, which returns rational polynomials $h'_{i+1},...,h'_{\mu}$. If $\forall_{j \geq i}$ $h'_j = f_j/N_j$ then it outputs $\bot$. Otherwise, let $j \in [i, \mu)$ be the \textit{first} index where $h'_{j+1}\neq f_{j+1}/N_{j+1}$ and output $(N_j, f_{j, L} + r_{j+1} \cdot  f_{j, R})$, where $f_{j, L}$ and $f_{j, R}$ are the left/right halves of $f_j$, as the attempted opening for $C_{j+1}$.
\end{itemize}

\begin{subclaim} 
For $i \in [\mu-1]$, if all openings of commitments on children of $\nu$ in $\textsf{openSubtree}$ satisfy $\phi_a(i+1, *)=1$ then the tuple $(f_L, f_R, N)$ returned by $\textsf{Extract}(i, \nu, \mathcal{C}_\nu, \textsf{openSubtree})$ is a valid opening for $\mathcal{C}_\nu$ to a rational polynomial $h$ that satisfies $\phi_b(i, h) = 1$ 
\end{subclaim} 

\begin{proof}
We will show why this is a correct opening for $\mathcal{C}_\nu$ and bound its norm. Based on the properties of a valid transcript tree, $\forall_{j \in \{1,2\}} C_L + r_j C_R =  C_{j,L} + q^{2^{\mu - i - 2}} C_{j,R}$ and $y_L + r_j y_R = y_{j,L} + z^{2^{\mu - i -2}} y_{j, R}$. Furthermore, $\forall_{j \in \{1,2\}} N_j \cdot (C_L + r_j C_R ) = f_j(q)$ and $h_j(z) = N_j^{-1} f_j(z) = y_L + r_j y_R \bmod p$ by the assumption that $(f_j, N_j)$ are valid openings to the two children commitments $\mathcal{C}_j$.  Let $L_q(\cdot): \ZZ[X]^2 \rightarrow \ZZ^2$ denote the linear operator corresponding to component-wise evaluation of each polynomial at $q$. Using linear algebra, the following holds true if $r_1 \neq r_2$:

\begin{equation*}
\begin{bmatrix}
N_1 & 0 \\
0 & N_2 \\
\end{bmatrix} 
\begin{bmatrix}
1 & r_1 \\
1 & r_2 \\
\end{bmatrix} 
\begin{bmatrix}
C_L \\
C_R \\
\end{bmatrix} 
= 
L_q \left(
\begin{bmatrix}
f_1 \\
f_2\\
\end{bmatrix} 
\right)
 \cdot \gr{G} 
\hspace{1mm}
\Rightarrow
\hspace{1mm}
(r_2 - r_1) N_1 N_2 
\begin{bmatrix}
C_L \\
C_R \\
\end{bmatrix}
= 
L_q\left(
\begin{bmatrix}
r_2 N_2 & -r_2 N_1 \\
-N_2 & N_1 \\
\end{bmatrix}
\begin{bmatrix}
f_1 \\
f_2 \\
\end{bmatrix}
\right)
\cdot  \gr{G}
\end{equation*} 

\begin{equation*}
\begin{bmatrix}
N_1 & 0 \\
0 & N_2 \\
\end{bmatrix} 
\begin{bmatrix}
1 & r_1 \\
1 & r_2 \\
\end{bmatrix} 
\begin{bmatrix}
y_L \\
y_R \\
\end{bmatrix} 
= 
L_z \left(
\begin{bmatrix}
f_1 \\
f_2\\
\end{bmatrix}
\right) \bmod p
\hspace{1mm}
\Rightarrow
\hspace{1mm}
(r_2 - r_1) N_1 N_2 
\begin{bmatrix}
y_L \\
y_R \\
\end{bmatrix}
= 
L_z \left(
\begin{bmatrix}
r_2 N_2 & -r_2 N_1 \\
-N_2 & N_1 \\
\end{bmatrix}
\begin{bmatrix}
f_1 \\
f_2 \\
\end{bmatrix}
\right)
\bmod p
\end{equation*} 

This shows that $N \cdot C_L = f_L(q) \cdot \gr{G}$, $N \cdot C_R = f_R(q) \cdot \gr{G}$, $N \cdot y_L = f_L(z) \bmod p$, and $N \cdot y_R = f_R(z) \bmod p$. Furthermore, if $\deg(f_1) < 2^{\mu - i - 1}$ and $\deg(f_2) < 2^{\mu - i - 1}$, then $\deg(f_L) < 2^{\mu - i-1}$ and $\deg(f_R) < 2^{\mu -i -1}$. 
%$$N \cdot (C_L + q^{2^{\mu - i - 1}} C_R) = (f_L(q) + q^{2^{\mu - i -1}} f_R(q)) \cdot \gr{G} = f(q) \cdot \gr{G}$$ 

%$$ \frac{f_L}{N_L} = \frac{N_2 r_2 f_1 - N_1 r_2 f_2}{(r_2 - r_1)N_1 N_2 } \ \ \text{and} \ \ \frac{f_R}{N_R} = \frac{N_1 f_2 - N_2 f_1}{(r_2 - r_1) N_1 N_2}$$

If $\forall _j ||f_j||_\infty \leq B_i$ and $\forall_j |N_j| \leq B_i$,  then $|N|  \leq 2^{\lambda + 1} B_i^2$ and $||f||_\infty \leq 2^{\lambda + 1} B_i^2$. Thus, if the openings of the children at level $i+1$ satisfy $\phi_a(i+1, f_j/N_j) = 1$ for $j \in \{1, 2\}$, then $\phi_b(i, f/N) = 1$. %In other words, if the openings $(f_j, N_j)$ for $h_j = f_j/N_j$ of the children at level $i+1$ satisfy $\phi_a(i+1, h_j, f_j, N_j) = 1$ then $\phi_b(i, h, f, N) = 1$. 
\end{proof} 



\begin{subclaim} [\emph{Key *New* Subclaim}]
For any $i \in [\mu]$ and $h \in \mathbb{Q}[X]$, if $\phi_a(i, h) = 0$ then the probability over uniform i.i.d. $r_{i+1},...,r_\mu$ that $h_\mu$ returned by $\textsf{Extend}(i,h, r_{i+1},...,r_\mu)$ satisfies $\phi_a(\mu, h_\mu) = 1$ is at most $\frac{3(\mu - i)}{2^\lambda}$. 
\end{subclaim} 

Let $f/N = h$ for $gcd(f, N) = 1$ denote the reduced form of $h \in \mathbb{Q}[X]$. If $\phi_a(i,h) = 0$ then either $N > B_i$ or $||f||_\infty > B_i$ while $\phi_a(\mu, h_\mu) = 1$ implies $h_\mu \in \mathbb{Z}$ and $|h_\mu| \leq B_\mu$.
 Let $\mu' = \mu - i$. Observe that $h_\mu = \frac{1}{N} \cdot g(r_{i+1},...,r_\mu)$ where $g(X_1,...,X_{\mu'}) = \sum_{b \in \{0,1\}^{\mu'}} f_{\sigma(b)} \prod_{j=1}^{\mu'}X_j^{b_i}$ is a multilinear integer polynomial whose $2^{\mu'}$ coefficients are a permutation of the coefficients of $f$. Here $f_j$ denotes the $j$th coefficient of $f \in \mathbb{Z}[X]$ and $\sigma(b)$ is the integer with binary representation $b$. \\
 
 \noindent \textbf{Case 1 $N > B_i$:} If $|N| > B_i$ then since $\log B_i \geq \mathsf{CSZ}_{\mu - i}$, the probability that this final element $h_\mu$ is an integer is equivalent to $\frac{1}{N} \cdot g(r_{i+1},\dots,r_\mu)$ being an integer or equivalently: 
 $$\Prob_{(r_{i+1},...,r_\mu) \gets [0,2^\lambda)^{\mu -i}} [g(r_{i+1},...,r_\mu)\equiv 0 \bmod N] $$
This probability is at most $\frac{\mu - i +1}{2^\lambda}$ by the Multilinear Composite Schwartz-Zippel Lemma (Lemma~\ref{lem:CSZ}).\\

 
\noindent \textbf{Case 2 $N \leq B_i \ \wedge \ ||f||_\infty > B_i$:} 
 
 Since $||g||_\infty = ||f||_\infty$, if $|h_\mu| \leq B_\mu$ then, by the bound on $N$: 
  
 $$|g(r_1,...,r_{\mu-i})| \leq N \cdot B_\mu \leq B_i \cdot B_\mu$$
 Furthermore, since $||g||_\infty = ||f||_\infty > B_i$ and $B_i \geq 2^{\lambda(\mu - i)} B_\mu$, by the Evaluation Bound Lemma (Lemma~\ref{lem:evalbound}): 

$$\Prob[h_\mu \leq B_\mu] \leq \Prob[|g(r_1,...,r_{\mu-i})| \leq B_\mu] \leq \Prob[|g(r_1,...,r_{\mu-i})| \leq \frac{1}{2^{\lambda (\mu - i)}} \cdot ||g||_\infty] \leq  \frac{3(\mu- i)}{2^{\lambda}}$$

 
Together these imply that if $\deg(f) \leq 2^{\mu -i}$ but $\phi_a(i, f/N) = 0$ then, since either $|N| > B_i$ or $||f||_\infty > B_i$, the probability over the random challenges that the final element $h_\mu$ of the list returned by $\textsf{Extend}$ satisfies $\phi_a(\mu, h_\mu) = 1$ is negligible. 

\end{proof} 

\begin{subclaim} 
 For any $i \in [\mu-1]$, given a valid (accepting) transcript with commitments $(\mathcal{C}_0,...,\mathcal{C}_\mu)$, round challenges $(r_1,...,r_\mu)$, and openings $(o_i,...,o_\mu)$ of the last $\mu-i + 1$ commitments to rational polynomials $(h_i,,...,h_\mu)$, where $\phi_b(i, h_i) = 1$ and $\phi_a(j, h_j) = 1$ for all $j \in [i+1,\mu]$, then either $\textsf{Extend}(i, h_i, r_{i+1},...,r_\mu)$ returns $h_{i+1},...,h_{\mu}$ or $\textsf{Break}(i, h_i, (h_i, o_i),...,(h_\mu, o_\mu))$ returns for some $j \geq i$ a valid opening of $\mathcal{C}_j$ to $h'_j \neq h_j$.  %in time $t_E$ with overwhelming probability $1 - \mathsf{RSA}(\GG, t_\mathcal{A} + t_E)$ over the internal randomness of $\mathcal{A}$, where $\mathsf{RSA}(\GG, t)$ denotes the maximum success probability of any $t$-step algorithm in breaking the Strong RSA Assumption over $\GG$. 
\end{subclaim} 
\begin{proof} 
Let $(h'_{i+1},...,h'_\mu)$ denote the output of $\textsf{Extend}(i, h_i, r_{i+1},...,r_\mu)$ and suppose it is not equal to $(h_{i+1},..., h_\mu)$. Let $j \in [i, \mu)$ denote the \emph{first} index for which $h_{j+1} \neq h'_{j+1}$. This means that $h_j = h'_j$ and thus $h'_{j+1} = h_{j, L} + r_{j+1} \cdot h_{j, R}$ where $h_{j, L}$ and $h_{j, R}$ are the left/right halves of $h_{j}$. Additionally, $\phi_b(j, h_{j}) = 1$ implies $h'_{j+1} \in \mathcal{M}(2^{2\lambda + 2} B_{j}^2, 2^{\lambda + 1} B_{j}^2) \subseteq \mathcal{M}(\sqrt{\frac{q}{2}}, \sqrt{\frac{q}{2}})$. 

(Note that for $j \geq i+1$, the condition $\phi_a(j, h_j) = 1$ also implies $\phi_b(j, h_j) = 1$).

Let $\mathcal{C}_{j+1} = ((C_{j+1, L}, y_{j+1,L}), (C_{j+1,R}, y_{j+1,R}))$ and $\mathcal{C}_{j} = ((C_{j,L}, y_{j,L}), (C_{j,R},y_{j,R}))$. 
Let $o_j = (f_j, N_{j})$ denote the opening of $\mathcal{C}_{j}$ to $h_j =\frac{f_j}{N_{j}}$ where $f_{j} = f_{j, L} + X^{2^{\mu - j + 1}} f_{j, R}$. Validity of the opening implies $N_{j} \cdot C_{j,L} = f_{j,L}(q) \cdot \gr{G}$ and $N_{j} \cdot C_{j,R} = f_{j,R}(q) \cdot \gr{G}$. Furthermore, in a valid transcript: 
 $$C_{j+1}  = C_{j, L} + r_{j+1} \cdot C_{j,R} =  C_{j+1,L} + q^{2^{\mu - j}} C_{j+1,R}$$
  Thus, $(N_{j}, f_{j,L} + r_{j+1} \cdot f_{j, R})$ is a valid opening of $C_{j+1}$ to $h'_{j+1}$ as $N_{j} \cdot C_{j+1} = (f_{j, L}(q) + r_{j+1} \cdot f_{j, R}(q)) \cdot \gr{G}$. 

%However, this implies that an algorithm running in time at most $t_\mathcal{A} + t_E$ computes valid openings of $C_j$ to $h'_j \neq h_j$, where both $h'_j, h_j \in \mathcal{M}(\sqrt{\frac{q}{2}}, \sqrt{\frac{q}{2}})$, which breaks the binding property of the commitment scheme (and the Strong RSA assumption over $\GG$). The probability of this succeeding is thus at most $\mathsf{RSA}(\GG, t_\mathcal{A} + t_E)$. 
\end{proof} 

\begin{theorem} DARK special sound protocols are knowledge sound. 
\end{theorem} 

\begin{proof} Relies on the forking lemma...

We show there is an extraction algorithm $\mathcal{E}^\mathcal{A}(C)$ that, given public input $C$ and black-box access to any adversary who succeeds in this protocol with probability $\epsilon > negl(\lambda)$ in expected time $T_{\mathcal{A}}$ on $y$, succeeds with probability $1 - negl(\lambda)/\epsilon^2$ in time $T_\mathcal{A} \cdot poly(\lambda)/\epsilon$ to compute an opening for the input commitment $C$, i.e. values $(m, o)$ such that $\textsf{Verify}(C, m, o) = 1$.  

Components: 
\begin{itemize} 
\item Definition of knowledge soundness (info theoretic)
\item Modified relation that either has original witness or a commitment break 
\item Suppose we have a protocol that is $(k^{(\mu)}, \epsilon)$-DARK special sound. We will make use of algorithms $\textsf{Extract}$, $\textsf{Extend}$, and $\textsf{Break}$ and their properties that are guaranteed to exist by the definition of DARK special soundness. 
\item For any node $\nu$ of a $k+1$-ary transcript tree let $S^*_\nu$ denote the \emph{left} $k$-ary subtree rooted at $\nu$ defined by a breadth first search from $\nu$ that visits only the first $k$ children of each node reached (i.e., prunes the rightmost branch from each node of the complete $k+1$-ary subtree $S_\nu$).

\item We define an algorithm $\textsf{TreeExtract}(\ell_\nu, \nu, \mathcal{C}_\nu, L_{S_\nu})$ that operates on a labeled subtree of a $(k+1)$-ary transcript tree that has depth $\mu$,  where $\ell_\nu$ is the level of $\nu$, $\mathcal{C}_\nu = L(\nu)_1$ is the commitment label on $\nu$ and $L_{S_\nu}$ is a labeling of the $(k+1)$-ary subtree $S_\nu$ rooted at $\nu$. If $\textsf{TreeExtract}(\ell_\nu, \nu, \mathcal{C}_\nu, L_{S_\nu})$ succeeds it returns $\textsf{openSubtree}$, which contains openings of all the commitment labels $L$ assigned to nodes in $S_\nu$ including the label $\mathcal{C}_\nu$ on node $\nu$. Otherwise it returns $\bot$. The algorithms runs as follows: 
\begin{itemize}  
\item If $\nu$ is a leaf node then it returns the opening of $\mathcal{C}_\nu$, which is included in the label on $\nu$. \
\item Else, for each node $\omega \in S_{\nu}$ with label $\mathcal{C}_\omega = L(\omega)_1$ on the second to last level, it sets $\textsf{openLeaves}$ to include the first $k$ opened leaves of $\omega$, and runs the algorithm $\textsf{Extract}(\mu - 1, \omega, \mathcal{C}_\omega, \textsf{openLeaves})$ to get an opening of $\mathcal{C}_\omega$. It continues iteratively: once it has computed openings for all commitment labels of all subtrees rooted at the $i$th level, for each node $\omega$ on the $(i+1)$st level with label $\mathcal{C}_\omega = L(\omega)_1$ it runs $\textsf{Extract}(i, \omega, \mathcal{C}_\omega, \textsf{openSubtree}^*_\omega)$ on the commitment label openings $\textsf{openSubtree}^*_\omega$ of the left $k$-ary subtree $S^*_\omega$ (excluding node $\omega$), which were computed in prior iterations. 
\end{itemize}

The \textsf{TreeExtract} algorithm is not guaranteed to succeed. In particular, the internal calls to $\textsf{Extract}$ are only guaranteed to succeed when the openings of subtrees satisfy predicate $\phi_a$ and the challenge labels are distinct within the pruned subtrees $S^*_\nu$. By convention, if any internal step fails then \textsf{TreeExtract} outputs $\bot$. 

\textbf{Remark:} While $\textsf{TreeExtract}$ operates on $k+1$-ary transcript tree, the internal calls to $\textsf{Extract}$ run on $k$-ary transcript trees because the protocol is $(k^{(\mu)}, \epsilon)$-DARK special sound. Furthermore, the reason we always pass the labeling/opening of the left $k$-ary subtree (as opposed to an arbitrary $k$-ary subtree) to $\textsf{Extract}$ is to ensure that the opening of $\mathcal{C}_\nu$ included in the output of $\textsf{TreeExtract}(\ell_\nu, \mathcal{C}_\nu, L_{S_\nu})$ is a function of only the labels on the left $k$-ary subtree $S^*_\nu$, and in particular is computed independently from any of the labels in the (right) subtree rooted at the third (right) child of $\nu$. We will use this fact in the next step. We will denote by $\textsf{TreeExtract}^*(\ell_\nu, \mathcal{C}_\nu, L_{S^*_\nu})$ the algorithm that only extracts openings of the commitments in $L_{S^*_\nu}$ and returns and opening of $C_\nu$. This runs exactly like $\textsf{TreeExtract}$ except that it only iterates over nodes that are present in the left $k$-ary subtree $S^*_\nu$. While it is possible that $\textsf{TreeExtract}$ fails and $\textsf{TreeExtract}^*$ succeeds, it is easy to see that they output the same opening of $C_\nu$ assuming both succeed. 

\item Let $\textsf{size}(k, \mu) = \frac{k^{\mu+1}-1}{k-1}$, which is the number of nodes is a $k$-ary depth $\mu$ tree. Given any $\mu$-round protocol that satisfies DARK special soundness, setting $N = \textsf{size}(3, \mu)$ we will define a collection of predicates $\{\pi_\nu: \nu \in [1,N]\}$ for the nodes of a ternary transcript tree with post-order labeling $L$, such that each $\pi_\nu$ is a function of the partial labeling $L_{\nu^*}$ and a $\mu - \ell_\nu$-length challenge vector $\mathbf{r} \in \mathcal{X}^{\mu - \ell_\nu}$, where $\ell_\nu$ is the level of node $\nu$ in the tree. Recall that $\nu^* < \nu$ is the node of highest index smaller than $\nu$ that is not a member of the subtree of $\nu$, and $L_{\nu^*}$ are the labels of all nodes numbered $[1, \nu^*]$. Let $\omega$ denote the parent node of $\nu$. The predicate $\pi_\nu(L_{\nu^*}, \mathbf{r})$ is defined as follows: 
\begin{itemize} 
\item If $\nu$ has no left-sibling, then $\pi_\nu$ always returns $1$. 
\item If $\nu$ has one left-sibling $\nu'$ (i.e., is a middle child) and $r' = L(\nu')_0$ is the challenge label assigned to the incoming edge of $\nu'$ then $\pi_\nu(L_{\nu^*}, \mathbf{r}) = 1$ iff $r'$ is distinct from the first component of $\mathbf{r}$, i.e. $\mathbf{r}_0 \neq r'$. Note that $\nu' \in [1, \nu^*]$ so $L(\nu')$ is included in the input $L_{\nu^*}$ to $\pi_\nu$. 
\item If $\nu$ has no right-sibling (i.e., is last child) then let $\mathcal{C}_\omega = L(\omega)_1$ denote the commitment label on $\omega$, let $(m_\omega, o_\omega)$ denote the opening of $\mathcal{C}_\omega$ returned by $\textsf{TreeExtract}^*(\ell_\omega, \omega, \mathcal{C}_\omega, L_{S^*_\omega})$ (if successful), let $m'$ denote the last message in the output list of $\textsf{Extend}(\ell_\omega, m_\omega,\mathbf{r})$ and finally: 

 $$\pi_\nu(L_{\nu^*}, \mathbf{r}) = 
 \begin{cases} 0 \quad\quad \text{ if }  \textsf{TreeExtract}^*(\ell_\omega, \omega, \mathcal{C}_\omega, L_{S^*_\omega}) = \bot \\ 
 1 \quad \quad \text{ if } \phi_a(\ell_\omega, m_\omega) = 1\\
 1 \quad \quad \text{ if } \phi_a(\ell_\omega, m_\omega) = 0 \wedge \phi_a(\mu, m') = 0 \\ 
0 \text{ otherwise} 
\end{cases} $$ 

As remarked above, while $\textsf{TreeExtract}$ operates on the entire $(k+1)$-ary subtree of labels rooted at $\omega$, the algorithm $\textsf{TreeExtract}^*$ takes as input only the labeling of the right $k$-ary subtree $S^*_\omega$ and $L_{S^*_\omega} \subseteq L_{\nu^*}$. 

\end{itemize}

\item By the Forking Lemma, there is an algorithm that generates a $(k+1)$-ary $\mu$-depth transcript tree in time ??? with labeling $L$ such that $\pi_\nu(L_{\nu*}, \textsf{rpath}(\nu)) = 1$ for every node $\nu$, where $\textsf{rpath}(\nu)$ denotes the challenge labels $L(\cdot)_0$ along the rightmost branch from $\nu$ to a leaf starting with the label $L(\nu)_0$ on $\nu$. In particular, this means that: 
\begin{enumerate}
\item The challenge labels on the first two children of any internal node are distinct, i.e., if $\omega$ is an internal node with children $\nu_1, \nu_2, \nu_3$ ordered from left-to-right, then $L_0(\nu_1) \neq L_0(\nu_2)$. 
\item  If running $\textsf{TreeExtract}(\ell_\omega, \omega, \mathcal{C}_\omega, L_{S^*_\omega})$ on the parent $\omega$ of $\nu$ (at level $\ell_\omega$) returns an opening of $\mathcal{C}_\omega$ to $m_\omega$ such that $\phi_a(\ell_\omega, m_\omega) \neq 1$, then the final output of $\textsf{Extend}(\ell_\omega, m_\omega, \textsf{rpath}(\nu))$ is a message $m'$ such that $\phi_a(\mu, m') \neq 1$. 
\end{enumerate} 

\item We will argue that,  for any $\omega \in [1,N]$, either $\textsf{TreeExtract}(\ell_\omega, \omega, \mathcal{C}_\omega, L_{S_\omega})$ returns a subtree $\textsf{openSubtree}$ of openings of the commitment labels in $L_{S_\omega}$ satisfying $\phi_a$ (i.e., each opening of a label $C_\omega$ to $m_\omega$ for a node $\omega$ on level $\ell_\omega$ satisfies $\phi_a(\ell_\omega, m_\omega) = 1$) or else there is an efficient algorithm that uses $\textsf{openSubtree}$ and $L$ to break the commitment scheme. 

\textbf{Step 1:} Suppose that $\omega$ is a node of highest level $\ell_{\omega}$ for which this fails, i.e. the output of $\textsf{TreeExtract}$ satisfies $\phi_a$ for any node of higher level than $\ell_\omega$. 
This means that all the openings of internal (non-root) nodes of the subtree $L_{S_\omega}$ computed while running $\textsf{TreeExtact}$ on $\omega$ satisfy $\phi_a$. Furthermore, $L$ has the property that all labels on the first two siblings are distinct. 

\textbf{Step 2:} By the definition of DARK special soundness and the hypothesis in \textbf{Step 1}, $\textsf{TreeExtract}(\ell_\omega, \omega, \mathcal{C}_\omega, L_{S_\omega})$ succeeds in returning $\textsf{openSubtree}$ consisting of the openings of $L_{S_\omega}$ such that the openings of all internal (non-root) nodes satisfy $\phi_a$, and the opening $(m_\omega, o_\omega)$ of the subtree root $\omega$ satisfies $\phi_b(\ell_\omega, m_\omega) = 1$. The opening $(m_\omega, o_\omega)$ is also identical to the output of $\textsf{TreeExtract}^*(\ell_\omega, \omega, \mathcal{C}_\omega, L_{S^*_\omega})$. 

\textbf{Step 3:} Let $\nu$ denote the rightmost child of $\omega$. By the property of $L$ that $\pi_\nu(L_{\nu^*}, \textsf{rpath}(\nu)) = 1$, if $\phi_a(\ell_\omega, m_\omega) = 0$ then the final output of $\textsf{Extend}(\ell_\omega, m_\omega, \textsf{rpath}(\nu))$ is a message $m'$ such that $\phi_a(\mu, m') = 0$. However, this implies that $m'$ must be distinct from the label $L$ assigns to the leaf node of the rightmost branch extending from $\nu$. Let $v_1,...,v_\mu$ denote the nodes along the root-to-leaf path passing through node $\omega$ and ending with its rightmost branch so that $\textsf{rpath}(\nu) = (L(v_{\ell_\nu})_0,...,L(v_\mu)_0)$. For each $i \in [1, \mu]$ let $\hat{C}_i = L(v_i)_1$ and $\mathbf{\hat{C}} = (\hat{C}_1,...,\hat{C}_\mu)$. Finally, since $\textsf{openSubtree}$ contains openings $(m_{\ell_\nu}, o_{\ell_\nu}),...(m_\mu, o_\mu)$ of the commitments $\hat{C}_{\ell_\nu},...\hat{C}_\mu$ that all satisfy predicate $\phi_a(i, m_i) = 1$, and $\phi_b(\ell_\omega, m_\omega) = 1$, if $m' \neq m_\mu$ then by the definition of DARK special soundness this implies that $\textsf{Break}(\ell_\omega, m_\omega,  \textsf{rpath}(\nu), \mathbf{\hat{C}}, (m_{\ell_\nu}, o_{\ell_\nu}),...(m_{\mu}, o_{\mu}))$ outputs a conflicting opening of some commitment label in $\mathbf{\hat{C}}$. 

\item Let $\mathcal{C}_1 = L(1)_1$, the transcript tree root. The extractor runs $\textsf{TreeExtract}(0, 1, \mathcal{C}_1, L_{S_1})$, which returns $\textsf{openTree}$. If every opening in $\textsf{openTree}$ satisfies predicate $\phi_a$ then it runs $\textsf{Extract}(0, \mathsf{x}, \textsf{openTree})$ to obtain witness $\mathsf{w}$ satisfying $R(\mathsf{x}, \mathsf{w}) = 1$. Otherwise, it uses the $\textsf{Break}$ algorithm (as described in the previous step) to output conflicting openings of a commitment. 
\end{itemize} 

\end{proof} 


\section{Security Proofs (old delete from here)}
\label{appendix:hardness}
In the preliminaries we already stated the two main hardness assumptions, the $r$-Strong RSA Assumption and the Adaptive Root Assumption.
\input{sections/hardness}

\subsection{Binding}
\label{appendix:binding}
%\def\thelemma{\ref{lem:binding}}
\benedikt{Update this to order assumption}
\newtheorem*{lemmabinding}{Lemma \ref{lem:binding}}
\begin{lemmabinding}
	\bindinglemma
\end{lemmabinding}
\begin{proof}
    Assume that there is an adversary that breaks the binding property of the scheme. Specifically, assume that some probabilistic polynomial time algorithm $\adv$ takes as input $\params$ and outputs $\gr{C} \in \GG, f(X) \in \ZZ(b)[X], f'(X)\in \ZZ(b)[X]$ such that with non-negligble probability $\pro{Open}(\params, \gr{C}, \tilde{f}(X), f(X)) = \pro{Open}(\params, \gr{C}, \tilde{f'}(X), f'(X)) = 1$ and $\tilde{f}(X) \neq \tilde{f'}(X)$. We proceed to show that this implies a violation of the Order Assumption~(Assumption \ref{assum:order}) and the Strong RSA Assumption~(Assumption \ref{assum:strongRSA}). The assumptions are incomparable so we show that either suffices to achieve the binding property of the commitment scheme.
    
	If $f(X)\neq f'(X)$ and $q/2>b$ then $f(q)\neq f'(q)\in \ZZ$. Since $\gr{g}^{f(q)}=\gr{g}^{f'(q)}=\gr{C}$ we have that $\gr{g}^{f(q)-f'(q)}=1$. This directly breaks the Order Assumption and we can also create an adversary $\adv_{RSA}$ that breaks the Strong RSA Assumption. To do so the $\adv_{RSA}$ picks an odd prime $\ell$ that is co-prime with $f(q)-f'(q)$ and computes $\gr{u}\gets \gr{g}^{\ell^{-1} \bmod (f(q)-f'(q))}$ as the $\ell$th root of $\gr{g}$.
\end{proof}

\subsection{Correctness}
\label{appendix:correctness}

%\def\thelemma{\ref{lem:correctness}}
\newtheorem*{lemmacorrectness}{Lemma \ref{lem:correctness}}
\begin{lemmacorrectness}
	\correctnesslemma
\end{lemmacorrectness}

\begin{proof}
In order to ensure correctness we must ensure that $b< q/2$ and that $|f|\leq b$. To show this we show that in each recursion step the honest prover's witness polynomial has coefficients bounded by $b$ and has degree $d$. 
We argue inductively that for each recursive call of $\pro{EvalBounded}$ the following constraints on the inputs are satisfied: The degree of $f(X)$ is bounded by $d$. $\gr{C}$ encodes the polynomial, \emph{i.e.}, $\gr{C}=\gr{g}^{f(q)}$ and $f(X)\in \ZZ(b)$. Also $f(z) = y\bmod p$.

Initially, during the execution of $\eval$, the prover maps the coefficients of a polynomial $\tilde{f}(X)\in \ZZ_p$ to an integer polynomial $f(X)$ with coefficients in $\ZZ(\frac{p-1}{2})$ and degree at most $d$ such that $\gr{C}=\gr{g}^{f(q)}$. Additionally $f(z)\bmod p=\tilde{f}(z)=y$.

 In a recursion steps where $d+1$ is odd, $f'(X)=X\cdot f(X)$ is a polynomial of degree $d+1$ such that $\gr{C}'=\gr{C}^q=\gr{g}^{q\cdot f(q)}=\gr{g}^{f'(X)}$ and the bound $b$ is unchanged as are the coefficients. Also, $f'(z)\bmod p = z \cdot f(z) \bmod p=z\cdot y\bmod p = y' \bmod p$. If $d+1$ is odd, then in the next step $d+1$ must be even.
 
 If $d+1$ is even then, $\prover$ computes $f_L(X)$ and $f_R(X)$ such that $f_L(X)+X^{\frac{d+1}{2}} f_R(X)=f(X)$. Consequently $f(z) \bmod p=f_L(z)+ z^{\frac{d+1}{2}} f_R(z)\bmod p=y_L+z^{\frac{d+1}{2}}  y_R\bmod p =y$. The \textsf{PoE} protocol has perfect correctness so {$\gr{g}^{f_L(q)+q^{\frac{d+1}{2}} f_R(X)}=\gr{C}$}.
 %\gr{C}_L\gr{C}_R^{(q^{\frac{d+1}{2}})}
 Finally $f'(X)=\alpha f_L(X) + f_R(X)\in \ZZ(\frac{p+1}{2}\cdot b)$ is a degree $d$ polynomial with coefficients bounded in absolute value by $(\frac{p+1}{2})\cdot b$. This is precisely the value of $b'$ the input to the next call of $\pro{EvalBounded}$. The value $y'$ is also correct:
$f'(z)\bmod p=\alpha f_L(z) +f_R(z) \bmod p= \alpha y_L +y_R\bmod p=y'$
 
 There are exactly $\lceil\log_2(d+1)\rceil$ recursion steps with even $d+1$. In the final recursion step we therefore have $b=\frac{p-1}{2}(\frac{p+1}{2})^{\lceil\log_2(d+1)\rceil}$ and as such the requirement that $q/2>\frac{p-1}{2}(\frac{p+1}{2})^{\lceil\log_2(d+1)\rceil}$. 
 So if $q>p^{\lceil\log_2(d+1)\rceil+1}\geq (p-1) (\frac{p+1}{2})^{\lceil \log_2(d+1)\rceil}$ then all verifier checks pass and the verifier outputs $1$.
\end{proof} 


\subsection{Proof of Theorem~\ref{thm:polycommitsecurity}}
\label{appendix:maintheoremproof}

\paragraph{Security of $\textsf{PoE}$ substitutions}
We first begin by showing that we can safely replace all of the $\textsf{PoE}$ evaluations with direct verification checks. Concretely, under the Adaptive Root Assumption, the $\eval$ protocol is as secure as the protocol $\eval'$ in which all $\textsf{PoE}$s are replaced by direct checks. We show that the witness-extended emulation for $\eval'$ implies the same property for $\eval$. This is useful because we will later show how to can build an extractor for $\eval'$, thereby showing that the same witness-extended emulation property extends to $\eval$.

\begin{lemma} \label{lemma:poe_security}
Let $\eval'$ be the protocol that is identical to $\eval$ but in line \ref{line:PoE} of $\pro{EvalBounded}$ $\verifier$ directly checks $\gr{C}_L\gr{C}_R^{q^{d'+1}}=\gr{C}$ instead of using a $\textsf{PoE}$. If the Adaptive Root Assumption holds for $\ggen$, and $\eval'$ has witness-extended emulation for polynomials of degree $d=\poly$, then so does $\eval$.
\end{lemma}

\begin{proof}
We show that if an extractor $E'$, as defined in Definition~\ref{def:wee}, exists for the protocol $\eval'$ then we can construct an extractor $E$ for the protocol $\eval$. Specifically, $E$ simulates $E'$ and presents it with a $\pro{Record}'(\cdots)$ oracle, while extracting the witness from its own $\pro{Record}(\cdots)$ oracle.

Whenever $E'$ queries the $\pro{Record}'$ oracle, $E$ queries its $\pro{Record}$ oracle and relays the response after dropping those portions of the transcript that correspond to the $\mathsf{PoE}$ proofs. Whenever $E'$ rewinds its prover, so does $E$ rewind its prover. When $E'$ terminates by outputting a transcript-and-witness pair $(\mathsf{tr}', f(X))$, $E$ adds $\mathsf{PoE}$s into this transcript to obtain $\mathsf{tr}$ and outputs $(\mathsf{tr}, f(X))$.

For each PPT adversary $(\adv,P^*)$, $E$ will receive a polynomial number of transcripts from its $\pro{Record}$ oracle. Any transcript $\tr$ of $\eval$ such that $\adv(\tr)=1$ and $\tr$ is accepting contains exactly $\lceil \log(d+1)\rceil$ $\textsf{PoE}s$ transcripts. 
So in total $E$ sees only a polynomial number of $\textsf{PoE}$ transcripts generated by a probabilistic polynomial-time prover and verifier. By Lemma~\ref{lem:poe} under the Adaptive Root Assumption, the probability that a polynomial time adversary can break the soundness of $\textsf{PoE}$, \emph{i.e.}, convince a verifier on an instance $(\gr{C}_R,\gr{C}/\gr{C}_{L},q^{d'+1})\not\in\mathcal{R}_{\textsf{PoE}}$, is negligible. 
Consequently, the probability that the adversary can break $\textsf{PoE}$ on \emph{any} of the polynomial number of executions of $\mathsf{PoE}$ is still negligible.

This means that with overwhelming probability all transcripts are equivalent to having the verifier directly check $(\gr{C}_R,\gr{C}/\gr{C}_{L},q^{d'+1})\in\mathcal{R}_{\textsf{PoE}}$. By assumption, the witness-candidate $f(X)$ that $E'$ outputs is a valid witness if the transcript $\mathsf{tr}'$ that $E'$ also outputs is accepting. The addition of honest $\mathsf{PoE}$ transcripts to $\mathsf{tr}'$ preserves the transcript's validity. So $\mathsf{tr}$ is an accepting transcript for $\pro{Eval}$ if and only if $\mathsf{tr}'$ is an accepting transcript for $\pro{Eval}'$. Therefore, $E'$ outputs a valid witness $f(X)$ whenever $E$ outputs a valid witness. This suffices to show that $\pro{Eval}$ has witness-extended emulation if $\pro{Eval}'$ has, and if the Adaptive Root Assumption holds for $\ggen$.
\end{proof}

\paragraph{Combining statements.} The $\eval$ protocol combines two statements into one by using a random linear combination of group elements, \emph{i.e.}, $\gr{C}'\gets \gr{C}_L^{\alpha}\gr{C}_R$. We now show that this step is sound and that given the discrete logarithm for $\gr{C}'$ the extractor can extract the discrete logarithm for $\gr{C}_L$ and $\gr{C}_R$ we also show that the we can bound the size of the discrete logarithm. We show that this statement holds in two settings. First we consider a group $\GG$ were the standard Strong RSA Assumption holds and group elements are encodings of integers. 
%Move next part to after lemma?
Then we will show that in groups in which taking square roots is easy we can extract dyadic rationals using the 2-Strong RSA Assumption.
 %For $\GG \gets \ggen(\lambda)$, and $\gr{g}\sample \GG$. Let $(\gr{C}_L\in \GG,\gr{C}_R\in \GG,\alpha\in [0,p-1],f\in [0,b];\gr{g}^{f}=\gr{C}_L^{\alpha}\gr{C}_R)$ and  $(\gr{C}_L,\gr{C}_R,\alpha'\in [0,p-1],f'\in [0,b];\gr{g}^{f'}=\gr{C}_L^{\alpha'}\gr{C}_R)$  be two transcripts for $\alpha\neq \alpha'$.
\begin{lemma}[Combining for integer witnesses]
\label{lem:intrandomcombine}
	For $\GG \gets \ggen(\lambda)$, and $\gr{g}\sample \GG$. 
	Let $(z,\gr{C}_L,\gr{C}_R,y_L,y_R,\alpha,f,y)$ and  $(z,\gr{C}_L,\gr{C}_R,y_L,y_R,\alpha',f',y')$ be two transcripts such that $\gr{g}^{f}=\gr{C}_L^{\alpha}\gr{C}_R$ and $\gr{g}^{f'}=\gr{C}_L^{\alpha'}\gr{C}_R$ for group elements $\gr{C}_L,\gr{C}_R \in \GG$, and integers $\alpha,\alpha' \in  [-\frac{p-1}{2},\frac{p-1}{2}]$, $\alpha\neq \alpha'$. Further let $f,f'\in \ZZ$ be such that $f(X)\gets\dec(f)$ and $f'(X)\gets\dec(f')$ are degree $d$ bounded polynomials with coefficients bounded by $b$, \emph{i.e.}, $f(X),f'(X)\in \ZZ(b)[X]\subset \ZZ[X]$. And finally let $y=f(z)\bmod p$ and $y'=f'(z)\bmod p$.
	 Then there exists a PPT algorithm $\mathcal{X}$ that given these transcripts computes either (1) $y_L,y_R\in \ZZ_p,f_L(X),f_R(X)\in \ZZ((p-1) \cdot b)[X]$  such that $f_L(z)=y_L\bmod p$ and $f_R(z)=y_R \bmod p$ or (2) an element in $\GG$ of known order or (3) a fractional root of $\gr{g}$.
\end{lemma}
\begin{proof}
	Using the transcripts $\mathcal{X}$ computes $\Delta_\alpha\gets\alpha-\alpha'$ and $\Delta_f\gets f-f'$ such that $\gr{C}_{L}^{\Delta_\alpha}=\gr{g}^{\Delta_f}$. 
 If $\frac{\Delta_f}{\Delta_\alpha}$ is not an integer then $\mathcal{X}$ outputs a fractional root of $\gr{g}$, that is the tuple $(\Delta_f,\Delta_\alpha,\gr{C}_{L})$.  
 If $\frac{\Delta_f}{\Delta_\alpha}$ on the other hand is an integer then $\mathcal{X}$ can compute $\gr{D}\gets\gr{g}^{\frac{\Delta_f}{\Delta_\alpha}}$. Either $\gr{D}=\gr{C}_{L}$ or $(\gr{D}/\gr{C}_{L})^{\Delta_\alpha}=1$. In the second case, $\gr{D}/\gr{C}_{L}$ is an element of known order.
   
  Otherwise $\gr{D} = \gr{C}_L$ and we have $\gr{C}_{L}=\gr{g}^{f_L}$ where $f_L=\frac{\Delta_f}{\Delta_\alpha}$ is an integer.
Additionally $\gr{C}_R=\gr{g}^{f_R}$ for $f_R\gets f-\alpha \cdot f_L$.

$\mathcal{X}$ now computes the corresponding polynomials $f_L(X)\gets \dec(f_L)$ and $f_R(X)\gets \dec(f_R)$.
Now if for all $i$, the coefficients $f_i$ and $f'_i\in [-b,b]$ and $\alpha,\alpha' \in [-\frac{p-1}{2},\frac{p-1}{2}]$ then by the triangle inequality we have that for the $i$th coefficient of $f_L(X)$, $f_{L,i}\in [-2b,2b]$. Additionally we have $f_{R,i}=\frac{f_i'\alpha-f_i \alpha'}{\Delta_\alpha}$. Using the triangle inequality again we have that $f_{R,i} \in [-(p-1) \cdot b, (p-1) \cdot b]$. For an odd prime $p$, $(p-1)\cdot p\geq 2$. The bound on $f_{R,i}$ is, therefore, greater than the bound on $f_{L,i}$. This gives us $f_L(X),f_R(X)\in \ZZ({(p-1) \cdot b})[X]$

Let $y_L=\frac{y-y'}{\Delta_\alpha} \bmod p=\frac{f(z)-f'(z)}{\Delta \alpha} \bmod p$ and $y_R= y-\alpha\frac{y-y'}{\Delta_\alpha} \bmod p$. Since $f_L(X)=\frac{f(X)-f'(X)}{\Delta \alpha}$ this shows that $y_L=f_L(z)\bmod p$ and $y_R=f_R(z)\bmod p$.
%The actual bound on f_{R,i} is b*(p-2)
\end{proof}

\def\thetheorem{\ref{thm:polycommitsecurity}}
\begin{theorem}
\maintheorem
\end{theorem}
\input{sections/proofofmaintheorem.tex}

%%%%%DYADIC


\subsection{Proof of Theorem~\ref{thm:dyadicpolysecurity}}
\label{apx:dyadic}
We begin by stating and proving the combining lemma, (Lemma~\ref{lem:intrandomcombine}) for dyadic rational witnesses.
%PROOF FOR DYADIC RATIONALS
\begin{lemma}[Combining for Dyadic Rational Witnesses]
\label{lem:dyadiccombining}
Let $\tr$ and $\tr'$ be two transcripts as specified in Lemma \ref{lem:intrandomcombine} with the difference that $f,f'\in \mathbb{D}$ are dyadic rationals such that $f(X)\gets \dec(f)$ and $f'(X)\gets \dec(f')$ are degree $d$ bounded dyadic rational polynomials with coefficients' numerators bounded by $N$ and denominators bounded by $D$, i.e. $f(X),f'(X)\in\mathbb{D}(N,D)$.
Assume that there exists a PPT algorithm for taking square roots of any element in $\GG$ and that the order of $\GG$ is odd, then there exists a PPT algorithm $\mathcal{X}$ that given these transcripts computes either (1) $y_L,y_R\in \ZZ_p,f_L(X),f_R(X)\in \mathbb{D}(N\cdot (p-1),D\cdot (p-1))[X]$  such that $f_L(z)=y_L\bmod p$ and $f_R(z)=y_R \bmod p$ or (2) an element in $\GG$ of known order or (3) a non-power of $2$ fractional root of $\gr{g}$.
\end{lemma}
\begin{proof}
The proof follows a similar structure to the proof of Lemma~\ref{lem:intrandomcombine}. 
		
	Using the transcripts we get $\Delta_\alpha\gets\alpha-\alpha'$ and $\Delta_f\gets f-f'$ such that $\gr{C}_{L}^{\Delta_\alpha}=\gr{g}^{\Delta_f}$. 
 If $\frac{\Delta_f}{\Delta_\alpha}$ is not a dyadic rational then this gives us a non-power of $2$ fractional root of $\gr{g}$ root of $\gr{g}$, that is the tuple $(\Delta_f,\Delta_\alpha,\gr{C}_{L})$.  
 If $\frac{\Delta_f}{\Delta_\alpha}$ on the other hand is a dyadic rational then we can compute $\gr{D}\gets\gr{g}^{\frac{\Delta_f}{\Delta_\alpha}}$. This may requires taking a power of $2$ root. By assumption the group order is odd, so every element has a square root and there exists an efficient algorithm for taking square roots. This implies that taking higher power of $2$ roots is also efficient.
  
  Now either $\gr{D} = \gr{C}_L=\gr{g}^{f_L}$ or we can extract an element of known order. Additionally $\gr{C}_R=\gr{g}^{f_R}$ for $f_R\gets f-\alpha \cdot f_L$.

 We now compute the corresponding polynomials $f_L(X)\gets \dec(f_L)$ and $f_R(X)\gets \dec(f_R)$.
Now if the coefficients $f_i$ and $f'_i\in \mathbb{D}(N,D)$ and $\alpha,\alpha' \in [-\frac{p-1}{2},\frac{p-1}{2}]$ then by the triangle inequality we have that for the numerator of the $i$th coefficient of $f_L(X)$ is between $[-2N,2N]$. The denominator grows by at most $p-1$. The bound on the denominators is therefore $D\cdot (p-1)$. Additionally we have $f_{R,i}=\frac{f_i'\alpha-f_i \alpha'}{\Delta_\alpha}$. Using the triangle inequality again we have that the numerator of $f_{R,i} \in [-(p-1) \cdot N, (p-1) \cdot N]$. The denominator is bounded by $D\cdot (p-1)$. This gives us $f_L(X),f_R(X)\in \mathbb{D}((p-1) \cdot N,D\cdot (p-1))[X]$

Finally $y_L=f_L(z)$ and $y_R=f_R(z)$ as in Lemma~\ref{lem:intrandomcombine}. It is important that $2$ is co-prime with the odd prime $p$ such that each dyadic rational can be mapped to a field element.
\end{proof}


We now restate the theorem for the security of the protocol with dyadic rational witnesses in groups where taking square roots is easy.

\def\thetheorem{\ref{thm:dyadicpolysecurity}}
\begin{theorem}
\dyadicmaintheorem
\end{theorem}

\begin{proof}
The proof largely follows the same structure of the proof of Theorem~\ref{thm:polycommitsecurity}.
	
We will prove security by showing that we can extract a dyadic rational polynomial $f(X)\in \mathbb{Z}[X]$ such that $f(X)$ has degree at most $d$ and the coefficients of $f(X)$ are dyadic rationals such that the product of the numerator and denominator is bounded by $q/2$. This ensures that $f(q)$ is a unique encoding of $f(X)$. Additionally $\gr{g}^{f(q)}=\gr{C}$ and $f(z) \bmod p=y$. The proof will use the general forking lemma (Lemma \ref{lemma:GFL}) to show that the polynomial commitment scheme has witness-extended emulation. 

We use the same extractor $\mathcal{X}$ as in Theorem \ref{thm:polycommitsecurity} with one key distinction. 
For $d+1$ odd we invoke the extractor described by Lemma~\ref{lem:dyadiccombining} instead of Lemma~\ref{lem:intrandomcombine}. 
This means that at every tree level either bounded dyadic rational witness polynomials are extracted or an element of known order or a non-power of $2$ fractional root of $\gr{g}$. By assumption the ladder two cases happen only with negligible probability.

We, therefore, now need to compute a bound on the size of the extracted polynomial. 
The check on $f$ ensures that $f\in \ZZ$ and that $|f|\leq b=\frac{p-1}{2} (\frac{p+1}{2})^{\lceil \log_2(d+1)\rceil}$. We can write $f\in\mathbb{D}(\frac{p-1}{2} (\frac{p+1}{2})^{\lceil \log_2(d+1)\rceil},1)$. By \ref{lem:intrandomcombine} both the numerator and the denominator grow by at most a factor $p-1$ in every round.
Given that the transcript tree has depth $\lceil \log_2(d+1)\rceil$ we get that the final extracted polynomial $f_0(X)\in \mathbb{D}(N,D)[X]$ has coefficients with numerators bounded by $N= \frac{p-1}{2}(\frac{p^2-1}{2})^{\lceil \log_2(d+1)\rceil}$ and denominators bounded by $D=(p-1)^{\lceil \log_2(d+1)\rceil}$

$q$ needs to be large enough such that $f_0(X)$ is uniquely decodable, \emph{i.e.}, $q>2\cdot N\cdot b=(p-1)^{\lceil \log_2(d+1)\rceil+1}(\frac{p^2-1}{2})^{\lceil \log_2(d+1)\rceil}$. In a simpler form $q>p^{3\lceil\log_2(d+1)\rceil+1}$ suffices.

This shows that we can successfully extract either a witness or a non-power of $2$ fractional root or an element of known order from any tree of valid transcripts.
Under the $2$-Fractional Root Assumption and the Order Assumption, the probability that a polynomial time adversary along with a polynomial time extractor $\mathcal{X}$ can produce such a a  non-power of $2$ fractional root or an element of known order is negligible. $\eval'$, therefore, has witness extended emulation and under the Adaptive Root Assumption by Lemma \ref{lemma:poe_security} so does $\eval$.
Lemma \ref{lem:ordertoadaptive} and Lemma \ref{lem:strongtofractional} show that we can reduce the hardness assumptions to just the Adaptive Root Assumption and the  $2$-Strong RSA Assumption. 
\end{proof}

%\section{Hiding Polynomial Commitment with HVZK Eval} 
%\label{appendix:zeroknowlege}
%\input{sections/zk}


\subsection{Proof of Theorem~\ref{thm:joined}} \label{appendix:joined}

\def\thetheorem{\ref{thm:joined}}
\begin{theorem}
\theoremjoined
\end{theorem}

\begin{proof}
    Correctness is immediate and witness extended emulation requires a single application of Lemma~\ref{lem:intrandomcombine} which leads to an updated bound on $q$. In general $q$ needs to be $\frac{p^2-1}{2}$ larger for any random linear combination that is taken with $\alpha \in [-\frac{p-1}{2},\frac{p-1}{2}]$. For class groups, Lemma~\ref{lem:dyadiccombining} is used and the lower bound on $q$ grows by a factor of $(p-1)^2\frac{p+1}{2}\leq p^3$.
\end{proof}



\section{Proof of Theorem~\ref{thm:IOPcompiler} (Polynomial IOP Compilation)}\label{sec:IOPcompilerproof}


\def\thetheorem{\ref{thm:IOPcompiler}}
\begin{theorem}
\theoremIOPcompiler
\end{theorem}

The fact that the compilation preserves HVZK is straightforward. We prove this part first and then move on to proving witness-extended emulation. 

\paragraph{HVZK}
\begin{proof} Let $S_\eval$ denote the HVZK simulator for $\eval$ and $S_\pro{IOP}$ denote the HVZK simulator for the original polynomial IOP. We construct an HVZK simulator $S$ for the compiled interactive argument as follows. 
$S$ begins by running $S_\pro{IOP}$ on the input $x$, which produces a series of query/response pairs to arbitrarily labeled oracles that are ``sent" from the IOP prover to the verifier. $S$ simulates the view of the honest verifier in the compiled interactive proof by replacing each distinctly labeled oracle with a fresh $\Gamma$ commitment to $0$, \emph{i.e.}, the zero polynomial over $\FF_p$. By the hiding property of $\Gamma$ this has negligible distance $\delta_0$ from the commitment sent in the real protocol.
(It places this commitment at the location in the transcript where the commitment to this oracle would be sent in the compiled protocol).
 For each query/response pair $(z, y)$ to an oracle, $S$ runs $S_\eval$ to simulate the view of an honest-verifier in the $\eval$ protocol opening a hiding polynomial commitment to the value $y$ at the point $z$. Let $P$ denote an upper bound on the total number of oracles sent and $Q$ denote an upper bound on the total number of queries to IOP oracles. 
If the simulation of $S_\pro{IOP}$ has statistical distance $\delta_1$ from the real IOP verifier's view, and each simulated $\eval$ subprotocol has statistical distance $\delta_2$ to the real $\eval$ verifier's view, then the output of $S$ has statistical distance at most $P \delta_0 + \delta_1 + Q \delta_2$ from $\textsf{View}_{\langle P(x, w), V(x) \rangle}$. For $P, Q < \poly$ and $\delta_0, \delta_1, \delta_2 < \negl$ this statistical distance is negligible in $\lambda$. 
\end{proof}

\paragraph{Witness-extended emulation (knowledge)}

\begin{proof}
Without loss of generality, assume the original IOP makes at least one query to each oracle sent. An oracle which is never queried can be omitted from the IOP.

We denote by $\verifier$ the IP verifier for the compiled IP, and $\verifier_{O}$ the verifier for the original IOP. 
Given a record oracle $\pro{Record}(P^*, \params, x, \st)$ for an IP prover $P^*$ that produces accepting transcripts with non-negligible probability, we build an emulator $E$ for the compiled IP. $E$ begins by constructing an IOP adversary $P'_{O}$, which succeeds also with non-negligible probability on input $x$. Every successful interaction of $P'_{O}$ with $\verifier_{O}$ on input $x$ corresponds to a successful transcript of $P^*$ with $V$ on $x$. In showing how $E$ builds $P'_{O}$ we also show how $E$ can obtain this corresponding transcript. $E$ will make use of the emulator $E_\eval$ for the commitment scheme $\Gamma$. %We will describe how this is done in the later parts of the proof. Accepting that this is true. 

Finally, $E$ can use the IOP knowledge extractor $E_{\pro{IOP}}^{P'_O}(x)$ in order to output a witness for $x$ along with the corresponding transcript. 

\paragraph{Constructing $P'_O$ (IOP adversary)}
$P'_O$ runs as follows on initial state $\st_0$ and input $x$. It internally simulates the interaction of $P^*$ and $V$, using the record oracle $\pro{Record}(P^*, \params, x, \st)$. It begins by running this for the first round on state $\st_0$. For every message that $P^*$ sends in this first round, $P'_O$ continues simulation until there is an $\eval$ on this commitment. (There is guaranteed to be at least one $\eval$ on each commitment, independent of the randomness). Therefore, denoting by $E_\eval$ the extractor for the $\eval$ subprotocol between $P^*$ and $\verifier$ on a given commitment and evaluation point, the record oracle can be used to simulate $E_\eval$'s record oracle.% for each $m$ evaluated at some point determined by $V$'s challenge.

For each message $m$ that $P^*$ sends to $V$ at the beginning of the first round, $P'_O$ interprets $m$ as a commitment, and attempts to extract from it a polynomial by 
running the PPT emulator $E_\eval$, simulating its record oracle as just described. \textbf{If it fails in any extraction attempt it aborts.} 

If $P'_O$ succeeds in all these extractions, then it uses these extracted polynomials as its first round proof oracles that it gives to $\verifier_O$. Upon receiving the first public-coin challenge from the IOP verifier, $P'$ uses the query function to derive the corresponding queries to each of these proof oracles. Before answering, it rewinds $P^*$ and $\verifier$ back to the point immediately after $P$ sent its first messages, and now substitutes random challenge from $\verifier_O$ in order to simulate $P^*$ and $V$ on these same queries. It checks that $P^*$'s answers are consistent with the answers it can compute on its own from the extracted polynomials. \textbf{If any answers are inconsistent, $P'_O$ aborts}. Otherwise, it sends the answers to $\verifier_O$. 

At the end of this first round (assuming $P'$ has not yet aborted), $P'_O$ has stored an updated state $\st'$ for $P^*$ based on this simulation. It proceeds to the next round and repeats the same process, using the record oracle $\pro{Record}(P^*, \params, x, \st')$. Finally, if $P'$ makes it through all rounds without aborting, then it has a final state $\st_V$ for $\verifier_O$ based on its internal simulation of $P^*$ and $V$ up through the end of the last round. Finally, $\verifier_O(\st_V)$ outputs $\pro{Accept}$ or $\pro{Reject}$. %(Observe that $\verifier_O$ accepts if and only if $\verifier$ would accept in the simulated transcript with $P^*$ because they run the same decision algorithm on the final state of query/response pairs). % $1$ on $\st_V$. (This is due to the fact that the verifier in the compiled IOP runs the same final decision algorithm as the IOP verifier). 

\paragraph{Analysis of $P'_O$ success probability} 
We claim that if $\pro{Record}(P^*, \params, x, \st_0)$ outputs an accepting transcript $\tr$ with non-negligible probability, then $P'_O$ succeeds with non-negligible probability. 

Observe that for any accepting $\tr$ between $P^*$ and $V$, if $P'_O$ happens to follow the same exact sequence of query/responses without ever aborting then it succeeds because $\verifier_O$ and $\verifier$ run the same decision algorithm on the final state of query/response pairs. Thus, it remains only to take a closer look at what events cause $P'_O$ to abort, and bound the fraction of accepting $\tr$ for which this occurs. 

As indicated in bold above, there are two kinds of events that cause $P'_O$ to abort: 
\begin{itemize}
\item It fails to extract from a ``commitment" message $m$ sent by $P^*$
\item After successfully extracting a polynomial $f$ from a commitment, $P^*$ answer queries to $f$ in a way that is inconsistent with $f$. 
\end{itemize}

The second type of event contradicts the evaluation binding property of $\Gamma$, therefore it occurs with negligible probability. 

To analyze the first type of event, let us define ``bad commitments" for a parameter $D$. We define this as a property of a message $m$ (purportedly a commitment) sent in a transcript state $\st$.

\paragraph{Bounding probability of commitment extraction failure} 
The pair $(m, \st)$ is a ``bad commitment" if there is less than a $1/D$ probability that extending the transcript between $P^*$ and $\verifier$, starting from state $\st$, will contain a successful execution of $\eval$ on $m$. This probability is over the randomness of the public-coins of $\verifier$ in the extended transcript. %have a succesful execution on (over the randomness of the public-coins) that $\pro{Record}(P^*, \params, x, \st)$ contains a successful execution of $\eval$ on $m$ on the queries defined by $\st$ and the next public coin challenge, where $\st$ is determined by running $\tr$ up until the point $m$ appears. 


Let $A(\tr)$ denote the event that a transcript $\tr$ sampled from $\pro{Record}(P^*, \params, x, \st_0)$ is accepting. Let $B(\tr)$ denote the event that $\tr$ contains a ``bad commitment" (i.e. some message $m$ sent in state $\st$ such that $\pro{Bad}(m, \st) = 1$). The conditional probability of event $A(\tr)$ conditioned on event $B(\tr)$ is less than $1/D$. To see this, fix $(m, \st)$ with $\pro{Bad}(m, \st) = 1$ and consider ``sampling" a random $\tr$ that contains $m$ at state $\st$. This is done by first choosing randomly from all partial transcripts that result in $(m, \st)$ via brute force, and then running the transcript normally from state $\st$ on random public-coins. No matter how $(m, \st)$ is chosen, the probability that this process produces an accepting transcript is by definition less than $1/D$. (The second part of the transcript following $(m, \st)$ contains at least one execution of $\eval$ on $m$ by hypothesis, and by the definition of $B(m, \st) = 1$ this execution is accepting with probability less than $1/D$).

Assume that $P(A(\tr)) \geq 1/\poly$. Applying Bayes' law, %letting $A(\tr)$ denote the event that $\tr$ is accepting and $P(A(\tr)) > 1/\poly$ the a-priori probability of this event, 
\[ P[B(\tr) | A(\tr)) \leq \frac{ P[A(\tr) | B(\tr)] }{ P(A(\tr)) } \leq \poly / D \enspace . \]
In other words, at least a $1 - \poly/D$ fraction of accepting transcripts do not contain ``bad commitments". %By a union bound, in a length $L$ transcript void of bad commitments, the transcript does not contain any failed $\eval$ with probability at least $L/B$. 
Furthermore, so long as a commitment $m$ is not ``bad", we can invoke the witness-emulation property of $\eval$ to say that the PPT $E_\Gamma$ emulator extracts a witness polynomial from each $m$ with overwhelming probability.


Setting $D = 2 \poly$ we get that on at least a $1/2$ fraction of accepting transcripts, $P'_O$s simulation also succeeds (i.e. successfully extracts from each prover commitment message) with probability at least $1/2$. This means that $P'_O$ has a non-negligible success probability conditioned on the event that $\tr$ is an accepting transcript. 

In conclusion, if $\tr$ is accepting with non-negligible probability, then there is a non-negligible probability that $P'_O$ succeeds. 
\end{proof}

\ifappendix

\section{Optimizations for Polynomial Commitment Scheme}
\label{subsec:optimization}
\input{sections/optimization}
\section{Multivariate Commitment Scheme}
\label{sec:multivariate}

\input{sections/multivariate}
\fi

%\ifappendix
%\section{Other Instantiations of Polynomial IOPs} \label{appendix:other_polynomial_iops}

%\input{sections/other_polynomial_iops}
%\fi


