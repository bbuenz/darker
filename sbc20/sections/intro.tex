
Since the landmark discoveries of \emph{interactive proofs} (IPs)~\cite{STOC:GolMicRac85} and %the ``PCP theorem" on 
\emph{probabilistically checkable proofs} (PCPs)~\cite{STOC:BFLS91,FOCS:ALMSS92} in the 90s, there has been tremendous development in the area of proof systems whereby a prover establishes the correct performance of an arbitrary computation in a way that can be verified much more efficiently than performing the computation itself. Such proof systems are \emph{succinct} if they also have a low communication cost between the prover and the verifier, \emph{i.e.}, the transcript of the protocol is much smaller than a witness to the computation. There are also \emph{zero knowledge} variants of these efficient proof systems, beginning with ZK-IPs~\cite{C:BGGHKMR88} and ZK-PCPs~\cite{STOC:Kilian92}, in which the computation may involve secret information and the prover demonstrates correct performance without leaking the secrets. As a toy example, one could prove that a chess position is winning for white without actually revealing the winning moves themselves. General purpose zero-knowledge proofs~\cite{JACM:GMW91} can be very expensive in terms of proof size and verification time even for computations that would be easy to perform given the secret inputs (\emph{e.g.}, by proving that one decrypted a file properly without leaking the key or the plaintext). The same techniques that are used to build efficient proof systems for expensive computations are also useful for making zero-knowledge proofs more practical. 
%A more practical example  
 
In recent years, there has been a surge of industry interest in verifiable outsourced computation~\cite{WalBlu15} (such as trustless cloud computing) as well as zero-knowledge proofs. In particular, blockchains use efficient zero-knowledge proofs as a solution for balancing privacy and publicly-verifiable integrity: examples include anonymous transactions in ZCash~\cite{SP:BCGGMT14,Zcash, ZcashProtocol} and verifying Ethereum smart contracts over private inputs~\cite{Zokrates}. In these applications, zero-knowledge proofs are posted to the blockchain ledger as a part of transactions and nodes must verify many proofs in the span of a short period of time. Therefore, succinctness and fast verification are necessary properties for the deployment of such proof systems. Verifiable computation is also being explored as a scaling solution for blockhain transactions~\cite{ZK-rollup}, and even as a way to entirely eliminate the need for maintaining historical blockchain data~\cite{Coda}. 
%In recent years, there has been a surge of industry interest in applying proof systems to outsourced verifiable computation~\cite{Sources}. These proof systems are particularly relevant to blockchains, which use efficient zero-knowledge proofs as a solution for balancing privacy and publicly-verifiable integrity: examples include anonymous transaction in ZCash~\cite{SP:BCGGMT14,Zcash}, and verifying Ethereum smart contracts over private inputs~\cite{ZKContracts}. Verifiable computation is also used as a way to synchronize more efficiently with the current state of a blockchain~\cite{Rollup}, or even entirely eliminate the need for maintaining historical blockchain data~\cite{Coda}. 

Following this pragmatic interest, there has also been a surge of research focused on obtaining proof systems with better concrete efficiency characteristics: \emph{succinctness} (the proof size is sublinear in the original computation length $T$), \emph{non-interactivity} (the proof is a single message), \emph{prover-scalability} (proof generation time scales linearly or quasi-linearly in $T$), and \emph{verifier-scalability} (verification time is sublinear in $T$). Proof systems that achieve all of these properties for general NP statements%\footnote{NP statements can be verified deterministically in polynomial time given a suitable \emph{witness}. More formally, a language $L \subseteq \{0,1\}^*$ is in $NP$ if there is a non-determinstic polynomial time decision algorithm $V_L$ for $L$: for every $x \in \{0,1\}^*$ there exists a witness $w$ such that $V_L(x, w) = 1$ iff $x \in L$. If $C$ is a circuit, the statement that $C(x) = y$ can be expressed as an NP statement $(C, x, y)$ with a witness $w$ that assigns correct values to all the internal wires of $C$ producing the output $y$ on input $x$.}
are called SNARGs (``succinct non-interactive arguments''). 
The proof is called an \emph{argument} when it is only sound assuming the prover is computationally bounded, \emph{i.e.}, \emph{computationally sound} as opposed to statistically sound. 
Succinct statistically sound proofs are unlikely to exist~\cite{CC:GolVadWig02,ICALP:Wee05}.

Currently, there are numerous constructions that achieve different tradeoffs between proof size, proof time, and verification time, but also under different \emph{trust} models as well as cryptographic assumptions. %There is a distinction between \emph{proofs} and \emph{arguments}, the latter offering soundness only against a computationally bounded prover. 
Some constructions also achieve better efficiency by relying on a \emph{preprocessing model} in which a one-time expensive setup procedure is performed in order to generate a compact verification key \pro{VK}, which is later used to verify proof instances efficiently.
%More precisely, a fresh \pro{VK} must be generated for each computation that will be proven, e.g. represented as an arithmetic circuit $C$ that takes inputs $x \in \ZZ^n$ over a prime field $\ZZ$. Thereafter, succinct proofs may be generated for the evaluation of $C$ on arbitrary inputs $x$ and verified efficiently with \pro{VK}. 
Somewhat unfortunately, the best performing proof systems to date (considering proof size and verification time) require a \emph{trusted} preprocessing. These are the pairing-based SNARKs extending from GGPR~\cite{EC:GGPR13,ES:SBVBPW13,TCC:BCIOP13,C:BCGTV13,EC:Groth16}, which have been implemented in numerous libraries~\cite{C:BCGTV13,bellman}, and even deployed in live systems such as the ZCash~\cite{Zcash} cryptocurrency.
%The preprocessing involves secret information that must be discarded, else it provides the prover with a trapdoor that breaks the integrity of the proof system. 
The trusted setup can be performed via \emph{multi-party computation} (MPC) by a committee of parties, such that trust in only one of the parties is sufficient. This has been done on two occasions for the ZCash blockchain, involving elaborate ``ceremonies" to engender public trust in the process~\cite{ZcashCeremony}. 

A proof system is called \emph{transparent} if it does not involve any trusted setup. Recent progress has yielded transparent proof systems for special types of computations: zk-\textsf{STARK}s~\cite{C:BBHR19} generate zero-knowledge proofs of size $O(\log^2 T)$ for a uniform computation\footnote{A uniform computation is expressed as a RAM program $P$ and a time bound $T$ on the running time of the program. A uniform computation depends on the size of $P$'s description but not on the time bound $T$.}, and the GKR protocol produces interactive proofs with communication $O(d \log T)$ for computations expressed as low-depth circuits of total size $T$ and depth $d$~\cite{STOC:GolKalRot08}. In both cases, non-interactivity can be achieved in the random oracle model with the Fiat-Shamir heuristic~\cite{C:FiaSha86,STOC:CCHLRRW19}.
These transparent proof systems perform significantly worse than SNARKs based on preprocessing. For computations expressed as an arithmetic circuit of $1$-million gates, \textsf{STARK}s~\cite{C:BBHR19} report a proof size of $600$KB, whereas preprocessing SNARKs achieve $200$ bytes~\cite{EC:Groth16}. Bulletproofs~\cite{SP:BBBPWM18, EPRINT:BCCGP16} is a transparent zero-knowledge proof system whose proofs are much smaller than those of \textsf{STARK}, but these proofs have a verification time that scales linearly in the size of the circuit; for an arithmetic circuit of one million gates the verification time is close to 1 minute, more than 1,000 times more expensive than verifying a \textsf{STARK} proof for the same computation. 
% The original GKR protocol was not zero-knowledge, but there are more recent zero-knowledge variants that have communication $O( \sqrt{n} + d \log T)$ where $n$ is the size of the (secret) input~\cite{SP:WTSTW18,EPRINT:ZGKPP17b}. 


Another thread of research has produced proof systems that remove trust from the circuit preprocessing step, and instead have a \emph{universal} (trusted) setup: a one-time trusted setup that can be reused for \emph{any} computation~\cite{Sonic,Libra,Spartan,Plonk}. All of these systems build SNARKs by combining an underlying reduction of circuit satisfiability to probabilistic testing of polynomials (with degree at most linear in the circuit size) together with \emph{polynomial commitment schemes}. In a polynomial commitment scheme, a prover commits to a $\mu$-variate polynomial $f$ over $\FF$ of degree at most $d$ with a message that is much smaller than sending all the coefficients of $f$. The prover can later produce a non-interactive argument that $f(z) = y$ for arbitrary $z \in \FF^\mu$ and $y \in \FF$. %It should be infeasible for the prover to claim $f(z) = y'$ and $f(z) = y$ for $y \neq y'$. Universal SNARK constructions also require this evaluation protocol to itself be a knowledge argument, \emph{i.e.}, a successful prover must know the coefficients of the committed polynomial. 
The trusted portion of the universal SNARK is entirely confined to the polynomial commitment scheme's setup. These constructions use variants of the Kate~\emph{et al.} commitment scheme for univariate polynomials~\cite{AC:KatZavGol10}, which requires a trusted setup.% trusted party to generate a length $d$ vector of group elements of the form $g^{s^i}$ for a secret point $s \in \FF$. 

%According to a concrete comparison~\cite{Libra} of proof systems' performance (prior to the present work) on a computation that derives the root of a SHA-256 Merkle tree with 256 leaves\footnote{This computation involves 511 calls to SHA-256.}, STARKs are the only transparent non-interactive proof system capable of producing a proof (in a practical\footnote{The STARK computation cited here takes about 30 minutes to generate.}  amount of time) that can be verified in under 9 seconds, and yet the proof size is nearly 400 KB. 

\subsection{Summary of contributions} 
Following the observations of the recent universal SNARK constructions~\cite{Plonk,Sonic,Libra}, SNARKs can be built from polynomial commitment schemes where all the trust is confined to the setup of the commitment scheme. The main technical contribution of our work is thus a new polynomial commitment scheme without trusted setup (\emph{i.e.}, a transparent polynomial commitment scheme), which we can use to construct transparent SNARKs. The observation that transparent polynomial commitments imply transparent SNARKs was also implicit in the recent works that build transparent SNARKs from multi-round classical PCPs, and specifically interactive oracle proofs of proximity (IOPPs)~\cite{ICALP:BBHR18}. As a secondary contribution, we present a framework that unifies all existing approaches to constructing SNARKs from polynomial commitments using the language of \emph{interactive oracle proofs} (IOPs)~\cite{STOC:ReiRotRot16,TCC:BenChiSpo16}. We view polynomial commitment schemes as a compiler for \emph{Polynomial IOPs}, and re-characterize the results of prior works as providing a variety of Polynomial IOPs for NP. 

\paragraph{New polynomial commitment scheme} We construct a new polynomial commitment scheme for $\mu$-multivariate polynomials of degree $d$ with optional zero-knowledge arguments of knowledge for correct evaluation that have $O(\mu \log d)$ size proofs and are verifiable in $O(\mu \log d)$ time. The commitment scheme requires a group of unknown order: two candidate instantiations are RSA groups and class groups of an imaginary quadratic order. Using RSA groups, we can apply the scheme to obtain universal preprocessing SNARKs with \emph{constant-size} %\footnote{The security parameters are technically size $O(\lambda)$ where $\lambda$ is a security parameter.}
setup parameters, as opposed to the linear-size parameters from previous attempts. Using class groups, we can remove the trusted setup from trusted-setup SNARKs altogether, thereby making them \emph{transparent}. Our polynomial commitment scheme leverages the power of integer commitments and \emph{Diophantine Arguments of Knowledge}~\cite{AC:Lipmaa03a}; accordingly, we classify this tool (and others of its kind) as a \emph{DARK} proof system.
%obtain the first transparent SNARKs with $O(\log d)$ proof size and $O(\log d)$ verification time.

\paragraph{Polynomial IOP formalism} %As a secondary contribution, we present a framework that unifies all existing approaches to constructing SNARKs from polynomial commitments. This framework is based on interactive oracle proofs
All SNARK constructions can be viewed as combining an underlying information-theoretic statistically-sound protocol with a ``cryptographic compiler'' that transforms the underlying protocol into a succinct argument at the cost of computational soundness. 
We define a \emph{Polynomial IOP} as a refinement of algebraic linear IOPs~\cite{CC:IKO07,TCC:BCIOP13,C:BBCGI19}, where in each round of interaction the prover provides the verifier with oracle access to a multivariate polynomial function of bounded degree. The verifier may then query this oracle to evaluate the polynomial on arbitrary points of its choice. The existing universal and transparent SNARK constructions provide a variety of statistically-sound Polynomial IOPs for circuit satisfiability (or RAM programs, in the case of \textsf{STARK}s); these are then cryptographically compiled using some form of a polynomial commitment, typically using Merkle trees or pairing groups.

The linear PCPs underlying GGPR and its successors (\emph{i.e.}, based on QAPs and R1CS) can also be transformed into Polynomial IOPs.\footnote{This observation was also implicit in the paper by Ben-Sasson \emph{et al.} introducing the system \pro{Aurora}~\cite{EC:BCRSVW19}.} This transformation helps highlight the fundamental paradigm shift between constructions of non-transparent non-universal SNARKs that combine linear PCPs and \emph{linear-only encodings} versus the more recent ones based on polynomial commitments: given the lack of efficient\footnote{Lai and Malavota~\cite{C:LaiMal19} provide a $n$-dimensional \emph{linear-map} commitment based on bilinear pairings, extending techniques in functional commitments~\cite{ICALP:LibRamYun16}, but verifying claimed evaluations of the committed function on query points takes $O(n)$.} \emph{linear function} commitment schemes, the compilation of linear PCPs \emph{necessarily} involves a trusted preprocessing step that preselects the verifier's linear PCP queries, and hides them inside a linear-only encoding. This linear-only encoding forces the prover to homomorphically output an (encoded) linear tranformation of the query, upon which the verifer performs several homomorphic checks (\emph{e.g.}, using pairings).
The shift towards Polynomial IOPs, which can be compiled more directly with efficient polynomial commitments, avoids the involvement of a trusted party to place hidden queries in the preprocessing. The only potential need for non-transparent setup is in the instantiation of polynomial commitment itself.

The precise definition of Polynomial IOPs as a central and standalone notion raises the question about its exact relation to other IOP notions. We present a univariate Polynomial IOP for extracting an indicated coefficient of a polynomial. 
%This construction establishes that adding point queries to univariate Polynomial IOPs does not make them more powerful. 
Furthermore, we present a univariate Polynomial IOP for proving that the inner product between the coefficient vectors of two polynomials equals a given value. This proof system is of independent interest. Together with an offline pre-processing phase during which the correctness of a multivariate polynomial is ascertained, these two tools enable us to show that \emph{any} algebraic linear IOP can be realized with a multivariate Polynomial IOP. 



\paragraph{Polynomial IOP compiler} 
We present a generic compilation of any public-coin Polynomial IOP into a doubly-efficient public-coin interactive argument of knowledge using an abstract polynomial commitment scheme. We prove that if the commitment scheme's evaluation protocol has witness-extended emulation, then the compiled interactive argument has this knowledge property as well. If the commitment scheme is hiding and the evaluation is honest-verifier zero knowledge (HVZK), then the compiled interactive argument is HVZK as well. Finally, public-coin interactive arguments may be cryptographically compiled into SNARKs using the Fiat-Shamir heuristic.\footnote{Security for Fiat-Shamir has been proven secure in the random oracle model for constant-round protocols, for multi-round protocols satisfying \emph{soundness against restoration attacks}, and in some cases using correlation-intractable hash functions~\cite{C:FiaSha86,TCC:BenChiSpo16,C:KalRotRot17,EC:CCRR18,STOC:CCHLRRW19}.}
%\cite{C:FiaSha86,CCS:BelRog93,EC:PoiSte96,CSproofs,TCC:HalMyeRac08,TCC:BenChiSpo16,EC:AABN02,C:KalRotRot17,EC:CCRR18,FOCS:HolLom18,STOC:CCHLRRW19}.}

\paragraph{New SNARK without Trusted Setup}
The main practical outcome of this work is a new transparent proof system (\pro{Supersonic}) for computations represented as arbitrary arithmetic circuits, obtained by cryptographically compiling the Polynomial IOPs underlying \textsf{Sonic}~\cite{Sonic} and \textsf{PLONK}~\cite{Plonk} using the DARK polynomial commitment scheme. \pro{Supersonic} improves the proof size by an order of magnitude over \textsf{STARK}s without compromising on verification time. For one million gates, \pro{Supersonic}'s proofs are just 7.8KB and take around 75ms to verify. Using the notation $O_\lambda(\cdot)$ to hide multiplicative factors dependent on the security parameter $\lambda$, \textsf{STARK}s have size and verification complexity $O_\lambda(\log^2 T)$ whereas \pro{Supersonic} has size and verification complexity $O_\lambda(\log T)$. (The additional multiplicative factors dependent on $\lambda$ are actually better for \pro{Supersonic} as well). 
As a caveat, while the prover time in \pro{Supersonic} is asymptotically on par with \textsf{STARK}s (\emph{i.e.}, quasilinear in $T$), the concrete efficiency is much worse due to the use of heavy-weight ``crypto operations'' over 1200 bit class group elements in contrast to the light-weight FFTs and hash functions in \textsf{STARK}s. Furthermore, \pro{Supersonic} is not quantum-secure due to its reliance on groups of unknown order, whereas \textsf{STARK}s are a candidate quantum-secure SNARK. 

