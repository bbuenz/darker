\documentclass[12pt]{article}
\pagestyle{plain} 
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics,advantage]{cryptocode}
\usepackage{notations}
%\usepackage{bm}
\usepackage{comment}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath,amssymb}
\usepackage[utf8x]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{xspace}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{cleveref}
%\usepackage{authblk}
%\usepackage{draftwatermark}
\usepackage[legalpaper, margin=1in]{geometry}
\usepackage{comment}
\usepackage{todonotes}
\theoremstyle{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{fact}{Fact}

\newif\ifcomments
\commentstrue
\ifcomments
	\newcommand{\ben}[1]{{\textcolor{red}{[\bf Ben: #1]}}}
		\newcommand{\benedikt}[1]{{\textcolor{blue}{[\bf Benedikt: #1]}}}

    \else
	\newcommand{\ben}[1]{}
	
\fi


\title{Darker}

\begin{document}
	
\maketitle
\section{Introduction}
\section{Technical Overview}
Contributions:
\begin{itemize}
	\item We reduce the evaluation time of Darker from O(d log(d)) to O(sqrt(d)*log(d))
	\item The commitment time is O(s) where s is the sparsity 
	\item Using multiexp techniques this can be computed using O(s*l/log(s*l)) group operations. 
	\item The size of the precomputed CRS is roughly O(sqrt(d))
	\item The scheme is secure under the random order assumption, basically the best assumption for groups of unknown order
	\item The interactive protocol becomes a proof not an argument
	\item We provide an implementation.
	\item (Optional) we show how to commit to polynomials in a point value representation
	\item We discuss applications to vector commitments. 
\end{itemize}

\section{Preliminaries}
\begin{enumerate}
	\item $\ZZ(b)=\{ z \in \ZZ | |z|<b\}$
	\item $\QQ(b)=\{\frac{n}{d} \in \QQ | |\frac{n}{\gcd(n,d)}|< b\}$
	\item $\ZZ^+=\{z \in \ZZ | z>0\}$ are the positive integers.
	\end{enumerate}
\section{Sketched Protocol}
Using additive notation. 
\benedikt{Let's describe the protocol with respect to $\QQ$? }
\ben{On the contrary I think we should avoid all mention of $\QQ$. It just makes things more complicated = harder to follow} 

\subsection{Odd Even Protocol}
\ben{Either include $q$ as a public input or set $q$ based on $b$. I also prefer using capital $B$ for a bound rather than lower case $b$. } 

\label{sec:oddeven}
\begin{mdframed}
Public Input: $C\in \GG, d \in \NN, b\in \NN$\\
Witness: $f(X) \in \ZZ(b)[X]$ \\
Claim: $\Commitment =\commit(f(X))$ and $\deg(f(X))<d$	\\
$\textsf{FFTEval}(q,C,d;f(X))$
\begin{enumerate}[nolistsep]
		\item $\pcif d=0$
		\item $\pcind[1]$ $\prover$ sends $f=f(X) \in \ZZ$
		\item $\pcind[1]$ $\verifier$ checks that $|f|<2^{\log_2(d_{\max}) \cdot \lambda} \cdot b$ and that $f \cdot \Generator=\Commitment$\pccomment{$d_{\max}$ is the original degree here}
		\item $\pcelse$
		\item $\prover$ computes $f_E(X)$ and $f_O(X)$ s.t. $f_E(X^2)+X \cdot f_O(X^2)=f(X)$\pccomment{Odd and Even coefficients} 
		\item \prover sends $\Commitment_E\gets \commit(f_E(q^2))$ and $\Commitment_O\gets \commit(f_O(q^2))$ to $\verifier$. 
		\item $\verifier$ checks that $\Commitment_E+ q\cdot \Commitment_O=\Commitment$ \pccomment{$q$ grows in each round. Outsourced with PoEs. See below}
		\item $\verifier$ samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to $\prover$
		\item \prover and \verifier compute $\Commitment'\gets \Commitment_E+\alpha \cdot \Commitment_O$
		\item $\prover$ computes $f'(X)\gets f_E(X)+\alpha f_O(X)$
		\item \prover and \verifier run $\textsf{FFTEval}(q^2,\Commitment',\frac{d}{2};f'(X))$
	\end{enumerate}
\end{mdframed}

\subsection{Computing all PoEs at once}
%Let the subscript $i$ denote proof elements from the $i$th round of the protocol. Let $\numrounds=\logd$ be the number of rounds in the protocol.
We present a \textsf{BatchPoE} protocol for proving that $\numrounds$ pairs of group elements $\{(\gr{C}_i, \gr{C}'_i)\}_{i=1}^k$ satisfy $q^{2^{i-1}} \cdot \gr{C}_i = \gr{C}'_i$ for all $i \in [\numrounds]$.
While this could be proved with $k$ independent PoE proofs, the protocol we present saves a factor $k$ in the communication cost over the naive solution.
%Let $\gr{D}_{i}\gets \gr{C}_{O,i}$ and $\gr{D}_{i}'\gets \gr{C}_{i}-\gr{C}_{i}$ for $i \in [1,\numrounds]$ such that $q^{2^{i-1}} \cdot \gr{D}_i=\gr{D}'_i$ for all $i\in [\numrounds]$. The prover and verifier run the following \textsf{BatchPoE} protocol that the claims hold.
\begin{mdframed}
\underline{\textsf{BatchPoE} \textbf{protocol}} \\
Prover and Verifier Input: $\{(\gr{C}_i,\gr{C}_i')\}_{i=1}^{\numrounds},q$\\
Claim: $q^{2^{i-1}}\cdot \gr{C}_i=\gr{C}'_i \quad \forall i \in \{1,...,\numrounds\}$
	\begin{enumerate}[nolistsep]
\item $\gr{X}_{\numrounds} \deq \gr{C}_{\numrounds}$, $\gr{Z}_{\numrounds} \deq \gr{C}'_{\numrounds}$
	\item $\pcwhile  i  > 1$
   \item \pcind[1]\prover computes $\gr{Y}_{i}\deq q^{2^{i-2}}\cdot \gr{X}_{i}$
\item\pcind[1]\prover sends $\gr{Y}_{i}$ to $\verifier$
	\item \pcind[1]$\verifier$ samples $\alpha \sample [-2^{\lambda-1} ,2^{\lambda-1}]$ and sends them to $\prover$
	\item \pcind[1]\prover and \verifier compute  $\gr{X}_{i-1} \deq  \gr{X}_{i}+ \alpha\cdot  \gr{Y}_{i}+\alpha^2 \cdot\gr{C}_{i-1}$
	\item $\pcind[1]$\verifier compute   $\gr{Z}_{i-1}\deq \gr{Y}_{i}+\alpha\cdot \gr{Z}_{i}+\alpha^2 \cdot \gr{C}_{i-1}^{'}$ 
	     \pccomment{Invariant: $q^{2^{i-2}} \cdot \gr{X}_{i-1} = \gr{Z}_{i-1}$ }
	\item $\pcind[1] i \deq i - 1$
\item \verifier outputs \textsf{accept} if and only if $q\cdot \gr{X}_1=\gr{Z}_1$
\end{enumerate}
\end{mdframed}
\paragraph{Challenge distribution}
Instead of using $\alpha$ and $\alpha^2$ as challenges it is also possible to use independently sampled $\alpha$ and $\beta$. The security argument is slightly more complicated as one needs to argue that the challenge matrix remains diagonalizable. The main benefit is that it decreases the verifier complexity slightly as $\alpha^2 \in \ZZ$ is about twice the size of $\alpha$ and $\beta$. 

\subsection{Computational complexity of batch PoE}
\ben{We analyze the complexity of Batch PoE both in general, and in the special case that...} The main prover work is in computing $\gr{Y}_i$. In the first few loops $\gr{Y}_i=g^{h(q)}$ for a sparse polynomial $h(X)$. For example in the first loop $h(X)$ has only a single non-zero coefficient.
After $\logd/2$ rounds the polynomial has roughly $\sqrt{d}$ coefficients. It then makes sense to switch to computing $\gr{Y}_i$ using a sequential computation, i.e. $\gr{Y}_i=\gr{X}_i^{q^{2^{i-2}}}$. This now also takes $O(\sqrt{d}\cdot \log{d})$ work. One could also switch earlier from one computation to the other. Additionally it is possible to use Wesolowski PoEs for the second part of the loop, i.e. the first half of the Odd/Even protocol. This leads to a smaller proof size. One possible split may be to only do $\log{\log{d}}$ BatchPoEs at the end. This should give you prover time that is still linear but better proof size. In practice doing BatchPoE for the last $6$ rounds should be good for almost all input sizes.
\section{$\tilde{O}(\sqrt{d})$ eval}
The PoEs are efficient and with some caching during the commitment phase we can also make the rest of the eval have $\tilde{O}(\sqrt{d})$ complexity (only group operations). The protocol is parameterized by a bound $b$ which determines the amount of preprocessing. We discuss the perfect choice for $b$ later but for intuition it helps to think of $b=d/b=\sqrt{d}$.
\subsection{Idea}
The core idea is that we can write a polynomial $f(X)$ of degree $d-1$ as the sum of $b$ polynomials $f_i(X)$ of degree less than $\frac{d}{b}$. That is $f(X)=\sum_{i=0}^b X^i f_i(X^b)$. This is a direct generalization of the odd/even split that the $\textsf{FFTEval}$ protocol uses. During the committing phase the prover computes and stores commitments to $f_i(X^b)$, i.e. $P_i\gets g^{f_i(q^b)}$. Using the $\frac{d}{b}$ precomputed group elements $g,g^{q^b},g^{q^{2b}}\dots$ all $b$ $P_i$'s can be computed using $d$ $\lambda$-bit exponentiations\footnote{Ignoring multi-exponentiation speedups for now}. Given the $P_i$'s one can compute $C=g^{f(q)}$. This is because $C=\prod_{i=0}^{b-1} P_i^{q^i}$. By computing this product left to right, i.e. $C=(((P_{b-1}^qP_{b-2})^qP_{b-3})^q \dots)P_0$ this can be done using only $b$ $\log_2(q)$-bit exponentiations.

Similarly the prover can use the $P_i$ to compute to $C_O$, i.e. the commitment to $f_O(X^2)$ where $f(X)=f_E(X^2)+Xf_O(X^2)$. Additionally computing $C_O'=g^{q f(q^2)}$ can be done efficiently given just $C_O$ as $C_O'=C_O^q$. 

After each round the protocol continues with $f'(X)=f_E(X)+\alpha f_O(X)$ as a witness and $q_{i+1}=q_{i}^2$. Similarly as in the first round we can write $f'(X)$ as the sum of $b/2$ polynomials of degree less than $\frac{d}{b}$.
$f'(X)=\sum_{i=0}^{\frac{b}{2}-1} X^i f'_i(X^{\frac{b}{2}})$. Given the commitments to the $f_i(X^b)$ we can efficiently compute commitments to $f_i'(X)=f_{2i}(X)+\alpha f_{2i+1}(X)$ as $P_i'\gets P_{2i}P_{2i+1}^{\alpha}$. This takes work at most $b$, $\lambda$-bit exponentiations. Repeating this for $\log_2(b)$ rounds we end up with a witness polynomial $f''(X)$ of degree less than $\frac{d}{b}$. Given the precomputed $g_i$ the prover can construct commitments to $f''(X)$ and finish the protocol using $\frac{d}{b}$ $\lambda$-bit exponentiations. In the first $\log_2(b)$ steps the most expensive operations is computing $C_O$ given the $P_i$'s. This takes roughly $b$ $\log_2(q)$-bit exponentiations in every round, i.e. $b\log_2(b) \log_2(q)$-bit exponentiations in total.
\subsection{Protocol}
\begin{mdframed}
$\textsf{Preprocess(b)}$:
\begin{enumerate}[nolistsep]
	\item $\Generator_i={q^{ib}} \cdot \Generator$ for $i \in [0,\frac{d}{b}-1]$
	\item Output $\Generator_0,\dots,\Generator_{\frac{d}{b}-1}$
\end{enumerate}
$\textsf{Commit}(f(X),b):$
\begin{enumerate}[nolistsep]
	\item $f(X)=\sum_{i=0}^{b-1} X^{i} f_i(X^{b})$ \pccomment{$\deg(f_i(X))<\frac{d}{b}$.}
	\item Let $\gr{P}_i\gets f_i(q^b) \cdot \Generator$ for all $i \in [0,b-1]$\pccomment{ computed using $\Generator_i$; Cost: $d$ $\lambda$-bit exp.}
	\item Compute $\gr{C}\gets \sum_{i=0}^{b-1} q^i \cdot \gr{P}_i=(( \gr{P}_{b-1}\cdot q+\gr{P}_{b-2})\cdot q + \gr{P}_{b-3}) \cdot q+...\gr{P}_0$ \pccomment{Cost: $b$ $\log_2(q)$-bit exp.}
	\item Output $\gr{C}$ and $\gr{P}_{0}\dots,\gr{P}_{b-1}$
\end{enumerate}
$\textsf{FFTEval}(q,\gr{C},\gr{P}_0,\dots,\gr{P}_{b-1},b,d;f_0(X),\dots,f_{b}(X))$
\begin{enumerate}[nolistsep]
		\item $\alpha_0=\hash(\gr{C},f_0,q,b)$ 
		\item $\pcfor i=1$ to $\log_2(b)$
		\item $\pcind[1]$ $\gr{C}_{O,i}\gets\sum_{j=0}^{\frac{b}{2^i}-1} q^{j\cdot 2^i}\cdot \gr{P}_{2j+1}^{}$ \pccomment{Computed using folding method, Total Cost: $b \log{b}$ $\log_2(q)$-bit exp}.
		\item \pcind[1] $\gr{C}_{O,i}'= q^{2^i} \cdot \gr{C}_{O,i}^{}$ \pccomment{Total cost (all iterations) $b$ $q$-bit exp, might as well do W PoE here}
		\item \pcind[1] $\alpha_i\gets \hash(\alpha_{i-1} \gr{C}_{O,i})$ \pccomment{Fiat-Shamir}
		\item $\pcind[1] \gr{P}_{j}=\gr{P}_{2j}+ \alpha \cdot \gr{P}_{2j+1}^{}$ for $j \in [0,\frac{b}{2^i}]$\pccomment{$b$ $\lambda$-bit exp in total}
		\item $f'(X)\gets \sum_{i=0}^{b-1} f_i(X) \prod_{j=1}^{\log_2(b)} \alpha_j^{j\text{th last bit of }i}$ \pccomment{$f_0(X)+\alpha_1 f_1(X) + \alpha_2 f_2(X)$, Cost: $d$ field ops}
		\item \pcfor $i=\log_2(b)+1$ to $\logd$
		\item \pcind[1] $f'(X)=f_E(X^2)+Xf_O(X^2)$
		\item \pcind[1] $\gr{C}_{O,i}\gets f_O(q^{2^i}) \cdot \Generator$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp}
		\item  \pcind[1] $\gr{C}_{O,i}'\gets q^{2^{i-1}} \cdot f_O(q^{2^i}) \cdot \Generator$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp using the preprocessed $\Generator_i$s}
		\item \pcind[1] $\alpha_i\gets\hash(\gr{C}_{O,i},\gr{C}_{O,i}')$
		\item \pcind[1] $f'(X)=f_E(X)+\alpha_i f_O(X)$
		\item Proof is $\gr{C}_{O,1},\dots,\gr{C}_{O,\logd}$ and $\gr{C}_O$'s
		\item Add $f'=f'(X)$ to proof.
	\end{enumerate}
	\end{mdframed}
	For $b=\sqrt{d}$ the runtime is $O(d \logd^2)$. A value like $b=\sqrt{d/\log(d)}$ gives roughly $O(d\logd^{1.5})$. Parallelism and multi-exp techniques need to be taken into account and the optimal value is likely best determined numerically. There are limited options anyway as $b$ needs to be a power of $2$.\\ 
Step 2 in FFTEval is likely a bottleneck. Smaller q value would still help in this protocol.
\section{Security Proof}

.

\subsection{Proof}
We state a version of the RSA assumption as described by $\cite{EC:CouPetPoi17}$.
\begin{assumption}[RSA assumption,\cite{RivShaAdl78,EC:CouPetPoi17} ]
	The RSA assumption states that an efficient adversary cannot compute a random root (co-prime with the order of the group) for a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\[
    \Pr\left[\ell \cdot \gr{U} = \Generator \wedge \gcd(\ell,|\GG|)=1:
    \begin{array}{l}
         \GG,B \leftarrow \ggen(\lambda)  \\
         \Generator \sample \GG, \ell \sample [B]  \\
         \gr{U} \in \mathbb{G} \leftarrow \adv(\mathbb{G}, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
\]

\end{assumption}

\begin{assumption}[Random order assumption]
	The random order assumption states that an efficient adversary cannot compute a multiple of the order of a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\[
    \Pr\left[a\cdot \Generator =0:
    \begin{array}{l}
         \GG,B \leftarrow \ggen(\lambda)  \\
         \Generator, \sample \GG\\
         a \in \NN \leftarrow \adv(\mathbb{G},B, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
    \]
\end{assumption}
\begin{lemma}
\label{lem:roa-to-rsa}
	The RSA assumption for $\ggen$ implies the random order assumption
	\end{lemma}
\begin{proof}
	Given an efficient adversary $\adv_{\textsf{Order}}$ for the random order assumption we will construct an efficient adversary $\adv_{\textsf{RSA}}$ for the RSA assumption. On input $\GG,\Generator,\ell$ to $\adv_{\textsf{RSA}}$ we will forward $\GG,\Generator$ to $\adv_{\textsf{Order}}$. $\adv_{\textsf{Order}}$ outputs $a$ such that $a\cdot \Generator=0$ with non-negligible probability $\epsilon$. 
	$\adv_{\textsf{RSA}}$ computes computes $a'\gets \frac{a}{\gcd(a,\ell^k)}$ for $k=\lceil\log_\ell(a)\rceil$. Note that since $\ell$ is co-prime to the order of $\GG$ and thus also the order of $\Generator$ and $a$ is a multiple of the order of $\Generator$ we have that $a'$ is still a multiple of the order of $\Generator$. Now $\adv_{\textsf{RSA}}$ computes $w\gets \ell^{-1} \bmod a'$ and outputs $\gr{U} \gets w\cdot \Generator$. $\ell \cdot \gr{U}=\Generator$ so $\adv_{\textsf{RSA}}$ succeeds with probability $\epsilon$.
\end{proof}
\begin{fact}[Known order elements]
	\label{fact:knownorder}
	Given a two elements in a group and multiples of the order of these elements there exists an efficient algorithm computing the order of any linear combination of the elements.
\end{fact}
Let $\gr{W}_1,\gr{W}_2 \in \GG$ be such that $\alpha_1 \cdot \gr{W}_1=0$ and $\alpha_2 \cdot \gr{W}_2=0$ then for $\gr{W}'=a\gr{W}_1 + b \gr{W}_2$ we have that for $\alpha'=\lcm(\alpha_1,\alpha_2)$, $\alpha' \cdot \gr{W}'=0$
\begin{fact}
\label{fact:encoding}
Let $q \in \ZZ$ be any positive integer. For any integer $E \in \ZZ$ such that $|E|<\frac{q^{d+1}}{2}$ there exists a unique integer polynomial $f \in \ZZ[X]$ with $||f||_\infty < q/2$ such that $f(q) = E$. 
\end{fact} 

\begin{lemma}
\label{lem:encoding}
Let $q \in \Z$ be any positive integer. For any integers $z_1, z_2 \in \ZZ$ and integer polynomials $f_1, f_2 \in \ZZ[X]$ of degree at most $d$ with bounded coefficients such that $||f_1||_\infty < q/2$ and $||f_2||_\infty < q/2$, if $gcd(f_i(q), z_i) = 1$ and $z_2 \cdot f_1(q) = z_1 \cdot f_2(q)$ then 
$f_1 = f_2$ and $z_1 = z_2$. 
\end{lemma}
\begin{proof}
The rational numbers $\frac{f_1(q)}{z_1} = \frac{f_2(q)}{z_2} \in \QQ$ are in reduced rational form, hence $f_1(q) = f_2(q)$ and $z_1 = z_2$. The integers $f_1(q)$ and $f_2(q)$ have absolute value bounded by $\frac{q^{d+1}}{2}$, and thus $f_1 = f_2$ by Fact~\ref{fact:encoding}.
\end{proof}


%\begin{fact}
%\label{fact:encoding}
%Let q be an integer. For any rational $z$ with numerator $n \in \ZZ$ such that $|z|<\frac{q^{d+1}}{2}$ there exists a unique degree (at most) d rational polynomial $\hat{h}(X)$ in $\QQ(q)[X]$ such that $\hat{h}(q) = z$. If $q>n$ then there exists a unique polynomial $h(X) \in \ZZ/p\ZZ$ such that $\hat{h}\equiv h \bmod p$ 
%\end{fact}

\begin{definition}[GUO Polynomial Commitment]
We describe a non-hiding succinct polynomial commitment scheme for polynomials of bounded degree over $\ZZ_p$ using a group of unknown order.
\begin{itemize}
	\item $\setup(\secparam) \rightarrow \crs:$
The setup algorithm $\setup$ on input $\secparam$ and max degree $d$ and prime $p$ samples a group of unknown order $\GG$ and a $\Generator \sample \GG$ and sets $q=2^k$ for $k \in \NN$ such that $q>p\cdot 2^{\lambda \cdot \logd}$. The algorithm outputs $\crs=(\GG,\Generator,q,p,d)$.

\item $\commit(\crs, f) \rightarrow \Commitment$: The commitment algorithm $\commit$ on input $f(X)\in \ZZ_p$ lifts $f(X)$ to the integer polynomial $\hat{f}(X)$ with coefficients bounded by $p$ and outputs $\Commitment =\hat{f}(q) \cdot \Generator$
%\item The open algorithm $\open$ outputs $f(X),\gr{W} \in \GG,\alpha \in \NN$
\item $\verify(\crs, \Commitment, f, (\hat{f}, \denom,  \gr{W}, a)) \rightarrow b$: 
The verification algorithm checks an opening of $\Commitment$ to the polynomial $f \in \ZZ_p[X]$, given the opening hint consisting of $\hat{f}\in \ZZ[X]$, $\denom \in \ZZ$, $\gr{W} \in \GG$, and $\alpha \in \ZZ$. It checks that $\alpha > 0$, $||\hat{f}||_\infty < \frac{q}{2}$, $\hat{f}(X) \equiv f(X)\cdot \denom \bmod p$, $\alpha\cdot \gr{W}=0$, $gcd(\hat{f}(q), \denom) = 1$, and $\denom \cdot \Commitment =\hat{f}(q)\cdot \Generator +\gr{W}$. If these checks pass it outputs $1$, and otherwise it outputs $0$. 
\item The evaluation protocol will be described later.
\end{itemize}
Note that an honestly generated commitment does not require an additional opening hint as $\Commitment = f(q) \cdot \Generator$. The flexibility in the $\verify$ algorithm is mainly for the security analysis of our evaluation protocol, so that the knowledge extractor is allowed to obtain a more general opening hint for the commitment. 
\end{definition}

\begin{lemma}[Binding commitment]
\label{lem:aug-com-binding}
	The commitment is binding under the random order assumption. 
\end{lemma}
\begin{proof}
	Suppose a polynomial time adversary is able to compute a commitment $\gr{C}$ and two valid opening hints $(\hat{f}_1, \denom_1, \gr{W}_1, \alpha_1)$ and $(\hat{f}_2, \denom_2, \gr{W}_2, \alpha_2)$ that open $\gr{C}$ to distinct values in $\ZZ_p[X]$, i.e. such that $\hat{f}_1 \cdot \denom_1^{-1} \neq \hat{f}_2 \cdot d_2^{-1} \bmod p$. 
	This implies $\hat{f}_1 \cdot \denom_2 \neq \hat{f}_2 \cdot \denom_1$. Moreover, since $||\hat{f}_1||_\infty < q/2$, $||\hat{f}_2||_\infty < q/2$, $\gcd(\hat{f}_1(q), \denom_1) = 1$, and $\gcd(\hat{f}_1(q), \denom_1) = 1$, by the contrapositive of Lemma~\ref{lem:encoding} this implies $\hat{f}_1(q) \cdot \denom_2 \neq \hat{f}_2(q) \cdot \denom_1$. Validity of the hints further implies $\alpha_1 \cdot \gr{W}_1 = 0$, $\alpha_2 \cdot \gr{W}_2 = 0$, and: 
	
	$$\denom_2 \cdot \denom_1 \cdot C = \denom_2 (\hat{f}_1(q) \cdot \gr{G} + \gr{W}_1) = \denom_1(\hat{f}_2(q) \cdot \gr{G} + \gr{W}_2)$$ 
	
	The adversary may therefore compute $\Delta = \alpha_1 \alpha_2 (\denom_2 \cdot \hat{f}_1(q)  - \denom_1 \cdot \hat{f}_2(q)) \neq 0$, which satisfies $\Delta \cdot \gr{G} = 0$. $\Delta$ is a multiple of the order of the element $\gr{G}$, which contradicts the Random Order Assumption. 
	 
	\end{proof}
	
		
	\begin{lemma}[PoEs]
		Protocol \textsf{BatchPoE} is an interactive proof of knowledge for the following relation:
		\[ \mathcal{R_\textsf{BPoE}} = \left\{
\big\langle \{(\gr{C}_i,\gr{C}_i')\}_{i=1}^{\numrounds}, q ; \ \{(\gr{W}_i\in \GG, a_i \in \ZZ)\}_{i=1}^k  \big\rangle
: \forall i
\begin{array}{l} 
 \Commitment_i' = q^{2^{\numrounds-i}}  \cdot \Commitment_i + \gr{W}_i \\ 
a_i\cdot \gr{W}_i=0
\end{array}\right\}
\]


		%$$\mathcal{R}_{POE}=\{\langle \{(\gr{G}_i,\gr{G}_i')\}_{i=1}^{\numrounds},q ;\{(\gr{W}_i\in \GG,a_i\in \ZZ)\}_{i=1}^k \rangle: \forall i \ \gr{G}_i' = q^{2^{\numrounds-i}}  \cdot \gr{G}_i + \gr{W}_i \ \ \wedge \ \ a_i\cdot \gr{W}_i=0]_{i=1}^{\numrounds-1} \}$$
	\end{lemma}
	\begin{proof}
		We define a knowledge extractor that runs with an adversary $\adv$ who succeeds for public inputs $\{(\Commitment_i,\Commitment_i')\}_{i=1}^{\numrounds}$ and $q$ with probability $\epsilon = 1/\poly$. The extractor begins by using the tree-finding algorithm of Lemma~\ref{lem:forking} to generate a tree of accepting transcripts with the following characteristics: 
\benedikt{Update proof to use challenges alpha and beta}
\begin{itemize}
\item The tree has depth $\numrounds$ and branching factor $3$. We index nodes by $v \in [0,3^\numrounds)$.

\item The root is labeled with the publics inputs. 
\item Each node $v$ distinct from the root is labeled with a challenge $\alpha_{v}$ and a prover message $\gr{Y}_v$. \ben{Check how to label leaves} 
\item Each non-leaf node $v$ has three children each labeled with three distinct verifier challenges 
$\alpha_{v,1} \neq \alpha_{v,2} \neq \alpha_{v,3}$.

\end{itemize} 

Since the verifier challenges in the protocol are sampled from $\mathcal{X} = [-2^{\lambda -1}, 2^{\lambda -1}]$, the probability of a collision over challenges $\alpha_1, \alpha_2 \sample \mathcal{X}$ sampled uniformly and independently is $2^{-\lambda}$. Thus, by Lemma~\ref{lem:forking} the tree-finding algorithm runs for $O(\poly/\epsilon)$ steps and succeeds with probability $1 - \negl/\epsilon$ to return a tree with these characteristics.

For the root node $\textsf{rt}$, define $\gr{X}_\textsf{rt} \deq \Commitment_\numrounds$ and $\gr{Z}_\textsf{rt} \deq \Commitment'_\numrounds$. For any node $v$ on level $i$ with parent $w$ on level $i+1$, which has prover message $\gr{Y}_v$ and verifier challenge $\alpha_v$, define $\gr{X}_v \deq \gr{X}_w + \alpha_v \cdot \gr{Y}_w + \alpha^2 \cdot \Commitment_{i-1}$. Similarly, define $\gr{Z}_v \deq \gr{Y}_w + \alpha \cdot \gr{Z}_w + \alpha^2\cdot  \Commitment'_{i-1}$.

We will show that given this tree, the extractor can compute for all nodes $v \in [0, 3^\numrounds]$ group elements $\gr{W}_v$ and integers $a_v$ such that $a_v \cdot \gr{W}_v = 0$ and if $v$ is on the $i$th level then $\gr{Z}_v = q^{2^{i-1}} \cdot \gr{X}_v + \gr{W}_v$. It can also compute values $\gr{W}'_v$ and $a'_v$ such that $a'_v \cdot \gr{W}'_v = 0$ and $\Commitment'_{i-1} = \Commitment_{i-1} + \gr{W}'_v$. It will do this by starting at the leaves and working its way up the tree.
For any leaf node $v$, the fact that the transcript is accepting implies $q \cdot \gr{X}_v = \gr{Z}_v$. Now suppose that the appropriate values $\gr{W}_v$ have been computed for all children of a node $w$ on the $i$th level. Denoting the three children of nodes $w$ with indices $v_1, v_2, v_3$ and the three challenges on each by $\alpha_1, \alpha_2, \alpha_3$. This means that $\gr{X}_{v_j} = \gr{X}_w + \alpha_j \cdot \gr{Y}_w + \alpha_j^2 \cdot \Commitment_{i-1}$ and $\gr{Z}_{v_j} = \gr{Y}_w + \alpha_j \cdot \gr{Z}_w + \alpha^2_j \cdot \Commitment'_{i-1}$ for each $j \in [3]$.
Furthermore, $\gr{Z}_{v_j} = q^{2^{i-1}} \cdot \gr{X}_{v_j} + \gr{W}_{v_j}$ such that $a_{v_j} \cdot \gr{W}_{v_j} = 0$ for each $j \in [3]$. 

Let $\mathbf{W} = (\gr{W}_{v_1}, \gr{W}_{v_2}, \gr{W}_{v_3})$ and let $a \deq lcm(a_{v_1}, a_{v_2}, a_{v_3})$. We can summarize these relations in the following matrix equations, where $\mathbf{A} \in \mathbb{Z}^{3\times 3}$ is the integer matrix with rows $(1, \alpha_j, \alpha_j^2)$:

$$\mathbf{A}
\begin{bmatrix}
\gr{X}_w \\ 
\gr{Y}_w \\ 
\Commitment_{i-1}
\end{bmatrix} 
=  
\begin{bmatrix}
\gr{X}_{v_1} \\ 
\gr{X}_{v_2} \\ 
\gr{X}_{v_3}
\end{bmatrix}
\ \ \text{and} \ \ 
\mathbf{D} \cdot 
\mathbf{A} \cdot 
\begin{bmatrix}
\gr{Y}_w \\ 
\gr{Z}_w \\ 
\Commitment'_{i-1}
\end{bmatrix} 
= 
\begin{bmatrix}
\gr{Z}_{v_1} \\ 
\gr{Z}_{v_2} \\ 
\gr{Z}_{v_3}
\end{bmatrix} 
= 
q^{2^{i-1}} \cdot 
\begin{bmatrix}
\gr{X}_{v_1} \\ 
\gr{X}_{v_2} \\ 
\gr{X}_{v_3}
\end{bmatrix}
+ 
\mathbf{W}  
\ \text{and} \ \ a \cdot \mathbf{W} = 0
$$

Substituting for the column vector $(\gr{X}_{v_1}, \gr{X}_{v_2}, \gr{X}_{v_3})$ we get: 

$$  \mathbf{A} \cdot 
\begin{bmatrix}
\gr{Y}_w \\ 
\gr{Z}_w \\ 
\Commitment'_{i-1}
\end{bmatrix} 
= 
q^{2^{i-1}} \cdot \mathbf{A} \cdot  
\begin{bmatrix}
\gr{X}_{w} \\ 
\gr{Y}_{w} \\ 
\Commitment_{i-1}
\end{bmatrix}  \ \
+ 
\begin{bmatrix}
\gr{W}_{v_1} \\ 
\gr{W}_{v_2} \\ 
\gr{W}_{v_3}
\end{bmatrix}  \ \
$$

Since $\mathbf{A}$ is a Vandermonde matrix with distinct rows, $det(\mathbf{A} \cdot \mathbf{D}) \neq 0$. Therefore, by Lemma~\ref{lem:extraction}, there exists a matrix $\mathbf{P}$ such that $\mathbf{P}\cdot \mathbf{A} = \mathbf{D}$ where $\mathbf{D}$ is a diagonal matrix with non-zero entries $d_1, d_2, d_3$. This means that: 

$$  
\begin{bmatrix}
d_1 \cdot \gr{Y}_w \\ 
d_2 \cdot \gr{Z}_w \\ 
d_3 \cdot \Commitment'_{i-1}
\end{bmatrix} 
= 
q^{2^{i-1}} \cdot
\begin{bmatrix}
d_1 \cdot \gr{X}_{w} \\ 
d_2 \cdot \gr{Y}_{w} \\ 
d_3 \cdot \Commitment_{i-1}
\end{bmatrix}  \ \
+ 
\mathbf{P} \cdot 
\mathbf{W} \ \ \text{and} \ \ a \cdot \mathbf{P} \cdot \mathbf{W} = 0
$$

This implies that $d_1 d_2 \cdot \gr{Z}_w = q^{2^{i-1}} \cdot (d_2 d_1 \cdot q^{2^{i-1}} \cdot \gr{X}_w + \langle \mathbf{P}_1, \mathbf{W} \rangle) + d_1 \cdot \langle \mathbf{P}_2, \mathbf{W} \rangle$. Let $d \deq d_1 d_2$ and let $\gr{W}_w \deq \gr{Z}_w - q^{2^{i}} \cdot \gr{X}_w$. 
We have that $d \cdot \gr{W}_w = q^{2^{i-1}} \cdot \langle \mathbf{P}_1, \mathbf{W} \rangle  + d_1 \cdot \langle \mathbf{P}_2, \mathbf{W} \rangle$. Hence, $a \cdot d \cdot \gr{W}_w = 0$. Set $a_w \deq a \cdot a$. 
 
We also have the relation $d_3 \Commitment'_{i-1} = q^{2^{i-1}} \cdot \Commitment_{i-1} + \langle \mathbf{P}_3, \mathbf{W} \rangle$. Setting $\gr{W}'_w \deq \Commitment'_{i-1} - q^{2^{i-1}} \cdot \Commitment_{i-1}$ we have $d_3 \cdot \gr{W}'_w = \langle \mathbf{P}_3, \mathbf{W} \rangle$, hence $a \cdot d_3 \cdot \gr{W}'_w = 0$. Let $a'_w \deq a \cdot d_3$.  
	\end{proof}

	
\begin{lemma}[Security Odd Even Dark]
	The protocol presented in \cref{sec:oddeven} is an interactive proof of knowledge for the $\Relation_\PC$ relation.
\end{lemma}
\ben{$\Relation_\PC$ is not yet defined anywhere else...}
\begin{proof}

~\paragraph{Extractor construction}
		We define a knowledge extractor that runs with an adversary $\adv$ who succeeds for public inputs $\{\Commitment,d,b \}$ and $q$ with probability $\epsilon = 1/\poly$. The extractor begins by using the tree-finding algorithm of Lemma~\ref{lem:forking} to generate a tree of accepting transcripts with the following characteristics: 
\begin{itemize}
\item The tree has depth $\logd$ and branching factor $2$. We index nodes by $v \in [0, d)$.
\item The root is labeled with the publics inputs. 
\item Each non-leaf node $v$ distinct from the root is labeled with a challenge $\alpha_{v}$ and a prover message $\gr{C}_{E,v},\gr{C}_{O,v}$.
\item Each non-leaf node $v$ has two children each labeled with two distinct verifier challenges 
$\alpha_{v} \neq \alpha_{v}'$.
\item Each leaf node $v$ is labelled with the message $\hat{f}_v$ sent in a final round of the protocol. 
\end{itemize} 

\benedikt{Currently assuming the PoE relations are checked directly}
Since the verifier challenges in the protocol are sampled from $\mathcal{X} = [-2^{\lambda -1}, 2^{\lambda -1}]$, the probability of a collision over challenges $\alpha_1, \alpha_2 \sample \mathcal{X}$ sampled uniformly and independently is $2^{-\lambda}$. Thus, by Lemma~\ref{lem:forking} the tree-finding algorithm runs for $O(\poly/\epsilon)$ steps and succeeds with probability $1 - \negl/\epsilon$ to return a tree with these characteristics.

For the root node $\textsf{rt}$, define $\gr{C}_\textsf{rt} \deq \Commitment$. For any node $v$ on level $i$ which has verifier challenge $\alpha_v$ and a parent $w$ on level $i+1$ with prover message $\gr{C}_{E,w},\Commitment_{O,w}$, define $\gr{C}_v \deq \gr{C}_{E,w} + \alpha_v \cdot \gr{C}_{O,w}$.
We will show that given this tree, the extractor can compute for all nodes $v \in [0, d)$ an opening hint $(\hat{f}_v \in \ZZ(b)[X],\denom_v \in \ZZ,\gr{W}_v \in \GG,a_v \in \ZZ^+)$ for $\gr{C}_v$. That is: $\denom_v \cdot \gr{C}_v=\hat{f}_v(q) \cdot \Generator +\gr{W}_v$ and $a_v \cdot \gr{C}_v=0$. Additionally, for $v$ at level $i$, $||\hat{f}_v||_\infty \leq b\cdot 2^{(\log_2(d)+2(\logd-i)) \cdot \lambda}$.

It will do this by starting at the leaves and working its way up the tree.
For any leaf node $v$, the fact that the transcript is accepting implies $\Commitment_v= \hat{f}_v \cdot \Generator$ for $\hat{f}_v \leq b \cdot 2^{\logd \lambda}$. Recall $\hat{f}_v$ is a constant bounded by $b \cdot 2^{\logd \lambda}$. Therefore, $(f,1,0,1)$ is a valid opening for $\Commitment_v$.

 Next, suppose that the appropriate openings have been computed for all children of a node $w$ on the $i$th level. Denoting the two children of nodes $w$ with indices $v_1, v_2$ and the two challenges on each by $\alpha_1, \alpha_2$ \benedikt{use $\alpha$, $\alpha$'}. This means that $\gr{C}_{v_1} = \gr{C}_{E,w} + \alpha_1 \cdot \gr{C}_{O,w}$ and $\gr{C}_{v_2} = \gr{C}_{E,w} + \alpha_2 \cdot \gr{C}_{O,w}$.
Furthermore openings $(\hat{f}_{v_1},\denom_{v_1},\gr{W}_{v_1},a_{v_1})$ for $\gr{C}_{v_1}$ and  $(\hat{f}_{v_2},\denom_{v_2},\gr{W}_{v_2},a_{v_2})$ for $\gr{C}_{v_2}$ have been computed. 

This gives us the equality: 
$$\hat{f}_{v_i}(q) \cdot \Generator + \gr{W}_i = r_i \cdot C_{v_i} = \denom_i \cdot (\Commitment_{E,w} + \alpha_i \cdot \Commitment_{O,w}) \quad \text{for} \ i \in \{1,2\}$$

From which we can derive:
$$(\denom_2 \hat{f}_{v_1}(q)-\denom_1 \hat{f}_{v_2}(q)) \Generator + \gr{W}_{O,w}=\denom_1 \denom_2 (\alpha_1-\alpha_2) \Commitment_{O,w}$$
and additionally
$$(\alpha_2 \denom_2 \hat{f}_{v_1}(q)-\alpha_1  \denom_1 \hat{f}_{v_2}(q)) \Generator + \gr{W}_{E,w}=\denom_1 \denom_2 (\alpha_2-\alpha_1) \Commitment_{E,w}$$

for $\gr{W}_{E,w}$ and $\gr{W}_{O,w}$ being elements of known order.
Using the extractor of the Batch PoE protocol we get that 
$$\gr{C}_w= \gr{C}_{E,w}+q^{2^i} \gr{C}_{O,w}+\gr{W}'$$
Let $\denom_w=\denom_1 \denom_2 (\alpha_22 − \alpha_1 )$. 
Further $\frac{\hat{f}_w}{\denom_w}=\frac{\denom_2 \hat{f}_{v_1}(q)-\denom_1 \hat{f}_{v_2}(q)}{\denom_1 \denom_2 (\alpha_1-\alpha_2)} \in \QQ$ is the reduced rational that encodes a polynomial in $\ZZ[X]$ with bounded coefficients. We will later argue about the size of the coefficients under different assumptions. 

\begin{itemize}
	\item Compute opening of $\Commitment_{E,w}$. 
	\item Use PoE to argue that we can compute an opening to $\Commitment_w$
	\item Argue bounded size
\end{itemize}
\paragraph{Coefficient size}
We will argue about the size of the extracted coefficients. Under the strong RSA assumption $\denom_w=1$ as otherwise by \benedikt{Fill in Lemma} we can compute a non trivial root of $\gr{G}$. This means in the extraction step the coefficient of $f_w(X)$ is less than the coefficients of $f_{v_1}$ and $f_{v_2}$ \benedikt{Exclude the case that $\alpha_1-\alpha_2=1$}. 
	\end{proof}


\section{Other ideas (WIP)}
\subsection{No field elements eval}


\begin{mdframed}
Public Input: $C\in \GG,z\in \ZZ_p,y\in \ZZ_p$\\
Witness: $f(X) \in \ZZ_p[X]$ \\
Claim: $C=\commit(f(X))$, $\deg(f(X))<d$ and $f(z)=y \bmod p$
	\begin{enumerate}[nolistsep]
		\item $\prover$ computes $q(X) \in \ZZ_p[X]=f(X)//(X-z) \bmod p$ and $Q\gets\commit(q(X))$
		\item \prover sends $Q$ to $\verifier$.
		\item $\prover$ and $\verifier$ compute $D\gets C/(Q^{(q-z)}g^y)$ \pccomment{$D$ commits to $h(X)=f(X)-q(X)(X-z)-y\equiv 0\bmod p$.}

		\item \prover and \verifier run $\textsf{DegreeProof}(D,Q^q,d;h(X),q(X)\cdot X)$
	\end{enumerate}
\end{mdframed}

Assume $d+1$ is a power of $2$
\begin{mdframed}
\begin{minipage}{\textwidth}
			$\pro{DegreeProof}(\crs, \gr{C},\gr{Q}\in \GG, d \in \NN; h(X),q(X)\in \ZZ_p[X]) :$ \pccomment{$\tilde{f}(X) = \sum_{i=0}^d \tilde{f}_i X^i$}
			\begin{enumerate}[nolistsep]
					\item \verifier samples challenge $\alpha$ 
			\item $\gr{C}'\gets \gr{C}^{\alpha}Q$
			\item \prover and \verifier run $\pro{DegreeProofBounded}(\params,q,\gr{C}',d,p\cdot 2^\lambda;\alpha \cdot h(X)+f(X))$
        \item \ \verifier checks that $b\cdot \boldsymbol{\varsigma}_{p,d} < q$\pccomment{$\boldsymbol{\varsigma}_{p,d}=O(p^{2\log(d)})$ (see Theorem~\ref{thm:polycommitsecurity} and \ref{thm:dyadicpolysecurity})}
        %q/(2^{\lceil \log_2(d+1) \rceil+1} p^{2 \lceil \log_2(d+1) \rceil+1})$
        \item \pcind[1] \verifier checks that $|h|\leq b$ and 
          \item \pcind[1] \verifier checks that $f\equiv 0 \bmod p$
                \item \label{line:baseend}\pcind[1] \verifier checks that $\Generator^{\alpha h}=\gr{C}$
\item \pcind[1] \verifier outputs $1$ \pcif all checks pass, $0$ otherwise.
		    \end{enumerate}
		    		\vspace{1em}
		$\pro{EvalBounded}(\crs,q,\gr{C}'\in \GG,d\in \NN,b\in \ZZ;\alpha h(X),f(X)\in \ZZ(b)[X])$		
	    \begin{enumerate}[nolistsep]
        \item \pcif $d=0$:
        \item \label{line:basestart}\pcind[1] \pcreturn $\gr{C}$ to $\prover$ and $\verifier$ and $\alpha h(X), f(X)$ \pccomment{$\alpha h(X)$ and $f(X)$ are constants}

        
        \item \pcelse: \pccomment{$d \geq 1$ and $d+1$ is even}
       
        \item \pcind[1] \prover and \verifier compute $d' \gets \lfloor\frac{d}{2}\rfloor$
        \item \pcind[1] \prover computes $f_E(X) \gets \sum\limits_{i=0}^{d'} f_{2\cdot i} \cdot X^i$ and $f_O(X)\gets\sum\limits_{i=0}^{d'} f_{2\cdot i 1}\cdot X^{i}$
        \item \pcind[1] \prover computes $\gr{C}_E \gets \Generator^{f_L(q^2)}$ and $\gr{C}_O \gets \Generator^{f_R(q^2)}$
        \item \pcind[1] \prover sends $\gr{C}_E, \gr{C}_O$ to \verifier. \pccomment{See Section \ref{subsec:optimization} for an optimization}
        \item \pcind[1] \label{line:PoE} \prover and \verifier run $\pro{PoE}(\gr{C}_E, \gr{C}/\gr{C}_O, q)$\pccomment{Showing that $\gr{C}_E\gr{C}_O^{q}=\gr{C}$}
        \item \pcind[1] \verifier samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to \prover
        \item \pcind[1] \prover and \verifier compute $\gr{C}' \gets \gr{C}_E^\alpha  \gr{C}_O$, $b'\gets b \cdot 2^{\lambda}$. 
        \item \pcind[1] \prover computes $f'(X) \gets \alpha \cdot f_E(X) + f_O(X) \in \ZZ[X]$  and\\
        \pcind[1] $h'(X)=\alpha h_E(X) + h_O(X)$\pccomment{$\deg(f'(X))=\deg(h'(X))=d'$}
        \item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}',q^2, d',b' ; \alpha f'(X))$
               \end{enumerate}
      \end{minipage}
\end{mdframed}


\section{Ben's lemmas}

Let $\G$ denote the abelian group (i.e., $\G$ is a $\Z$-module) that contains the space of commitments for the PCS. We first prove an elementary linear algebraic fact. 

\begin{lemma}\label{lem:triangularization}
Let $\G$ be a $\Z$-module. Let $p$ be a prime and $\F = \Z_p$. Given two vectors $\x, \y \in \G^n$ and a system of equations $\mathbf{A} \x = \y$ for a matrix $\A \in \Z^{n \times n}$ that is invertible over $\F$, 
there is an efficient algorithm to derive a diagonal matrix $\mathbf{D}$ with diagonal entries  $(d_1,...,d_n) \in \Z^n$, where $d_i \neq 0 \bmod p$ for all $i$, and a matrix $\mathbf{L}$ such that $\mathbf{D} \cdot \x = \mathbf{L} \cdot \y$. In particular, $\mathbf{L} \mathbf{A} = \mathbf{D}$.    
\end{lemma} 
\begin{proof} 
Since $det(\mathbf{A}) \neq 0 \bmod p$, by Gaussian elimination there is a triangularization matrix $\mathbf{P}$ such that $\mathbf{P} \mathbf{A} = \mathbf{T}$ is lower triangular with a diagonal of integer values that are non-zero over $\F$ (i.e., it is in reduced row-echelon form). 
Since $\mathbf{P} \mathbf{A} \cdot \x = \mathbf{T} \cdot \y= \mathbf{P}\cdot \y$, there exists an integer $d_1$ (i.e., upper left entry of $\mathbf{T}$) such that $d_1 \cdot x_1 =\langle \mathbf{P}_1, \y \rangle$, where $\mathbf{P}_1$ is the first row of $\mathbf{P}$. Denote by $\x^{(i)}$ the vector that swaps the 1st and $i$th coordinates of $\x$. Denote by $\A^{(i)}$ the matrix that results from swapping the first and $i$th columns of $\A$. We have $\A^{(i)} \x^{(i)} = \y$. 
 For each $i \in [n]$, repeat the triangularization process on $\A^{(i)}$ to get $\mathbf{P}^{(i)}$ such that $\mathbf{P}^{(i)} \cdot \A^{(i)} = \mathbf{T}^{(i)}$ is lower triangular. The upper left entry of $\mathbf{T}^{(i)}$ is an integer $d_i \neq 0 \bmod p$, and $d_i \cdot x_i = \langle \mathbf{P}^{(i)}_1, \y \rangle$.
  Return the matrix $D$ with diagonal entries $d_1,...,d_n$ and the matrix $L$ with row vectors $\mathbf{P}^{(i)}_1$ for $i \in [n]$. 
\end{proof} 

The next lemma is a direct result of this fact. 

\begin{lemma}\label{lem:extraction}
Given two vectors of commitments $\mathbf{C}, \mathbf{C^*} \in \G^n$, a system of equations $\mathbf{A} \mathbf{C} = \mathbf{C^*}$ for an integer matrix $\mathbf{A} \in \Z^{n \times n}$ that is invertible over $\F_p$, and a vector of openings of $\mathbf{C^*}$ to a vector of polynomials $\mathbf{f^*} = (f_1^*,...,f_n^*) \in (\FF)^n$, there is an efficient algorithm to derive polynomials $\mathbf{f} = (f_1,...,f_n) \in (\FF)^n$, integer vector $\mathbf{t} \in \Z^n$ such that $t_i \neq 0 \bmod p$, and openings for each $t_i \cdot \mathbf{C}_i$ to the polynomial $t_i \cdot f_i \bmod p$ such that $\mathbf{A} \cdot \mathbf{f} = \mathbf{f^*} \bmod p$. 
\end{lemma} 
\begin{proof} 
By Lemma~\ref{lem:triangularization}, there exists a diagonal matrix $\mathbf{T}$ with integer entries $t_1,...,t_n \neq 0 \bmod p$ and a matrix $\mathbf{L}$ such that $\mathbf{T} \cdot \mathbf{C} = \mathbf{L} \cdot \mathbf{C}^*$ and $\mathbf{L} \cdot \mathbf{A} = \mathbf{T}$. 
  From each linear combination of $\mathbf{C^*}$, we use $\add^*$ to derive an opening of $t_i \cdot \mathbf{C}_i$ to a polynomial $g_i = \langle \mathbf{L}_i, \mathbf{f^*} \rangle \in \FX$.
   Let $\mathbf{g} = (g_1,...,g_n)$. Finally, solve for the vector of polynomials $\mathbf{f}$ such that $\mathbf{A} \cdot \mathbf{f} = \mathbf{f^*}$ by computing $\mathbf{A}^{-1} \bmod p$. Note that $\mathbf{L} \cdot \mathbf{A} \cdot \mathbf{f} = \mathbf{T} \cdot \mathbf{f} = \mathbf{L} \cdot \mathbf{f}^*$ where $\mathbf{T}$ is a diagonal matrix with entries $t_i \neq 0 \bmod p$. Thus, $t_i f_i = g_i$, for which we have a valid opening of $t_i \cdot \mathbf{C}_i$.   
\end{proof}

\begin{lemma}[Forking Lemma]\label{lem:forking}
Let $(\prover, \verifier)$ be an $r$-round public-coin interactive proof system and $\mathcal{A}$ an adversary such that $\langle \mathcal{A}(\pp, x), \verifier(\pp, x) \rangle = 1$ with probability $\epsilon > \negl(\lambda)$ on public input $x$ and public parameters $\pp$.  Let $\{\pi_i\}_{i =1}^r$ be a set of properties $\pi_i: \mathcal{X}^2 \rightarrow \{0,1\}$ such that $\forall_{i} \ Pr[ \pi(x_1, x_2) = 1: x_1, x_2 \sample \mathcal{X}] > 1 - \negl(\lambda)$. There exists an algorithm $\mathcal{T}$ that runs in time $O(\lambda/\epsilon)$ and outputs an $(n_1,...,n_r)$-tree of accepting transcripts such that with probability $\Omega(1 - \frac{r \cdot\negl(\lambda)}{\epsilon})$ in each $i$th level of the tree every pair of sibling-node challenges $x_1, x_2$ satisfy $\pi_i(x_1, x_2) = 1$. 
\end{lemma} 

\section{Evaluation}

We evaluate 
 \bibliographystyle{alpha}
 \bibliography{../cryptobib/abbrev3,../cryptobib/crypto,cryptobib/additional}
\end{document}
