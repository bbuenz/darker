\documentclass[12pt]{article}
\pagestyle{plain} 
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics,advantage]{cryptocode}
\usepackage{notations}
%\usepackage{bm}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath,amssymb}
\usepackage[utf8x]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{xspace}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{cleveref}
%\usepackage{authblk}
%\usepackage{draftwatermark}
\usepackage[legalpaper, margin=1in]{geometry}
\usepackage{comment}
\usepackage{todonotes}
\theoremstyle{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}


\title{Darker}

\begin{document}
	
\maketitle
\section{Sketched Protocol}
Using additive notation. 

\subsection{Odd Even Protocol}
\begin{mdframed}
Public Input: $C\in \GG$\\
Witness: $f(X) \in \ZZ_p[X]$ \\
Claim: $\Commitment =\commit(f(X))$ and $\deg(f(X))<d$	\\
$\textsf{FFTEval}(q,C,d;f(X))$
\begin{enumerate}[nolistsep]
		\item $\pcif d=0$
		\item $\pcind[1]$ $\prover$ sends $f=f(X)$
		\item $\pcind[1]$ $\verifier$ checks that $|f|<2^{\log_2(d_{\max}) \cdot \lambda}$ and that $f \cdot \Generator=\Commitment$\pccomment{$d_{\max}$ is the original degree here}
		\item $\prover$ computes $f_E(X)$ and $f_O(X)$ s.t. $f_E(X^2)+X \cdot f_O(X^2)=f(X)$\pccomment{Odd and Even coefficients} 
		\item \prover sends $\Commitment_E\gets \commit(f_E(q^2))$ and $\Commitment_O\gets \commit(f_O(q^2))$ to $\verifier$.
		\item $\verifier$ checks that $\Commitment_E+ q\cdot \Commitment_O=\Commitment$ \pccomment{$q$ grows in each round. Outsourced with PoEs. See below}
		\item $\verifier$ samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to $\prover$
		\item \prover and \verifier compute $\Commitment'\gets \Commitment_E+\alpha \cdot \Commitment_O$
		\item $\prover$ computes $f'(X)\gets f_E(X)+\alpha f_O(X)$
		\item \prover and \verifier run $\textsf{FFTEval}(q^2,\Commitment',\frac{d}{2};f'(X))$
	\end{enumerate}
\end{mdframed}

\subsection{Computing all PoEs at once}
Let the subscript $i$ denote proof elements from the $i$th round of the protocol. Let $\numrounds=\logd$ be the number of rounds in the protocol.
Let $\gr{D}_{i}\gets \gr{C}_{O,i}$ and $\gr{D}_{i}'\gets \gr{C}_{i}-\gr{C}_{i}$ for $i \in [1,\numrounds]$ such that $q^{2^{i-1}} \cdot \gr{D}_i=\gr{D}'_i$ for all $i\in [\numrounds]$. The prover and verifier run the following \textsf{BatchPoE} protocol that the claims hold.
\begin{mdframed}
Prover and Verifier Input: $[\gr{D}_i,\gr{D}_i']_{i=1}^{\numrounds},q$\\
Claim: $q^{2^{i-1}}\cdot \gr{D}_i=\gr{D}'_i \quad \forall i \in [\numrounds]$
	\begin{enumerate}[nolistsep]
\item $\gr{X}_{\numrounds}=\gr{D}_{\numrounds-1}$, $\gr{Z}_{\numrounds-1}=\gr{D}'_{\numrounds}$
	\item $\pcfor i \in [\numrounds-1,2]$
   \item \pcind[1]$\gr{Y}_{i}\gets q^{2^{i}}\cdot \gr{X}_{i}$ \pccomment{Computable either through multi exponentiation using bases: $\Generator_j=q^{ 2^{j}} \cdot \Generator$ or directly.}
\item\pcind[1]\prover sends $\gr{Y}_{i}$ to $\verifier$
	\item \pcind[1]$\verifier$ samples $\alpha,\beta \sample [-2^{\lambda-1} ,2^{\lambda-1}]$ and sends them to $\prover$
	\item \pcind[1]\prover and \verifier compute  $\gr{X}_{i-1}\gets  \gr{X}_{i}+ \alpha\cdot  \gr{Y}_{i}+\beta \cdot\gr{D}_{i-1}$
	\item $\pcind[1]$\verifier compute   $\gr{Z}_{i-1}\gets \gr{Y}_{i}+\alpha\cdot \gr{Z}_{i}+\beta\cdot \gr{D}_{i-1}^{'}$
\item \verifier checks that $q\cdot \gr{X}_1=\gr{Z}_1$
\end{enumerate}
\end{mdframed}

\subsection{Computational complexity of batch PoE}
The main prover work is in computing $\gr{Y}_i$. In the first few loops $\gr{Y}_i=g^{h(q)}$ for a sparse polynomial $h(X)$. For example in the first loop $h(X)$ has only a single non-zero coefficient.
After $\logd/2$ rounds the polynomial has roughly $\sqrt{d}$ coefficients. It then makes sense to switch to computing $\gr{Y}_i$ using a sequential computation, i.e. $\gr{Y}_i=\gr{X}_i^{q^{2^{i-2}}}$. This now also takes $O(\sqrt{d}\cdot \log{d})$ work. One could also switch earlier from one computation to the other. Additionally it is possible to use Wesolowski PoEs for the second part of the loop, i.e. the first half of the Odd/Even protocol. This leads to a smaller proof size. One possible split may be to only do $\log{\log{d}}$ BatchPoEs at the end. This should give you prover time that is still linear but better proof size. In practice doing BatchPoE for the last $6$ rounds should be good for almost all input sizes.
\section{$\tilde{O}(\sqrt{d})$ eval}
The PoEs are efficient and with some caching during the commitment phase we can also make the rest of the eval have $\tilde{O}(\sqrt{d})$ complexity (only group operations). The protocol is parameterized by a bound $b$ which determines the amount of preprocessing. We discuss the perfect choice for $b$ later but for intuition it helps to think of $b=d/b=\sqrt{d}$.
\subsection{Idea}
The core idea is that we can write a polynomial $f(X)$ of degree $d-1$ as the sum of $b$ polynomials $f_i(X)$ of degree less than $\frac{d}{b}$. That is $f(X)=\sum_{i=0}^b X^i f_i(X^b)$. This is a direct generalization of the odd/even split that the $\textsf{FFTEval}$ protocol uses. During the committing phase the prover computes and stores commitments to $f_i(X^b)$, i.e. $P_i\gets g^{f_i(q^b)}$. Using the $\frac{d}{b}$ precomputed group elements $g,g^{q^b},g^{q^{2b}}\dots$ all $b$ $P_i$'s can be computed using $d$ $\lambda$-bit exponentiations\footnote{Ignoring multi-exponentiation speedups for now}. Given the $P_i$'s one can compute $C=g^{f(q)}$. This is because $C=\prod_{i=0}^{b-1} P_i^{q^i}$. By computing this product left to right, i.e. $C=(((P_{b-1}^qP_{b-2})^qP_{b-3})^q \dots)P_0$ this can be done using only $b$ $\log_2(q)$-bit exponentiations.

Similarly the prover can use the $P_i$ to compute to $C_O$, i.e. the commitment to $f_O(X^2)$ where $f(X)=f_E(X^2)+Xf_O(X^2)$. Additionally computing $C_O'=g^{q f(q^2)}$ can be done efficiently given just $C_O$ as $C_O'=C_O^q$. 

After each round the protocol continues with $f'(X)=f_E(X)+\alpha f_O(X)$ as a witness and $q_{i+1}=q_{i}^2$. Similarly as in the first round we can write $f'(X)$ as the sum of $b/2$ polynomials of degree less than $\frac{d}{b}$.
$f'(X)=\sum_{i=0}^{\frac{b}{2}-1} X^i f'_i(X^{\frac{b}{2}})$. Given the commitments to the $f_i(X^b)$ we can efficiently compute commitments to $f_i'(X)=f_{2i}(X)+\alpha f_{2i+1}(X)$ as $P_i'\gets P_{2i}P_{2i+1}^{\alpha}$. This takes work at most $b$, $\lambda$-bit exponentiations. Repeating this for $\log_2(b)$ rounds we end up with a witness polynomial $f''(X)$ of degree less than $\frac{d}{b}$. Given the precomputed $g_i$ the prover can construct commitments to $f''(X)$ and finish the protocol using $\frac{d}{b}$ $\lambda$-bit exponentiations. In the first $\log_2(b)$ steps the most expensive operations is computing $C_O$ given the $P_i$'s. This takes roughly $b$ $\log_2(q)$-bit exponentiations in every round, i.e. $b\log_2(b) \log_2(q)$-bit exponentiations in total.
\subsection{Protocol}
\begin{mdframed}
$\textsf{Preprocess(b)}$:
\begin{enumerate}[nolistsep]
	\item $g_i=g^{q^{ib}}$ for $i \in [0,\frac{d}{b}-1]$
	\item Output $g_0,\dots,g_{\frac{d}{b}-1}$
\end{enumerate}
$\textsf{Commit}(f(X),b):$
\begin{enumerate}[nolistsep]
	\item $f(X)=\sum_{i=0}^{b-1} X^{i} f_i(X^{b})$ \pccomment{$\deg(f_i(X))<\frac{d}{b}$.}
	\item Let $P_i\gets g^{f_i(q^b)}$ for all $i \in [0,b-1]$\pccomment{ computed using $g_i$; Cost: $d$ $\lambda$-bit exp.}
	\item Compute $C\gets \prod_{i=0}^{b-1} P_i^{q^i}=((P_{b-1}^q P_{b-2})^q P_{b-3})^q...P_0$ \pccomment{Cost: $b$ $\log_2(q)$-bit exp.}
	\item Output $C$ and $P_{0}\dots,P_{b-1}$
\end{enumerate}
$\textsf{FFTEval}(q,C,P_0,\dots,P_{b-1},b,d;f_0(X),\dots,f_{b}(X))$
\begin{enumerate}[nolistsep]
		\item $\alpha_0=\hash(C,f_0,q,b)$ 
		\item $\pcfor i=1$ to $\log_2(b)$
		\item $\pcind[1]$ $C_{O,i}\gets\prod_{j=0}^{\frac{b}{2^i}-1} P_{2j+1}^{q^{j\cdot 2^i}}$ \pccomment{Computed using folding method, Total Cost: $b \log{b}$ $\log_2(q)$-bit exp}.
		\item \pcind[1] $C_{O,i}'=C_{O,i}^{q^{2^i}}$ \pccomment{Total cost (all iterations) $b$ $q$-bit exp, might as well do W PoE here}
		\item \pcind[1] $\alpha_i\gets \hash(\alpha_{i-1} C_{O,i})$ \pccomment{Fiat-Shamir}
		\item $\pcind[1] P_{j}=P_{2j}P_{2j+1}^{\alpha}$ for $j \in [0,\frac{b}{2^i}]$\pccomment{$b$ $\lambda$-bit exp in total}
		\item $f'(X)\gets \sum_{i=0}^{b-1} f_i(X) \prod_{j=1}^{\log_2(b)} \alpha_j^{j\text{th last bit of }i}$ \pccomment{$f_0(X)+\alpha_1 f_1(X) + \alpha_2 f_2(X)$, Cost: $d$ field ops}
		\item \pcfor $i=\log_2(b)+1$ to $\logd$
		\item \pcind[1] $f'(X)=f_E(X^2)+Xf_O(X^2)$
		\item \pcind[1] $C_{O,i}\gets g^{f_O(q^{2^i})}$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp}
		\item  \pcind[1] $C_{O,i}'\gets g^{q^{2^{i-1}} \cdot f_O(q^{2^i})}$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp using $g_i$}
		\item \pcind[1] $\alpha_i\gets\hash(C_{O,i},C_{O,i}')$
		\item \pcind[1] $f'(X)=f_E(X)+\alpha_i f_O(X)$
		\item Proof is $C_{O,1},\dots,C_{O,\logd}$ and $C_O$'s
		\item Add $f'=f'(X)$ to proof.
	\end{enumerate}
	\end{mdframed}
	For $b=\sqrt{d}$ the runtime is $O(d \logd^2)$. A value like $b=\sqrt{d/\log(d)}$ gives roughly $O(d\logd^{1.5})$. Parallelism and multi-exp techniques need to be taken into account and the optimal value is likely best determined numerically. There are limited options anyway as $b$ needs to be a power of $2$.\\ 
Step 2 in FFTEval is likely a bottleneck. Smaller q value would still help in this protocol.
\section{Security Proof}
We state a version of the RSA assumption as described by $\cite{EC:CouPetPoi17}$.
\begin{assumption}[RSA assumption,\cite{RivShaAdl78,EC:CouPetPoi17} ]
	The RSA assumption states that an efficient adversary cannot compute a random root (co-prime with the order of the group) for a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\[
    \Pr\left[\ell \cdot \gr{U} = \Generator \wedge \gcd(\ell,|\GG|)=1:
    \begin{array}{l}
         \GG,B \leftarrow \ggen(\lambda)  \\
         \Generator \sample \GG, \ell \sample [B]  \\
         \gr{U} \in \mathbb{G} \leftarrow \adv(\mathbb{G}, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
\]

\end{assumption}

\begin{assumption}[Random order assumption]
	The random order assumption states that an efficient adversary cannot compute a multiple of the order of a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\[
    \Pr\left[a\cdot \Generator =0:
    \begin{array}{l}
         \GG,B \leftarrow \ggen(\lambda)  \\
         \Generator, \sample \GG\\
         a \in \NN \leftarrow \adv(\mathbb{G},B, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
    \]
\end{assumption}
\begin{lemma}
\label{lem:roa-to-rsa}
	The RSA assumption for $\ggen$ implies the random order assumption
	\end{lemma}
\begin{proof}
	Given an efficient adversary $\adv_{\textsf{Order}}$ for the random order assumption we will construct an efficient adversary $\adv_{\textsf{RSA}}$ for the RSA assumption. On input $\GG,\Generator,\ell$ to $\adv_{\textsf{RSA}}$ we will forward $\GG,\Generator$ to $\adv_{\textsf{Order}}$. $\adv_{\textsf{Order}}$ outputs $a$ such that $a\cdot \Generator=0$ with non-negligible probability $\epsilon$. 
	We compute $a'=\frac{a}{\gcd(a,\ell)}$. Note that since $\ell$ is co-prime to the order of $\GG$ and thus also the order of $\Generator$ and $a$ is a multiple of the order of $\Generator$ we have that $a'$ is still a multiple of the order of $\Generator$. Now $\adv_{\textsf{RSA}}$ computes $w\gets \ell^{-1} \bmod a'$ and outputs $\gr{U} \gets w\cdot \Generator$. $\ell \cdot \gr{U}=\Generator$ so $\adv_{\textsf{RSA}}$ succeeds with probability $\epsilon$.
\end{proof}
\begin{definition}[Augmented GUO Commitment]
We describe an augmented polynomial commitment for groups of unknown order.
\begin{itemize}
	\item 
The setup algorithm $\setup$ on input $\secparam$ and max degree $D$ and prime $p$ samples a group of unknown order $\GG$ and a $g\sample \GG$ and sets $q=2^k$ for $k \in \NN$ such that $q>p\cdot 2^{\lambda \cdot \logd}$. The algorithm outputs $\crs=(\GG,g,q,p,D)$

\item The commitment algorithm $\commit$ on input $f(X)\in \ZZ_p$ lifts $f(X)$ to the integer polynomial $\hat{f}(X)$ with coefficients bounded by $p$ and outputs $\Commitment =f(q) \cdot \Generator$
\item The open algorithm $\open$ outputs $f(X),\gr{W} \in \GG,\alpha \in \NN$
\item The verify commitment algorithm checks that $\alpha\cdot \gr{W}=0$ and that $\Commitment =f(q)\cdot \Generator +\gr{W}$
\end{itemize}

\end{definition}
\begin{lemma}[Binding commitment]
\label{lem:aug-com-binding}
	The commitment is binding under the random order assumption. 
\end{lemma}
\begin{proof}
	Given a commitment $C$ and two openings $f(X),w,\alpha$ and $f'(X),w',\alpha'$ with $f(X)\neq f'(X)$. $f(X),f'(X)$ have bounded coefficients so $f(q)\neq f'(q)\in \ZZ$. This implies that $(f(q)-f'(q))\cdot \Generator+w-w'=0$. 
	We cancel out the $w$ and the $w'$ term to get $\alpha\cdot \alpha'\cdot (f(q)-f'(q)) \Generator=0$. $\cdot \alpha'\cdot (f(q)-f'(q))$ is a root of $\Generator$ 
	which breaks the Random Order assumption and by \cref{lem:roa-to-rsa} also the RSA assumption.
	\end{proof}
	
	\begin{lemma}[PoEs]
		The batch PoE protocol on input $[\gr{D}_i,\gr{D}_i']_{i=1}^{\numrounds}$ is an interactive proof of knowledge for the following relation:
		$$\mathcal{R}_{POE}=\{([\gr{D}_i,\gr{D}_i']_{i=1}^{\numrounds},q;\gr{W}_i\in \GG,a_i\in \ZZ): [\gr{D}_i'=q^{2^{\numrounds-i}}  \cdot \gr{D}_i+\gr{W}_i \wedge a_i\cdot \gr{W}_i=0]_{i=1}^{\numrounds-1} \}$$
	\end{lemma}
	\begin{proof}
	We will prove security by constructing an extractor $E$ that given rewinding access to an adversary $A$ is able to extract a valid witness. 
The extractor works in a round by round manner using $3$ transcripts with different challenges $\alpha_j$ and $\beta_j$ $j\in\{1,2,3\}$. 
 
\begin{itemize}
	\item Read $\gr{X}_1$ and $\gr{Z}_1$ from the transcript.
	\item In each round we have $\gr{X}_i \approx q^i \gr{Z}_i$. We use $\approx$ to denote equality but for an additive shift of a known order element.
	\item We will show that $\gr{X}_{i+1}\approx \gr{Z}_{i+1}$
	\item Let $C= \left\{\begin{array}{lll}
		1 & \alpha_1 & \beta_1\\
		1 & \alpha_2 & \beta_2\\
		1 & \alpha_3 & \beta_3
	\end{array}\right\} $ be the challenge matrix. 
	\item We find $P$ such that $P C$ is an upper triangle matrix. If it doesn't exist then the extractor aborts.
\end{itemize}
	We will show that if $q^{2^i}\cdot \gr{X}_i \cdot \gr{W}_i=\gr{Z}_i$ and $a_i \cdot \gr{W}_i=0$ then the extractor can compute $\gr{X}_{i+1},\gr{Y}_{i+1} \gr{W}_{i+1}, a_{i+1}$ such that $X_{i+1}^q\cdot W_{i+1}=Z_{i+1}$ and $a_{i+1}\cdot \gr{W}_{i+1}=0$.  
	The extractor rewinds the prover two times per round to get responses for  
	\end{proof}
	
	Proof idea:
	\begin{itemize}
		\item  We know that $\gr{D}_1^q=\gr{D}_1'$, $\gr{X}_1^q=\gr{Y}_1$ and $\gr{Y}_1^q=\gr{Z}_1$.
		\item Rewind the prover to get three challenge pairs $\alpha$ and $\beta$ per round.
		\item $q\cdot (\gr{X}_{i+1} +\alpha \gr{Y}_{i+1} +\beta \gr{D}_{i}')= \gr{Y}_{i} +\alpha \gr{Z}_{i} +\beta \gr{D}_{i}$
		\item Use a linear combination of $[(1,\alpha_i,\beta_i)]_{i=1}^3$ (likely full rank). 
		\item This shows that $\gr{X}_{i+1}= \gr{Y}_{i}$ and ...
	\end{itemize}
\subsection{Strong RSA to RSA assumption}
\begin{itemize}
\item CRS $\gr{G} \in \GG$
	\item Prover sends $\gr{C}_1,\gr{C}_2$
	\item 
Verifier sends $\alpha \in [0,2^\lambda]$
\item Prover sends $f' \in \ZZ, \gr{w}\in \GG, \rho \in \ZZ$
\item Verifier checks that $f' \cdot \gr{G}+\gr{w} =\alpha \cdot \gr{C}_1 +\gr{C}_2$ and $\gr{w}^\rho=1$
\end{itemize}
Run the protocol 3 times to compute $\Delta\alpha_1$, $\Delta\alpha_2$ and $\Delta f_1$ and $\Delta f_2$.
Let $f'_1\gets \frac{\Delta f_1}{\gcd(\Delta \alpha_1,\Delta f_1)}$ ,$\alpha'_1\gets \frac{\Delta \alpha_1}{\gcd(\Delta \alpha_1,\Delta f_1)}$ denote the reduced fractions. For an adversary with success probability $\epsilon$ either $f'_1\leq 8/\epsilon$ or $f'_1 >8/\epsilon$ with non negligible probability ($\approx\epsilon^2$). 
\paragraph{$f'_1$ is small.}
In that case we can compute 
\section{Other ideas (WIP)}
\subsection{No field elements eval}


\begin{mdframed}
Public Input: $C\in \GG,z\in \ZZ_p,y\in \ZZ_p$\\
Witness: $f(X) \in \ZZ_p[X]$ \\
Claim: $C=\commit(f(X))$, $\deg(f(X))<d$ and $f(z)=y \bmod p$
	\begin{enumerate}[nolistsep]
		\item $\prover$ computes $q(X) \in \ZZ_p[X]=f(X)//(X-z) \bmod p$ and $Q\gets\commit(q(X))$
		\item \prover sends $Q$ to $\verifier$.
		\item $\prover$ and $\verifier$ compute $D\gets C/(Q^{(q-z)}g^y)$ \pccomment{$D$ commits to $h(X)=f(X)-q(X)(X-z)-y\equiv 0\bmod p$.}

		\item \prover and \verifier run $\textsf{DegreeProof}(D,Q^q,d;h(X),q(X)\cdot X)$
	\end{enumerate}
\end{mdframed}

Assume $d+1$ is a power of $2$
\begin{mdframed}
\begin{minipage}{\textwidth}
			$\pro{DegreeProof}(\crs, \gr{C},\gr{Q}\in \GG, d \in \NN; h(X),q(X)\in \ZZ_p[X]) :$ \pccomment{$\tilde{f}(X) = \sum_{i=0}^d \tilde{f}_i X^i$}
			\begin{enumerate}[nolistsep]
					\item \verifier samples challenge $\alpha$ 
			\item $\gr{C}'\gets \gr{C}^{\alpha}Q$
			\item \prover and \verifier run $\pro{DegreeProofBounded}(\params,q,\gr{C}',d,p\cdot 2^\lambda;\alpha \cdot h(X)+f(X))$
        \item \ \verifier checks that $b\cdot \boldsymbol{\varsigma}_{p,d} < q$\pccomment{$\boldsymbol{\varsigma}_{p,d}=O(p^{2\log(d)})$ (see Theorem~\ref{thm:polycommitsecurity} and \ref{thm:dyadicpolysecurity})}
        %q/(2^{\lceil \log_2(d+1) \rceil+1} p^{2 \lceil \log_2(d+1) \rceil+1})$
        \item \pcind[1] \verifier checks that $|h|\leq b$ and 
          \item \pcind[1] \verifier checks that $f\equiv 0 \bmod p$
                \item \label{line:baseend}\pcind[1] \verifier checks that $\Generator^{\alpha h}=\gr{C}$
\item \pcind[1] \verifier outputs $1$ \pcif all checks pass, $0$ otherwise.
		    \end{enumerate}
		    		\vspace{1em}
		$\pro{EvalBounded}(\crs,q,\gr{C}'\in \GG,d\in \NN,b\in \ZZ;\alpha h(X),f(X)\in \ZZ(b)[X])$		
	    \begin{enumerate}[nolistsep]
        \item \pcif $d=0$:
        \item \label{line:basestart}\pcind[1] \pcreturn $\gr{C}$ to $\prover$ and $\verifier$ and $\alpha h(X), f(X)$ \pccomment{$\alpha h(X)$ and $f(X)$ are constants}

        
        \item \pcelse: \pccomment{$d \geq 1$ and $d+1$ is even}
       
        \item \pcind[1] \prover and \verifier compute $d' \gets \lfloor\frac{d}{2}\rfloor$
        \item \pcind[1] \prover computes $f_E(X) \gets \sum\limits_{i=0}^{d'} f_{2\cdot i} \cdot X^i$ and $f_O(X)\gets\sum\limits_{i=0}^{d'} f_{2\cdot i 1}\cdot X^{i}$
        \item \pcind[1] \prover computes $\gr{C}_E \gets \Generator^{f_L(q^2)}$ and $\gr{C}_O \gets \Generator^{f_R(q^2)}$
        \item \pcind[1] \prover sends $\gr{C}_E, \gr{C}_O$ to \verifier. \pccomment{See Section \ref{subsec:optimization} for an optimization}
        \item \pcind[1] \label{line:PoE} \prover and \verifier run $\pro{PoE}(\gr{C}_E, \gr{C}/\gr{C}_O, q)$\pccomment{Showing that $\gr{C}_E\gr{C}_O^{q}=\gr{C}$}
        \item \pcind[1] \verifier samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to \prover
        \item \pcind[1] \prover and \verifier compute $\gr{C}' \gets \gr{C}_E^\alpha  \gr{C}_O$, $b'\gets b \cdot 2^{\lambda}$. 
        \item \pcind[1] \prover computes $f'(X) \gets \alpha \cdot f_E(X) + f_O(X) \in \ZZ[X]$  and\\
        \pcind[1] $h'(X)=\alpha h_E(X) + h_O(X)$\pccomment{$\deg(f'(X))=\deg(h'(X))=d'$}
        \item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}',q^2, d',b' ; \alpha f'(X))$
               \end{enumerate}
      \end{minipage}
\end{mdframed}

 \bibliographystyle{alpha}
 \bibliography{../cryptobib/abbrev3,../cryptobib/crypto,cryptobib/additional}
\end{document}
