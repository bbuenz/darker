\documentclass[12pt]{article}
\pagestyle{plain} 
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics,advantage]{cryptocode}
\usepackage{notations}
%\usepackage{bm}
\usepackage{comment}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath,amssymb}
\usepackage[utf8x]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{xspace}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{cleveref}
%\usepackage{authblk}
%\usepackage{draftwatermark}
\usepackage[legalpaper, margin=1in]{geometry}
\usepackage{comment}
\usepackage{todonotes}
\theoremstyle{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{fact}{Fact}

\newif\ifcomments
\commentstrue
\ifcomments
	\newcommand{\ben}[1]{{\textcolor{red}{[\bf Ben: #1]}}}
    \else
	\newcommand{\ben}[1]{}
	
\fi


\title{Darker}

\begin{document}
	
\maketitle
\section{Sketched Protocol}
Using additive notation. 

\subsection{Odd Even Protocol}
\begin{mdframed}
Public Input: $C\in \GG$\\
Witness: $f(X) \in \ZZ_p[X]$ \\
Claim: $\Commitment =\commit(f(X))$ and $\deg(f(X))<d$	\\
$\textsf{FFTEval}(q,C,d;f(X))$
\begin{enumerate}[nolistsep]
		\item $\pcif d=0$
		\item $\pcind[1]$ $\prover$ sends $f=f(X)$
		\item $\pcind[1]$ $\verifier$ checks that $|f|<2^{\log_2(d_{\max}) \cdot \lambda}$ and that $f \cdot \Generator=\Commitment$\pccomment{$d_{\max}$ is the original degree here}
		\item $\prover$ computes $f_E(X)$ and $f_O(X)$ s.t. $f_E(X^2)+X \cdot f_O(X^2)=f(X)$\pccomment{Odd and Even coefficients} 
		\item \prover sends $\Commitment_E\gets \commit(f_E(q^2))$ and $\Commitment_O\gets \commit(f_O(q^2))$ to $\verifier$. 
		\item $\verifier$ checks that $\Commitment_E+ q\cdot \Commitment_O=\Commitment$ \pccomment{$q$ grows in each round. Outsourced with PoEs. See below}
		\item $\verifier$ samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to $\prover$
		\item \prover and \verifier compute $\Commitment'\gets \Commitment_E+\alpha \cdot \Commitment_O$
		\item $\prover$ computes $f'(X)\gets f_E(X)+\alpha f_O(X)$
		\item \prover and \verifier run $\textsf{FFTEval}(q^2,\Commitment',\frac{d}{2};f'(X))$
	\end{enumerate}
\end{mdframed}

\subsection{Computing all PoEs at once}
%Let the subscript $i$ denote proof elements from the $i$th round of the protocol. Let $\numrounds=\logd$ be the number of rounds in the protocol.
We present a \textsf{BatchPoE} protocol for proving that $\numrounds$ pairs of group elements $\{(\gr{G}_i, \gr{G}'_i)\}_{i=1}^k$ satisfy $q^{2^{i-1}} \cdot \gr{G}_i = \gr{G}'_i$ for all $i \in [\numrounds]$.
While this could be proved with $k$ independent PoE proofs, the protocol we present saves a factor $k$ in the communication cost over the naive solution.
%Let $\gr{D}_{i}\gets \gr{C}_{O,i}$ and $\gr{D}_{i}'\gets \gr{C}_{i}-\gr{C}_{i}$ for $i \in [1,\numrounds]$ such that $q^{2^{i-1}} \cdot \gr{D}_i=\gr{D}'_i$ for all $i\in [\numrounds]$. The prover and verifier run the following \textsf{BatchPoE} protocol that the claims hold.
\begin{mdframed}
\underline{\textsf{BatchPoE} \textbf{protocol}} \\
Prover and Verifier Input: $\{(\gr{G}_i,\gr{G}_i')\}_{i=1}^{\numrounds},q$\\
Claim: $q^{2^{i-1}}\cdot \gr{G}_i=\gr{G}'_i \quad \forall i \in \{1,...,\numrounds\}$
	\begin{enumerate}[nolistsep]
\item $\gr{X}_{\numrounds} \deq \gr{G}_{\numrounds}$, $\gr{Z}_{\numrounds} \deq \gr{G}'_{\numrounds}$
	\item $\pcwhile  i  > 1$
   \item \pcind[1]\prover computes $\gr{Y}_{i}\deq q^{2^{i-2}}\cdot \gr{X}_{i}$
\item\pcind[1]\prover sends $\gr{Y}_{i}$ to $\verifier$
	\item \pcind[1]$\verifier$ samples $\alpha \sample [-2^{\lambda-1} ,2^{\lambda-1}]$ and sends them to $\prover$
	\item \pcind[1]\prover and \verifier compute  $\gr{X}_{i-1} \deq  \gr{X}_{i}+ \alpha\cdot  \gr{Y}_{i}+\alpha^2 \cdot\gr{G}_{i-1}$
	\item $\pcind[1]$\verifier compute   $\gr{Z}_{i-1}\deq \gr{Y}_{i}+\alpha\cdot \gr{Z}_{i}+\alpha^2 \cdot \gr{G}_{i-1}^{'}$ 
	     \pccomment{Invariant: $q^{2^{i-2}} \cdot \gr{X}_{i-1} = \gr{Z}_{i-1}$ }
	\item $\pcind[1] i \deq i - 1$
\item \verifier outputs \textsf{accept} if and only if $q\cdot \gr{X}_1=\gr{Z}_1$
\end{enumerate}
\end{mdframed}

\ben{Leave out comment about how to compute $\gr{Y}_i$ when it has a special form where we apply this in the main protocol, i.e. via multi-exponentiation using bases $\Generator_j=q^{ 2^{j}} \cdot \Generator$ or directly. BathcPoE protocol should be independent. Explain in separate comment how to compute $\gr{Y}_i$ more efficiently when has special structure.}

\subsection{Computational complexity of batch PoE}
\ben{We analyze the complexity of Batch PoE both in general, and in the special case that...} The main prover work is in computing $\gr{Y}_i$. In the first few loops $\gr{Y}_i=g^{h(q)}$ for a sparse polynomial $h(X)$. For example in the first loop $h(X)$ has only a single non-zero coefficient.
After $\logd/2$ rounds the polynomial has roughly $\sqrt{d}$ coefficients. It then makes sense to switch to computing $\gr{Y}_i$ using a sequential computation, i.e. $\gr{Y}_i=\gr{X}_i^{q^{2^{i-2}}}$. This now also takes $O(\sqrt{d}\cdot \log{d})$ work. One could also switch earlier from one computation to the other. Additionally it is possible to use Wesolowski PoEs for the second part of the loop, i.e. the first half of the Odd/Even protocol. This leads to a smaller proof size. One possible split may be to only do $\log{\log{d}}$ BatchPoEs at the end. This should give you prover time that is still linear but better proof size. In practice doing BatchPoE for the last $6$ rounds should be good for almost all input sizes.
\section{$\tilde{O}(\sqrt{d})$ eval}
The PoEs are efficient and with some caching during the commitment phase we can also make the rest of the eval have $\tilde{O}(\sqrt{d})$ complexity (only group operations). The protocol is parameterized by a bound $b$ which determines the amount of preprocessing. We discuss the perfect choice for $b$ later but for intuition it helps to think of $b=d/b=\sqrt{d}$.
\subsection{Idea}
The core idea is that we can write a polynomial $f(X)$ of degree $d-1$ as the sum of $b$ polynomials $f_i(X)$ of degree less than $\frac{d}{b}$. That is $f(X)=\sum_{i=0}^b X^i f_i(X^b)$. This is a direct generalization of the odd/even split that the $\textsf{FFTEval}$ protocol uses. During the committing phase the prover computes and stores commitments to $f_i(X^b)$, i.e. $P_i\gets g^{f_i(q^b)}$. Using the $\frac{d}{b}$ precomputed group elements $g,g^{q^b},g^{q^{2b}}\dots$ all $b$ $P_i$'s can be computed using $d$ $\lambda$-bit exponentiations\footnote{Ignoring multi-exponentiation speedups for now}. Given the $P_i$'s one can compute $C=g^{f(q)}$. This is because $C=\prod_{i=0}^{b-1} P_i^{q^i}$. By computing this product left to right, i.e. $C=(((P_{b-1}^qP_{b-2})^qP_{b-3})^q \dots)P_0$ this can be done using only $b$ $\log_2(q)$-bit exponentiations.

Similarly the prover can use the $P_i$ to compute to $C_O$, i.e. the commitment to $f_O(X^2)$ where $f(X)=f_E(X^2)+Xf_O(X^2)$. Additionally computing $C_O'=g^{q f(q^2)}$ can be done efficiently given just $C_O$ as $C_O'=C_O^q$. 

After each round the protocol continues with $f'(X)=f_E(X)+\alpha f_O(X)$ as a witness and $q_{i+1}=q_{i}^2$. Similarly as in the first round we can write $f'(X)$ as the sum of $b/2$ polynomials of degree less than $\frac{d}{b}$.
$f'(X)=\sum_{i=0}^{\frac{b}{2}-1} X^i f'_i(X^{\frac{b}{2}})$. Given the commitments to the $f_i(X^b)$ we can efficiently compute commitments to $f_i'(X)=f_{2i}(X)+\alpha f_{2i+1}(X)$ as $P_i'\gets P_{2i}P_{2i+1}^{\alpha}$. This takes work at most $b$, $\lambda$-bit exponentiations. Repeating this for $\log_2(b)$ rounds we end up with a witness polynomial $f''(X)$ of degree less than $\frac{d}{b}$. Given the precomputed $g_i$ the prover can construct commitments to $f''(X)$ and finish the protocol using $\frac{d}{b}$ $\lambda$-bit exponentiations. In the first $\log_2(b)$ steps the most expensive operations is computing $C_O$ given the $P_i$'s. This takes roughly $b$ $\log_2(q)$-bit exponentiations in every round, i.e. $b\log_2(b) \log_2(q)$-bit exponentiations in total.
\subsection{Protocol}
\begin{mdframed}
$\textsf{Preprocess(b)}$:
\begin{enumerate}[nolistsep]
	\item $g_i=g^{q^{ib}}$ for $i \in [0,\frac{d}{b}-1]$
	\item Output $g_0,\dots,g_{\frac{d}{b}-1}$
\end{enumerate}
$\textsf{Commit}(f(X),b):$
\begin{enumerate}[nolistsep]
	\item $f(X)=\sum_{i=0}^{b-1} X^{i} f_i(X^{b})$ \pccomment{$\deg(f_i(X))<\frac{d}{b}$.}
	\item Let $P_i\gets g^{f_i(q^b)}$ for all $i \in [0,b-1]$\pccomment{ computed using $g_i$; Cost: $d$ $\lambda$-bit exp.}
	\item Compute $C\gets \prod_{i=0}^{b-1} P_i^{q^i}=((P_{b-1}^q P_{b-2})^q P_{b-3})^q...P_0$ \pccomment{Cost: $b$ $\log_2(q)$-bit exp.}
	\item Output $C$ and $P_{0}\dots,P_{b-1}$
\end{enumerate}
$\textsf{FFTEval}(q,C,P_0,\dots,P_{b-1},b,d;f_0(X),\dots,f_{b}(X))$
\begin{enumerate}[nolistsep]
		\item $\alpha_0=\hash(C,f_0,q,b)$ 
		\item $\pcfor i=1$ to $\log_2(b)$
		\item $\pcind[1]$ $C_{O,i}\gets\prod_{j=0}^{\frac{b}{2^i}-1} P_{2j+1}^{q^{j\cdot 2^i}}$ \pccomment{Computed using folding method, Total Cost: $b \log{b}$ $\log_2(q)$-bit exp}.
		\item \pcind[1] $C_{O,i}'=C_{O,i}^{q^{2^i}}$ \pccomment{Total cost (all iterations) $b$ $q$-bit exp, might as well do W PoE here}
		\item \pcind[1] $\alpha_i\gets \hash(\alpha_{i-1} C_{O,i})$ \pccomment{Fiat-Shamir}
		\item $\pcind[1] P_{j}=P_{2j}P_{2j+1}^{\alpha}$ for $j \in [0,\frac{b}{2^i}]$\pccomment{$b$ $\lambda$-bit exp in total}
		\item $f'(X)\gets \sum_{i=0}^{b-1} f_i(X) \prod_{j=1}^{\log_2(b)} \alpha_j^{j\text{th last bit of }i}$ \pccomment{$f_0(X)+\alpha_1 f_1(X) + \alpha_2 f_2(X)$, Cost: $d$ field ops}
		\item \pcfor $i=\log_2(b)+1$ to $\logd$
		\item \pcind[1] $f'(X)=f_E(X^2)+Xf_O(X^2)$
		\item \pcind[1] $C_{O,i}\gets g^{f_O(q^{2^i})}$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp}
		\item  \pcind[1] $C_{O,i}'\gets g^{q^{2^{i-1}} \cdot f_O(q^{2^i})}$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp using $g_i$}
		\item \pcind[1] $\alpha_i\gets\hash(C_{O,i},C_{O,i}')$
		\item \pcind[1] $f'(X)=f_E(X)+\alpha_i f_O(X)$
		\item Proof is $C_{O,1},\dots,C_{O,\logd}$ and $C_O$'s
		\item Add $f'=f'(X)$ to proof.
	\end{enumerate}
	\end{mdframed}
	For $b=\sqrt{d}$ the runtime is $O(d \logd^2)$. A value like $b=\sqrt{d/\log(d)}$ gives roughly $O(d\logd^{1.5})$. Parallelism and multi-exp techniques need to be taken into account and the optimal value is likely best determined numerically. There are limited options anyway as $b$ needs to be a power of $2$.\\ 
Step 2 in FFTEval is likely a bottleneck. Smaller q value would still help in this protocol.
\section{Security Proof}
We state a version of the RSA assumption as described by $\cite{EC:CouPetPoi17}$.
\begin{assumption}[RSA assumption,\cite{RivShaAdl78,EC:CouPetPoi17} ]
	The RSA assumption states that an efficient adversary cannot compute a random root (co-prime with the order of the group) for a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\[
    \Pr\left[\ell \cdot \gr{U} = \Generator \wedge \gcd(\ell,|\GG|)=1:
    \begin{array}{l}
         \GG,B \leftarrow \ggen(\lambda)  \\
         \Generator \sample \GG, \ell \sample [B]  \\
         \gr{U} \in \mathbb{G} \leftarrow \adv(\mathbb{G}, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
\]

\end{assumption}

\begin{assumption}[Random order assumption]
	The random order assumption states that an efficient adversary cannot compute a multiple of the order of a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\[
    \Pr\left[a\cdot \Generator =0:
    \begin{array}{l}
         \GG,B \leftarrow \ggen(\lambda)  \\
         \Generator, \sample \GG\\
         a \in \NN \leftarrow \adv(\mathbb{G},B, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
    \]
\end{assumption}
\begin{lemma}
\label{lem:roa-to-rsa}
	The RSA assumption for $\ggen$ implies the random order assumption
	\end{lemma}
\begin{proof}
	Given an efficient adversary $\adv_{\textsf{Order}}$ for the random order assumption we will construct an efficient adversary $\adv_{\textsf{RSA}}$ for the RSA assumption. On input $\GG,\Generator,\ell$ to $\adv_{\textsf{RSA}}$ we will forward $\GG,\Generator$ to $\adv_{\textsf{Order}}$. $\adv_{\textsf{Order}}$ outputs $a$ such that $a\cdot \Generator=0$ with non-negligible probability $\epsilon$. 
	We compute $a'=\frac{a}{\gcd(a,\ell)}$. Note that since $\ell$ is co-prime to the order of $\GG$ and thus also the order of $\Generator$ and $a$ is a multiple of the order of $\Generator$ we have that $a'$ is still a multiple of the order of $\Generator$. Now $\adv_{\textsf{RSA}}$ computes $w\gets \ell^{-1} \bmod a'$ and outputs $\gr{U} \gets w\cdot \Generator$. $\ell \cdot \gr{U}=\Generator$ so $\adv_{\textsf{RSA}}$ succeeds with probability $\epsilon$.
\end{proof}

\begin{definition}[GUO Polynomial Commitment]
We describe a non-hiding succinct polynomial commitment scheme for polynomials of bounded degree over $\ZZ_p$ using a group of unknown order.
\begin{itemize}
	\item $\setup(\secparam) \rightarrow \crs:$
The setup algorithm $\setup$ on input $\secparam$ and max degree $d$ and prime $p$ samples a group of unknown order $\GG$ and a $\Generator \sample \GG$ and sets $q=2^k$ for $k \in \NN$ such that $q>p\cdot 2^{\lambda \cdot \logd}$. The algorithm outputs $\crs=(\GG,\Generator,q,p,d)$.

\item $\commit(\crs, f) \rightarrow \Commitment$: The commitment algorithm $\commit$ on input $f(X)\in \ZZ_p$ lifts $f(X)$ to the integer polynomial $\hat{f}(X)$ with coefficients bounded by $p$ and outputs $\Commitment =f(q) \cdot \Generator$
%\item The open algorithm $\open$ outputs $f(X),\gr{W} \in \GG,\alpha \in \NN$
\item $\verify(\crs, f, \Commitment, \gr{W}, \alpha) \rightarrow b \in \{0,1\}$: The verification algorithm checks an opening of $\Commitment$ to the polynomial $f \in \ZZ_p$, given the opening hint $(\gr{W}, \alpha)$. It checks that $\alpha\cdot \gr{W}=0$ and that $\Commitment =f(q)\cdot \Generator +\gr{W}$
\item The evaluation protocol will be describe later.
\end{itemize}
Note that an honestly generated commitment does not require an additional opening hint as $\Commitment = f(q) \cdot \Generator$. The flexibility in the $\verify$ algorithm is solely for the security analysis of our evaluation protocol, so that the knowledge extractor is allowed to obtain a more general opening hint for the commitment. 
\end{definition}

\begin{lemma}[Binding commitment]
\label{lem:aug-com-binding}
	The commitment is binding under the random order assumption. 
\end{lemma}
\begin{proof}
	Given a commitment $C$ and two openings $f(X),w,\alpha$ and $f'(X),w',\alpha'$ with $f(X)\neq f'(X)$. $f(X),f'(X)$ have bounded coefficients so $f(q)\neq f'(q)\in \ZZ$. This implies that $(f(q)-f'(q))\cdot \Generator+w-w'=0$. 
	We cancel out the $w$ and the $w'$ term to get $\alpha\cdot \alpha'\cdot (f(q)-f'(q)) \Generator=0$. $\cdot \alpha'\cdot (f(q)-f'(q))$ is a root of $\Generator$ 
	which breaks the Random Order assumption.
	% and by \cref{lem:roa-to-rsa} also the RSA assumption.
	\end{proof}
	
	\begin{fact}[Homomorphic property]
		The GUO commitment is additively homomorphic. Given openings $(f \in \ZZ,\gr{W},\alpha \in \ZZ)$ to $\Commitment$ and $(f',\gr{W}',\alpha')$ to $\Commitment'$, the opening to $\Commitment + \Commitment'$ is $(f + f', \gr{W} + \gr{W}', lcm(\alpha, \alpha'))$.  \end{fact}
	\begin{proof}
		Given $f \in \ZZ,\gr{W} \in \GG, \alpha \in \ZZ$
	\end{proof}
	
	\begin{lemma}[PoEs]
		Protocol \textsf{BatchPoE} is an interactive proof of knowledge for the following relation:
		\[ \mathcal{R_\textsf{BPoE}} = \left\{
\big\langle \{(\gr{G}_i,\gr{G}_i')\}_{i=1}^{\numrounds}, q ; \ \{(\gr{W}_i\in \GG, a_i, d_i\in \ZZ)\}_{i=1}^k  \big\rangle
: \forall i
\begin{array}{l} 
d_i \cdot \gr{G}_i' = q^{2^{\numrounds-i}}  \cdot d_i \cdot \gr{G}_i + \gr{W}_i \\ 
a_i\cdot \gr{W}_i=0
\end{array}\right\}
\]


		%$$\mathcal{R}_{POE}=\{\langle \{(\gr{G}_i,\gr{G}_i')\}_{i=1}^{\numrounds},q ;\{(\gr{W}_i\in \GG,a_i\in \ZZ)\}_{i=1}^k \rangle: \forall i \ \gr{G}_i' = q^{2^{\numrounds-i}}  \cdot \gr{G}_i + \gr{W}_i \ \ \wedge \ \ a_i\cdot \gr{W}_i=0]_{i=1}^{\numrounds-1} \}$$
	\end{lemma}
	\begin{proof}
		We define a knowledge extractor that runs with an adversary $\adv$ who succeeds for public inputs $\{(\gr{G}_i,\gr{G}_i')\}_{i=1}^{\numrounds}$ and $q$ with probability $\epsilon = 1/\poly$. The extractor begins by using the tree-finding algorithm of Lemma~\ref{lem:forking} to generate a tree of accepting transcripts with the following characteristics: 

\begin{itemize}
\item The tree has depth $\numrounds$ and branching factor $3$. We index nodes by $v \in [0, n^{\log 3})$.
\item The root is labeled with the publics inputs. 
\item Each non-leaf node $v$ distinct from the root is labeled with a challenge $\alpha_{v}$ and a prover message $\gr{Y}_v$. 
\item Each non-leaf node $v$ has three children each labeled with three distinct verifier challenges 
$\alpha_{v,1} \neq \alpha_{v,2} \neq \alpha_{v,3}$.

\end{itemize} 

Since the verifier challenges in the protocol are sampled from $\mathcal{X} = [-2^{\lambda -1}, 2^{\lambda -1}]$, the probability of a collision over challenges $\alpha_1, \alpha_2 \sample \mathcal{X}$ sampled uniformly and independently is $2^{-\lambda}$. Thus, by Lemma~\ref{lem:forking} the tree-finding algorithm runs for $O(\poly/\epsilon)$ steps and succeeds with probability $1 - \negl/\epsilon$ to return a tree with these characteristics.

For the root node $\textsf{rt}$, define $\gr{X}_\textsf{rt} \deq \gr{G}_\numrounds$ and $\gr{Z}_\textsf{rt} \deq \gr{G}'_\numrounds$. For any non-leaf node $v$ on level $i$ with parent $w$ on level $i+1$, which has prover message $\gr{Y}_v$ and verifier challenge $\alpha_v$, define $\gr{X}_v \deq \gr{X}_w + \alpha_v \cdot \gr{Y}_w + \alpha^2 \cdot \gr{G}_{i-1}$. Similarly, define $\gr{Z}_v \deq \gr{Y}_w + \alpha \gr{Z}_w + \alpha^2 \gr{G}'_{i-1}$.

We will show that given this tree, the extractor can compute for all nodes $v \in [0, n^{\log 3})$ group elements $\gr{W}_v$ and integers $a_v$ and $d_v$ such that $a_v \cdot \gr{W}_v = 0$ and if $v$ is on the $i$th level then $d_v \cdot \gr{Z}_v = d_v \cdot q^{2^{i-1}} \cdot \gr{X}_v + \gr{W}_v$. It can also compute values $\gr{W}'_v, d'_v$ such that $a_v \cdot \gr{W}'_v = 0$ and $d'_v \cdot \gr{G}'_{i-1} = d'_v \cdot \gr{G}_{i-1} + \gr{W}'_v$. It will do this by starting at the leaves and working its way up the tree.
For any leaf node $v$, the fact that the transcript is accepting implies $q \cdot \gr{X}_v = \gr{Z}_v$. Now suppose that the appropriate values $\gr{W}_v$ have been computed for all children of a node $w$ on the $i$th level. Denoting the three children of nodes $w$ with indices $v_1, v_2, v_3$ and the three challenges on each by $\alpha_1, \alpha_2, \alpha_3$. This means that $\gr{X}_{v_j} = \gr{X}_w + \alpha_j \cdot \gr{Y}_w + \alpha_j^2 \cdot \gr{G}_{i-1}$ and $\gr{Z}_{v_j} = \gr{Y}_w + \alpha_j \cdot \gr{Z}_w + \alpha^2_j \cdot \gr{G}'_{i-1}$ for each $j \in [3]$.
Furthermore, $d_{v_j} \cdot \gr{Z}_{v_j} = d_{v_j} \cdot q^{2^{i-1}} \cdot \gr{X}_{v_j} + \gr{W}_{v_j}$ such that $a_{v_j} \cdot \gr{W}_{v_j} = 0$ and $d_{v_j} \neq 0$ for each $j \in [3]$. 

Let $\mathbf{D}$ denote the diagonal matrix with entries $d_{v_1}, d_{v_2}, d_{v_3}$. Let $\mathbf{W} = (\gr{W}_{v_1}, \gr{W}_{v_2}, \gr{W}_{v_3})$ and let $a \deq lcm(a_{v_1}, a_{v_2}, a_{v_3})$. We can summarize these relations in the following matrix equations, where $\mathbf{A} \in \mathbb{Z}^{3\times 3}$ is the integer matrix with rows $(1, \alpha_j, \alpha_j^2)$:

$$\mathbf{D} \cdot \mathbf{A}
\begin{bmatrix}
\gr{X}_w \\ 
\gr{Y}_w \\ 
\gr{G}_{i-1}
\end{bmatrix} 
= \mathbf{D} \cdot 
\begin{bmatrix}
\gr{X}_{v_1} \\ 
\gr{X}_{v_2} \\ 
\gr{X}_{v_3}
\end{bmatrix}
\ \ \text{and} \ \ 
\mathbf{D} \cdot 
\mathbf{A} \cdot 
\begin{bmatrix}
\gr{Y}_w \\ 
\gr{Z}_w \\ 
\gr{G}'_{i-1}
\end{bmatrix} 
= 
\mathbf{D} \cdot 
\begin{bmatrix}
\gr{Z}_{v_1} \\ 
\gr{Z}_{v_2} \\ 
\gr{Z}_{v_3}
\end{bmatrix} 
= 
q^{2^{i-1}} \cdot 
\mathbf{D} \cdot 
\begin{bmatrix}
\gr{X}_{v_1} \\ 
\gr{X}_{v_2} \\ 
\gr{X}_{v_3}
\end{bmatrix}
+ 
\mathbf{W}  
\ \text{and} \ \ a \cdot \mathbf{W} = 0
$$

Substituting for the column vector $(\gr{X}_{v_1}, \gr{X}_{v_2}, \gr{X}_{v_3})$ we get: 

$$ \mathbf{D} \cdot \mathbf{A} \cdot 
\begin{bmatrix}
\gr{Y}_w \\ 
\gr{Z}_w \\ 
\gr{G}'_{i-1}
\end{bmatrix} 
= 
q^{2^{i-1}} \cdot \mathbf{D} \cdot \mathbf{A} \cdot  
\begin{bmatrix}
\gr{X}_{w} \\ 
\gr{Y}_{w} \\ 
\gr{G}_{i-1}
\end{bmatrix}  \ \
+ 
\begin{bmatrix}
\gr{W}_{v_1} \\ 
\gr{W}_{v_2} \\ 
\gr{W}_{v_3}
\end{bmatrix}  \ \
$$

Since $\mathbf{A}$ is a Vandermonde matrix with distinct rows and $\mathbf{D}$ has a non-zero diagonal, $det(\mathbf{A} \cdot \mathbf{D}) \neq 0$. Therefore, by Lemma~\ref{lem:extraction}, there exists a matrix $\mathbf{P}$ such that $\mathbf{P}\cdot \mathbf{A} = \mathbf{D}'$ where $\mathbf{D}$ is a diagonal matrix with non-zero entries $d'_1, d'_2, d'_3$. This means that: 

$$  
\begin{bmatrix}
d'_1 \cdot \gr{Y}_w \\ 
d'_2 \cdot \gr{Z}_w \\ 
d'_3 \cdot \gr{G}'_{i-1}
\end{bmatrix} 
= 
q^{2^{i-1}} \cdot
\begin{bmatrix}
d'_1 \cdot \gr{X}_{w} \\ 
d'_2 \cdot \gr{Y}_{w} \\ 
d'_3 \cdot \gr{G}_{i-1}
\end{bmatrix}  \ \
+ 
\mathbf{P} \cdot 
\mathbf{W} \ \ \text{and} \ \ a \cdot \mathbf{P} \cdot \mathbf{W} = 0
$$

Finally, this implies that $d'_1 d'_2 \cdot \gr{Z}_w = q^{2^{i-1}} \cdot (d'_2 d'_1 \cdot q^{2^{i-1}} \cdot \gr{X}_w + \langle \mathbf{P}_1, \mathbf{W} \rangle) + d'_1 \cdot \langle \mathbf{P}_2, \mathbf{W} \rangle$. 
Therefore, the extractor has obtained the integer $d_w \deq d'_1 d'_2$, group element $\gr{W}_w \deq q^{2^{i-1}} \cdot \langle \mathbf{P}_1, \mathbf{W} \rangle  + d'_1 \cdot \langle \mathbf{P}_2, \mathbf{W} \rangle$, and the integer $a_w \deq a$ such that $d_w \cdot \gr{Z}_w = d_w \cdot q^{2^i} \cdot \gr{X}_w + \gr{W}_w$ such that $a_w \cdot \gr{W}_w = 0$. 
We also have the relation $d'_w \gr{G}'_{i-1} = q^{2^{i-1}} \cdot d'_w \gr{G}_{i-1} + \gr{W}'_w$ such that $a_w \cdot \gr{W}'_w = 0$, for $d'_w \deq d'_3$ and $\gr{W}'_w \deq \langle \mathbf{P}_3, \mathbf{W} \rangle$. 



%For the root node $\textsf{rt}$ define $y_{\textsf{rt}} \deq y$, where $y$ is the input. We also define a value $\g_v$ for every node $v$ as follows: if $v$ is the root then $\g_v \deq \g$, else if $v$ has a parent $w$ then $\g_v \deq \g_{w, 0} + \alpha_v \cdot \g_{w, 1}$ where $\g_w = (\g_{w,0}, \g_{w,1})$ is the concatenation of equal length vectors $\g_{w,0}, \g_{w,1}$. If $v$ is a node on the $i$th level up from the leaves then $\g_v \in \G^{2^i}$. By construction, for every root to leaf path of nodes $v_1,...,v_{\log n}$ the sequence of values $(\alpha_{v_i}, y_{v_i,0}, y_{v_i,1})$ form an accepting transcript between the prover and verifier where $(\g_{v_i}, y_{v_i})$ are the verifier's local inputs in the $i$th round. Moreover, the leaf node labels satisfy $[\![  x_v ]\!]_{\g_v} = y_v$. 

	\end{proof}

	
	
	\begin{proof}[Benedikt's sketch]
	We will prove security by constructing an extractor $E$ that given rewinding access to an adversary $A$ is able to extract a valid witness. 
The extractor works in a round by round manner using $3$ transcripts with different challenges $\alpha_j$ and $\beta_j$ $j\in\{1,2,3\}$. 
 
\begin{itemize}
	\item Read $\gr{X}_1$ and $\gr{Z}_1$ from the transcript.
	\item In each round we have $\gr{X}_i = q^i \gr{Z}_i$. We use $\approx$ to denote equality but for an additive shift of a known order element.
	\item We will show that $\gr{X}_{i+1}\approx \gr{Z}_{i+1}$
	\item Let $C= \left\{\begin{array}{lll}
		1 & \alpha_1 & \beta_1\\
		1 & \alpha_2 & \beta_2\\
		1 & \alpha_3 & \beta_3
	\end{array}\right\} $ be the challenge matrix. 
	\item We find $P$ such that $P C$ is an upper triangle matrix. If it doesn't exist then the extractor aborts.
\end{itemize}
	We will show that if $q^{2^i}\cdot \gr{X}_i \cdot \gr{W}_i=\gr{Z}_i$ and $a_i \cdot \gr{W}_i=0$ then the extractor can compute $\gr{X}_{i+1},\gr{Y}_{i+1} \gr{W}_{i+1}, a_{i+1}$ such that $X_{i+1}^q\cdot W_{i+1}=Z_{i+1}$ and $a_{i+1}\cdot \gr{W}_{i+1}=0$.  
	The extractor rewinds the prover two times per round to get responses for  
	\end{proof}
	
	Proof idea:
	\begin{itemize}
		\item  We know that $\gr{D}_1^q=\gr{D}_1'$, $\gr{X}_1^q=\gr{Y}_1$ and $\gr{Y}_1^q=\gr{Z}_1$.
		\item Rewind the prover to get three challenge pairs $\alpha$ and $\beta$ per round.
		\item $q\cdot (\gr{X}_{i+1} +\alpha \gr{Y}_{i+1} +\beta \gr{D}_{i}')= \gr{Y}_{i} +\alpha \gr{Z}_{i} +\beta \gr{D}_{i}$
		\item Use a linear combination of $[(1,\alpha_i,\beta_i)]_{i=1}^3$ (likely full rank). 
		\item This shows that $\gr{X}_{i+1}= \gr{Y}_{i}$ and ...
	\end{itemize}
\subsection{Strong RSA to RSA assumption}
\begin{itemize}
\item CRS $\gr{G} \in \GG$
	\item Prover sends $\gr{C}_1,\gr{C}_2$
	\item 
Verifier sends $\alpha \in [0,2^\lambda]$
\item Prover sends $f' \in \ZZ, \gr{w}\in \GG, \rho \in \ZZ$
\item Verifier checks that $f' \cdot \gr{G}+\gr{w} =\alpha \cdot \gr{C}_1 +\gr{C}_2$ and $\gr{w}^\rho=1$
\end{itemize}
Run the protocol 3 times to compute $\Delta\alpha_1$, $\Delta\alpha_2$ and $\Delta f_1$ and $\Delta f_2$.
Let $f'_1\gets \frac{\Delta f_1}{\gcd(\Delta \alpha_1,\Delta f_1)}$ ,$\alpha'_1\gets \frac{\Delta \alpha_1}{\gcd(\Delta \alpha_1,\Delta f_1)}$ denote the reduced fractions. For an adversary with success probability $\epsilon$ either $f'_1\leq 8/\epsilon$ or $f'_1 >8/\epsilon$ with non negligible probability ($\approx\epsilon^2$). 
\paragraph{$f'_1$ is small.}
In that case we can compute 
\section{Other ideas (WIP)}
\subsection{No field elements eval}


\begin{mdframed}
Public Input: $C\in \GG,z\in \ZZ_p,y\in \ZZ_p$\\
Witness: $f(X) \in \ZZ_p[X]$ \\
Claim: $C=\commit(f(X))$, $\deg(f(X))<d$ and $f(z)=y \bmod p$
	\begin{enumerate}[nolistsep]
		\item $\prover$ computes $q(X) \in \ZZ_p[X]=f(X)//(X-z) \bmod p$ and $Q\gets\commit(q(X))$
		\item \prover sends $Q$ to $\verifier$.
		\item $\prover$ and $\verifier$ compute $D\gets C/(Q^{(q-z)}g^y)$ \pccomment{$D$ commits to $h(X)=f(X)-q(X)(X-z)-y\equiv 0\bmod p$.}

		\item \prover and \verifier run $\textsf{DegreeProof}(D,Q^q,d;h(X),q(X)\cdot X)$
	\end{enumerate}
\end{mdframed}

Assume $d+1$ is a power of $2$
\begin{mdframed}
\begin{minipage}{\textwidth}
			$\pro{DegreeProof}(\crs, \gr{C},\gr{Q}\in \GG, d \in \NN; h(X),q(X)\in \ZZ_p[X]) :$ \pccomment{$\tilde{f}(X) = \sum_{i=0}^d \tilde{f}_i X^i$}
			\begin{enumerate}[nolistsep]
					\item \verifier samples challenge $\alpha$ 
			\item $\gr{C}'\gets \gr{C}^{\alpha}Q$
			\item \prover and \verifier run $\pro{DegreeProofBounded}(\params,q,\gr{C}',d,p\cdot 2^\lambda;\alpha \cdot h(X)+f(X))$
        \item \ \verifier checks that $b\cdot \boldsymbol{\varsigma}_{p,d} < q$\pccomment{$\boldsymbol{\varsigma}_{p,d}=O(p^{2\log(d)})$ (see Theorem~\ref{thm:polycommitsecurity} and \ref{thm:dyadicpolysecurity})}
        %q/(2^{\lceil \log_2(d+1) \rceil+1} p^{2 \lceil \log_2(d+1) \rceil+1})$
        \item \pcind[1] \verifier checks that $|h|\leq b$ and 
          \item \pcind[1] \verifier checks that $f\equiv 0 \bmod p$
                \item \label{line:baseend}\pcind[1] \verifier checks that $\Generator^{\alpha h}=\gr{C}$
\item \pcind[1] \verifier outputs $1$ \pcif all checks pass, $0$ otherwise.
		    \end{enumerate}
		    		\vspace{1em}
		$\pro{EvalBounded}(\crs,q,\gr{C}'\in \GG,d\in \NN,b\in \ZZ;\alpha h(X),f(X)\in \ZZ(b)[X])$		
	    \begin{enumerate}[nolistsep]
        \item \pcif $d=0$:
        \item \label{line:basestart}\pcind[1] \pcreturn $\gr{C}$ to $\prover$ and $\verifier$ and $\alpha h(X), f(X)$ \pccomment{$\alpha h(X)$ and $f(X)$ are constants}

        
        \item \pcelse: \pccomment{$d \geq 1$ and $d+1$ is even}
       
        \item \pcind[1] \prover and \verifier compute $d' \gets \lfloor\frac{d}{2}\rfloor$
        \item \pcind[1] \prover computes $f_E(X) \gets \sum\limits_{i=0}^{d'} f_{2\cdot i} \cdot X^i$ and $f_O(X)\gets\sum\limits_{i=0}^{d'} f_{2\cdot i 1}\cdot X^{i}$
        \item \pcind[1] \prover computes $\gr{C}_E \gets \Generator^{f_L(q^2)}$ and $\gr{C}_O \gets \Generator^{f_R(q^2)}$
        \item \pcind[1] \prover sends $\gr{C}_E, \gr{C}_O$ to \verifier. \pccomment{See Section \ref{subsec:optimization} for an optimization}
        \item \pcind[1] \label{line:PoE} \prover and \verifier run $\pro{PoE}(\gr{C}_E, \gr{C}/\gr{C}_O, q)$\pccomment{Showing that $\gr{C}_E\gr{C}_O^{q}=\gr{C}$}
        \item \pcind[1] \verifier samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to \prover
        \item \pcind[1] \prover and \verifier compute $\gr{C}' \gets \gr{C}_E^\alpha  \gr{C}_O$, $b'\gets b \cdot 2^{\lambda}$. 
        \item \pcind[1] \prover computes $f'(X) \gets \alpha \cdot f_E(X) + f_O(X) \in \ZZ[X]$  and\\
        \pcind[1] $h'(X)=\alpha h_E(X) + h_O(X)$\pccomment{$\deg(f'(X))=\deg(h'(X))=d'$}
        \item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}',q^2, d',b' ; \alpha f'(X))$
               \end{enumerate}
      \end{minipage}
\end{mdframed}


\section{Ben's lemmas}

Let $\G$ denote the abelian group (i.e., $\G$ is a $\Z$-module) that contains the space of commitments for the PCS. We first prove an elementary linear algebraic fact. 

\begin{lemma}\label{lem:triangularization}
Let $\G$ be a $\Z$-module. Let $p$ be a prime and $\F = \Z_p$. Given two vectors $\x, \y \in \G^n$ and a system of equations $\mathbf{A} \x = \y$ for a matrix $\A \in \Z^{n \times n}$ that is invertible over $\F$, 
there is an efficient algorithm to derive a diagonal matrix $\mathbf{D}$ with diagonal entries  $(d_1,...,d_n) \in \Z^n$, where $d_i \neq 0 \bmod p$ for all $i$, and a matrix $\mathbf{L}$ such that $\mathbf{D} \cdot \x = \mathbf{L} \cdot \y$. In particular, $\mathbf{L} \mathbf{A} = \mathbf{D}$.    
\end{lemma} 
\begin{proof} 
Since $det(\mathbf{A}) \neq 0 \bmod p$, by Gaussian elimination there is a triangularization matrix $\mathbf{P}$ such that $\mathbf{P} \mathbf{A} = \mathbf{T}$ is lower triangular with a diagonal of integer values that are non-zero over $\F$ (i.e., it is in reduced row-echelon form). 
Since $\mathbf{P} \mathbf{A} \cdot \x = \mathbf{T} \cdot \y= \mathbf{P}\cdot \y$, there exists an integer $d_1$ (i.e., upper left entry of $\mathbf{T}$) such that $d_1 \cdot x_1 =\langle \mathbf{P}_1, \y \rangle$, where $\mathbf{P}_1$ is the first row of $\mathbf{P}$. Denote by $\x^{(i)}$ the vector that swaps the 1st and $i$th coordinates of $\x$. Denote by $\A^{(i)}$ the matrix that results from swapping the first and $i$th columns of $\A$. We have $\A^{(i)} \x^{(i)} = \y$. 
 For each $i \in [n]$, repeat the triangularization process on $\A^{(i)}$ to get $\mathbf{P}^{(i)}$ such that $\mathbf{P}^{(i)} \cdot \A^{(i)} = \mathbf{T}^{(i)}$ is lower triangular. The upper left entry of $\mathbf{T}^{(i)}$ is an integer $d_i \neq 0 \bmod p$, and $d_i \cdot x_i = \langle \mathbf{P}^{(i)}_1, \y \rangle$.
  Return the matrix $D$ with diagonal entries $d_1,...,d_n$ and the matrix $L$ with row vectors $\mathbf{P}^{(i)}_1$ for $i \in [n]$. 
\end{proof} 

The next lemma is a direct result of this fact. 

\begin{lemma}\label{lem:extraction}
Given two vectors of commitments $\mathbf{C}, \mathbf{C^*} \in \G^n$, a system of equations $\mathbf{A} \mathbf{C} = \mathbf{C^*}$ for an integer matrix $\mathbf{A} \in \Z^{n \times n}$ that is invertible over $\F_p$, and a vector of openings of $\mathbf{C^*}$ to a vector of polynomials $\mathbf{f^*} = (f_1^*,...,f_n^*) \in (\FF)^n$, there is an efficient algorithm to derive polynomials $\mathbf{f} = (f_1,...,f_n) \in (\FF)^n$, integer vector $\mathbf{t} \in \Z^n$ such that $t_i \neq 0 \bmod p$, and openings for each $t_i \cdot \mathbf{C}_i$ to the polynomial $t_i \cdot f_i \bmod p$ such that $\mathbf{A} \cdot \mathbf{f} = \mathbf{f^*} \bmod p$. 
\end{lemma} 
\begin{proof} 
By Lemma~\ref{lem:triangularization}, there exists a diagonal matrix $\mathbf{T}$ with integer entries $t_1,...,t_n \neq 0 \bmod p$ and a matrix $\mathbf{L}$ such that $\mathbf{T} \cdot \mathbf{C} = \mathbf{L} \cdot \mathbf{C}^*$ and $\mathbf{L} \cdot \mathbf{A} = \mathbf{T}$. 
  From each linear combination of $\mathbf{C^*}$, we use $\add^*$ to derive an opening of $t_i \cdot \mathbf{C}_i$ to a polynomial $g_i = \langle \mathbf{L}_i, \mathbf{f^*} \rangle \in \FX$.
   Let $\mathbf{g} = (g_1,...,g_n)$. Finally, solve for the vector of polynomials $\mathbf{f}$ such that $\mathbf{A} \cdot \mathbf{f} = \mathbf{f^*}$ by computing $\mathbf{A}^{-1} \bmod p$. Note that $\mathbf{L} \cdot \mathbf{A} \cdot \mathbf{f} = \mathbf{T} \cdot \mathbf{f} = \mathbf{L} \cdot \mathbf{f}^*$ where $\mathbf{T}$ is a diagonal matrix with entries $t_i \neq 0 \bmod p$. Thus, $t_i f_i = g_i$, for which we have a valid opening of $t_i \cdot \mathbf{C}_i$.   
\end{proof}

\begin{lemma}[Forking Lemma]\label{lem:forking}
Let $(\prover, \verifier)$ be an $r$-round public-coin interactive proof system and $\mathcal{A}$ an adversary such that $\langle \mathcal{A}(\pp, x), \verifier(\pp, x) \rangle = 1$ with probability $\epsilon > \negl(\lambda)$ on public input $x$ and public parameters $\pp$.  Let $\{\pi_i\}_{i =1}^r$ be a set of properties $\pi_i: \mathcal{X}^2 \rightarrow \{0,1\}$ such that $\forall_{i} \ Pr[ \pi(x_1, x_2) = 1: x_1, x_2 \sample \mathcal{X}] > 1 - \negl(\lambda)$. There exists an algorithm $\mathcal{T}$ that runs in time $O(\lambda/\epsilon)$ and outputs an $(n_1,...,n_r)$-tree of accepting transcripts such that with probability $\Omega(1 - \frac{r \cdot\negl(\lambda)}{\epsilon})$ in each $i$th level of the tree every pair of sibling-node challenges $x_1, x_2$ satisfy $\pi_i(x_1, x_2) = 1$. 
\end{lemma} 


 \bibliographystyle{alpha}
 \bibliography{../cryptobib/abbrev3,../cryptobib/crypto,cryptobib/additional}
\end{document}
