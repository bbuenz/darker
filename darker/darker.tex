\documentclass[10pt,conference]{IEEEtran} 
\pagestyle{plain} 
\usepackage[operators,lambda,keys,sets,primitives,adversary,asymptotics,advantage]{cryptocode}
\usepackage{notations}
%\usepackage{bm}
\usepackage{comment}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage{amsthm}
\usepackage{amsmath,amssymb}
\usepackage[utf8x]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{xspace}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{cleveref}
%\usepackage{authblk}
%\usepackage{draftwatermark}
\usepackage[legalpaper, margin=1in]{geometry}
\usepackage{comment}
\usepackage{todonotes}
\theoremstyle{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{fact}{Fact}

\newif\ifcomments
\commentstrue
\ifcomments
	\newcommand{\ben}[1]{{\textcolor{red}{[\bf Ben: #1]}}}
	\newcommand{\benedikt}[1]{{\textcolor{blue}{[\bf Benedikt: #1]}}}
	\newcommand{\alan}[1]{{\textcolor{green!50!black}{[ \bg Alan: #1]}}}
\else
	\newcommand{\ben}[1]{}
	
\fi

\newcommand{\dollar}{\$}
\newcommand{\random}{\xleftarrow{\dollar}}

\title{Darker}

\begin{document}
	
\maketitle
\section{Introduction}
SNARKs typically require strong trust assumptions. Fortunately, recent results show how to avoid the trusted setup ceremony and eliminate the resulting cryptographic toxic waste altogether. The solution consists of two steps: First, the cryptographic hardness assumptions and trust assumptions are restricted to the generation of a polynomial commitment scheme, from which the remainder of the SNARK is constructed. Second, the polynomial commitment scheme is instantiated with mathematical tools that do not require trust assumptions in order to make a compelling argument for security. The result is a \emph{transparent} SNARK.

Groups of unknown order constitute one of the branches of mathematics that admit polynomial commitment schemes, along with a variety of protocols called \emph{Diophantine Arguments of Knowledge (DARKs)}. When the scheme is instantiated with a transparent group of unknown order, \emph{i.e.}, one that requires no trusted setup, the resulting polynomial commitment scheme is likewise transparent --- and the same property holds for the SNARK derived from it.

While SNARKs for general-purpose computations are capable of proving satisfiability of arbitrary arithmetic circuits, for typical applications the circuits are \emph{sparse}: most gates are not connected to most other gates, but only to a select subset of them. As a result, after casting the circuit satisfaction problem into the language of polynomial algebra, the polynomials that represent the computation are typically sparse as well: only a small fraction of its coefficients are zero. This sparsity presents an engineering challenge. The performance cost rises with the polynomials' degrees, but the information they encode only rises with the number of nonzero coefficients. As a result, the key question is how to deal with sparse high-degree polynomials efficiently.

This paper takes another look at DARK polynomial commitment schemes, following in the footsteps of the scheme proposed by Supersonic~\cite{BFS20}. We report several results in this context, on several fronts.

\begin{itemize}
\item[1.] We present a new set of DARK protocols --- one for preprocessing, one for committing to a polynomial, and one for evaluating it. The key distinguishing feature of the new commitment algorithm is that it produces two outputs: one is the commitment itself, to be sent to the verifier; and the other is a secret cache consisting of group elements. By relying on this secret helper input, the complexity of the evaluation protocol drops from $O(d \cdot \log d)$ to $\tilde{O}(\sqrt{d} + s)$, where $d$ is the degree of the polynomial. After obtaining the common reference string (whether uniform or structured) from the preprocessing phase, the complexity of the commitment algorithm is likewise $\tilde{O}(\sqrt{d} + s)$.

\item[2.] We prove the security of these protocols in the random oracle model under the Strong RSA Assumption alone. The previous DARK scheme was only provably secure in the random oracle model when assuming both the Strong RSA Assumption and the Adaptive Root Assumption. Importantly, this assumption is only necessary for the security of the commitment scheme. The interactive evaluation protocol has unconditional security, although after the Fiat-Shamir transform is applied to make it non-interactive, this security is again computational.

\item[3.] We report on a python implementation of these protocols, complete with performance statistics. We comment on various implementation aspects and optimizations, and even take the opportunity to compare the performance of various groups of unknown order: the multiplicative group of integers modulo an RSA modulus, ideal or form class groups, and hyperelliptic Jacobian groups.

%\item[4.] We discuss a few extensions and applications of these new and improved protocols, such as batching evaluation proofs, committing to polynomials in point-value representation, and applications to vector commitments.
\end{itemize}

\section{Technical Overview}

Our new algorithms introduce three distinct ideas.
\begin{itemize}
\item[1.] Mix even-odd split with left-right split. This combination reduces the total number of bits in the exponent and thus the number of group operations the prover needs to compute.
\item[2.] Batching with Pietrzak $\mathsf{PoE}$. By switching from Wesolowski's $\mathsf{PoE}$ to Pietrzak's $\mathsf{PoE}$, we can merge all $\mathsf{PoE}$s into one for free. Additionally, the security guarantee becomes stronger.
\item[3.] Caching during commitment. The commitment algorithm also outputs secret cache, which allows the prover to produce evaluation proofs in much less work.
\end{itemize}
We discuss each item separately before presenting the protocols that incorporate all these changes formally.

\subsection{Replace Left-Right Split with Even-Odd Split}
The original DARK polynomial evaluation protocol relies on an interactive random self-reduction derived from splitting the working polynomial $f(X)$ into a left and a right half, $f_L(X)$ and $f_R(X)$ such that $f(X) = f_L(X) + X^{d'} \cdot f_R(X)$. After receiving commitments to both halves, the verifier supplies a random scalar $\alpha$ and the protocol repeats the process recursively using $f'(X) = f_L(X) + \alpha \cdot f_R(X)$ as the new working polynomial. The new protocol opts instead for a split in terms of even and odd powers of $X$: $f(X) = f_E(X^2) + Xf_O(X^2)$, similar to the Fast Fourier Transform.

The verifier has to verify that the two commitments he receives match the commitment to the working polynomial that he already possesses. To achieve this goal, the Kronecker substitution is used: the polynomial $f(X) \in \mathbb{F}_p[X]$ is lifted to the integers $\hat{f}(X) \in \mathbb{Z}[X]$ and then evaluated in a number $q \gg p$ that is large enough to guarantee that overflow will never be a factor. The commitment to the polynomial $f(X)$ is then given by $\mathsf{C} = \hat{f}(q) \cdot \mathsf{g}$, where $\mathsf{g}$ is a designated element of the group and the group is denoted additively. In the left-right split, the verifier checks that $\mathsf{C} = \mathsf{C}_L + q^{d'} \cdot \mathsf{C}_R$. The parameter $q$ is static, but $d'$ shrinks with each round. The expensive exponentiation\footnote{Since we denote the group additively, the correct term might be ``multiplication'' or ``scalar multiplication''. However, we use the term ``exponentiation'' and ``exponent'' for compatibility with prior terminology --- for instance, ``proofs of correct exponentiation''.} can be outsourced to the prover with a proof of correct exponentiation ($\mathsf{PoE}$), which is cheap to verify. So in every round, the prover sends a tuple $(\mathsf{C}_R, q^{d'} \cdot \mathsf{C}_R)$, and needs to establish their correct relation with a $\mathsf{PoE}$.

The situation changes slightly for the even-odd split. First, the parameter $q$ changes each round; in the next round it is the square of its value the round before. Second, the prover now needs to transmit a tuple $(\mathsf{C}_O, q \cdot \mathsf{C}_O)$ in every round, and establish their correct relation using a $\mathsf{PoE}$. Note that the exponent shrinks in the left-right protocol, but grows in the even-odd protocol. In order to minimize the total number of bits in the exponents, the optimal strategy is to benefit from both worlds: start with the even-odd protocol, then switch to the left-right protocol. However, the performance improvements resulting from cached partial commitments requires an even-odd split throughout.

\subsection{Batching with Pietrzak's Proof of Exponentiation}
The shortest proof results from applying Wesolowski's batched $\mathsf{PoE}$~\cite{Wesolowski19} to all $\mathsf{PoE}$-relations at once. However, it is possible to forego the Adaptive Root Assumption by opting instead for Pietrzak's $\mathsf{PoE}$~\cite{Pietrzak19a}, in which case only one such $\mathsf{PoE}$ is needed.

Pietrzak's $\mathsf{PoE}$ establishes that $\mathsf{C} = e \cdot \mathsf{A}$ with an interative random self-reduction, where $e$ is a power of two. The prover sends $\mathsf{B} = \sqrt{e} \cdot \mathsf{A}$. The verifier sends a random scalar $\alpha$ and the protocol proceeds to the next step of the recursion to show that $\alpha \cdot \mathsf{B} + \mathsf{C} = \sqrt{e} \cdot (\alpha \cdot \mathsf{A} + \mathsf{B})$.

The sequence of exponents arising from one run of the Pietrzak protocol is exactly the same as the sequence of exponents arising from one run of the evaluation protocol, regardless of which split is used. This observation suggests the following strategy: start with the largest $\mathsf{PoE}$ relation to be proved and run one round of the Pietrzak protocol. Now combine the working commitments of the Pietrzak protocol with the second-largest $\mathsf{PoE}$ relation of the $\mathsf{Eval}$, using a random coefficient supplied by the verifier. Proceed with the next round of the Pietrzak protocol, and so on. Figure~\ref{figure:batch-pietrzak} depicts one round of this adapted protocol.

\begin{figure}[!htp]
\centering
\begin{tikzpicture}
\node[anchor=west] (working claim text) at (0,0) {working $\mathsf{PoE}$-relation:};
\node[anchor=west] (working claim) at (5, 0) {$(\mathsf{A}, e \cdot \mathsf{A})$};
\node[anchor=west] (split small) at (5.5, -0.5) {$(\mathsf{A}, \sqrt{e} \cdot \mathsf{A})$};
\node[anchor=west] (split large) at (5.5, -1) {$(\sqrt{e}\cdot \mathsf{A}, e \cdot \mathsf{A})$};
\node[anchor=west] (from eval text) at (0, -1.5) {$\mathsf{PoE}$-relation from $\mathsf{Eval}$:};
\node[anchor=west] (from eval) at (5.5, -1.5) {$(\mathsf{C}, \sqrt{e} \cdot \mathsf{C})$};
\node[anchor=west] (random linear combo text) at (0, -2.25) {random linear combination:};
\node[anchor=west] (random linear combo) at (5.5, -2.25) {$(\mathsf{B}, \sqrt{e} \cdot \mathsf{B})$};
\draw[-] (5.5, -1.875) -- (8, -1.875) {};
\node[anchor=north west] (is new working poe relation) at (random linear combo text.south west) {(= new working $\mathsf{PoE}$-relation)};
\draw[->] (5.25, -0.25) -- (5.25, -0.75) -- (5.5, -0.5) {};
\draw[->] (5.25, -0.75) -- (5.5, -1) {};
\draw[->, transform canvas={xshift=0.5cm, yshift=-2.25cm}] (5.25, -0.25) -- (5.25, -0.75) -- (5.5, -0.5) {};
\draw[->, transform canvas={xshift=0.5cm, yshift=-2.25cm}] (5.25, -0.75) -- (5.5, -1) {};
\draw[dashed] (6.25, -3.25) -- (6.5, -3.75) {};
\end{tikzpicture}
\caption{One round of the Pietrzak batch $\mathsf{PoE}$}
\label{figure:batch-pietrzak}
\end{figure}

\subsection{Caching during Commitment}

The key to achieving $\sqrt{d}$ complexity in the evaluation protocol is to produce an additional output in the commitment phase. This second output is not transmitted to the verifier; instead it is an additional secret input for the prover during the evaluation phase.

Let $b$ be a parameter that determines the amount of preprocessing and whose value is a power of two. We discuss the optimal choice for $b$ later but for intuition it helps to think of $b \approx d/b \approx \sqrt{d}$. In the preprocessing phase, the values $\mathsf{G}_i = q^{ib} \cdot \mathsf{G}$ are computed for $i \in \{0, \ldots, \lceil\frac{d}{b} \rceil - 1\}$, where $\mathsf{G} \in \mathbb{G}$ is the designated base element of the group of unknown order. The common reference string consists of $(\mathsf{G} = \mathsf{G}_0, \mathsf{G}_1, \ldots, \mathsf{G}_{\lceil\frac{d}{b}\rceil - 1})$.

The key idea is to generalize the even-odd split to a $b$-wise split. Specifically, the polynomial $f(X)$ is split as
\begin{equation}
f(X) = \sum_{i=0}^{b-1} X^i f_i(X^b)
\end{equation}
such that for all $i \in \{0,\ldots,b-1\} : \textnormal{deg}(f_i) \leq \frac{d}{b} \enspace .$

In the commitment phase, the prover stores commitments to these polynomial parts --- specifically $\mathsf{P}_i = \hat{f_i}(q^b) \cdot \mathsf{G}$ for $i \in \{0, \ldots, b-1\}$. The prover can compute all $b$ cached commitments from the common reference string and only $s$ exponentiations of $1+\lfloor\log_2 p\rfloor$ bits, where $s \leq d$ is the number of nonzero coefficients in $f(X)$. In fact, the total number of bits in the exponent can be even less if the prover uses multi-exponentiation techniques, but we ignore those for the time being. The actual commitment $\mathsf{C}$ to the polynomial $f(X)$ is best computed backwards from $\mathsf{C}_{b-1} = \mathsf{P}_{b-1}$ using the folding recursion rule $\mathsf{C}_{i} = \mathsf{P}_i + q \cdot \mathsf{C}_{i+1}$, with $\mathsf{C} = \mathsf{C}_0$. This strategy requires another $b$ exponentiations of $1 + \lfloor \log_2 q \rfloor$ bits.

Since $b$ is a power of two, the exact same strategy can be used in the evaluation protocol to compute $\mathsf{C}_O$, the commitment to $f_O(X) = \frac{f(X) - f(-X)}{2}$, the odd part of the even-odd split. With respect to the commitments $q^{2^i} \cdot \mathsf{C}_O$, the situation is more subtle. In the first $\log_2 b$ rounds, these commitments can be computed from $\mathsf{C}_O$ because the exponents are relatively small. In the other half of the rounds, the polynomial$f_O(X)$ has at most $d/b$ nonzero coefficients, and $q^{2^i} \cdot \mathsf{C}_O$ can be computed from the common reference string elements $\mathsf{G}_i$ and roughly $\frac{d}{b} \cdot \log p$ exponent bits.

\section{Protocols}

The protocols and algorithms are presented below. We use additive notation for the groups and denote the identity element by 0. In argument lists and return values, we use the semicolon to distinguish public values (on the left) from secret ones (on the right). All algorithms have access to the (implicit) public parameters $(\mathbb{G}, \mathsf{G}, d)$ and without loss of generality the degree $d$ of the polynomial $f(X)$ is one less than a power of two. The function $\mathsf{lift} : \mathbb{F}_p[X] \rightarrow \mathbb{Z}[X]$ lifts a polynomial defined over a field to its canonical representative over the integers, with coefficients from $\mathbb{F}_p$ being represented by the range $\mathbb{Z}(\frac{p-1}{2}) = \{-\frac{p-1}{2}, \ldots, \frac{p-1}{2}\}$. The function $\mathsf{terms} : \mathbb{Z}[X] \rightarrow (\mathbb{Z}[X])^*$ takes a (sparse) polynomial and returns a list of its nonzero terms: $\mathsf{terms}(\sum_{i=0}^{s-1} c_i \cdot X^{e_i}) = (c_i \cdot X^{e_i})_{i=0}^{s-1}$ if all $c_i \neq 0$.

One of the reasons for our algorithms' good performance is the clever use of multi-exponentiation techniques, where a single group element is computed from a list of disparate terms and coefficients.
For notational and comprehensive convenience, we factor out these multi-exponentiation steps into a separate procedure. Concretely, we use the following procedure to compute a single multi-exponentiation. When two subsequent invocations have identical loops and loop indices, a single loop is implied rather than two.
\begin{mdframed}
$\mathsf{MultiExp}(\{(c_i, \mathsf{G}_i)\}_{i=0}^{t-1})$ \textbf{:}
\begin{enumerate}[nolistsep]
\item $\mathsf{H} \gets 0$
\item \textbf{for} $i$ \textbf{from} $0$ \textbf{to} $t-1$ \textbf{:}
\item \pcind $\mathsf{H} \gets \mathsf{H} + c_i \cdot \mathsf{G}_i$
\item \textbf{return} $\mathsf{H}$
\end{enumerate}
\end{mdframed}

Another recurring procedure worth factoring out captures the recursive folding rule described earlier. While the output is again a single group element, the input is different: it consists of a list of group elements and a single coefficient. Furthermore, this procedure is inherently sequential because the coefficient is applied to the accumulator variable and not the various group elements in the argument.
\begin{mdframed}
$\mathsf{Fold}(c, (\mathsf{G}_i)_{i=0}^{t-1})$ \textbf{:}
\begin{enumerate}[nolistsep]
\item $\mathsf{H} \gets \mathsf{G}_0$
\item \textbf{for} $i$ \textbf{from} $0$ \textbf{to} $t-1$ \textbf{:}
\item \pcind $\mathsf{H} \gets c \cdot \mathsf{H} + \mathsf{G}_i$
\item \textbf{return} $\mathsf{H}$
\end{enumerate}
\end{mdframed}

\begin{mdframed}
$\mathsf{Preprocess}()$\textbf{:}
\begin{enumerate}[nolistsep]
	\item $\mathsf{G}_0 \gets \mathsf{G}$
	\item \textbf{for} $i$ \textbf{from} $1$ \textbf{to} $\frac{d+1}{b}$ \textbf{:}
	\item \pcind $\mathsf{G}_i \gets q^{b} \cdot \mathsf{G}_{i-1}$
	\item \textbf{return} $\left(\mathsf{G}_i\right)_{i=0}^{\frac{d+1}{b} - 1}$
\end{enumerate}
\end{mdframed}

\begin{mdframed}
$\mathsf{Commit}(\left(\mathsf{G}_i\right)_{i=0}^{\frac{d+1}{b} - 1}, b; f(X) \in \mathbb{F}_p[X])$ \textbf{:}
\begin{enumerate}[nolistsep]
	\item $f_0, \ldots, f_{b-1} \gets \mathsf{split}(f(X))$ such that $f(X) = \sum_{i=0}^{b-1} X^i f_i(X^b)$ and $\deg(f_i) < \frac{d+1}{b}$
	\item \textbf{for} $i$ \textbf{from} $0$ \textbf{to} $b-1$ \textbf{:}
	%\item \pcind $\mathsf{P}_i \gets 0$
	%\item \pcind \textbf{for each} nonzero term $\hat{h_j} X^{j}$ of $\mathsf{lift}(f_i(X^b))$ \textbf{:}
	%\item \pcind \pcind $\mathsf{P}_i \gets \mathsf{P}_i + \hat{h_j} \cdot \mathsf{G}_{\lfloor j / b \rfloor}$ \label{line:commit-coefficient}
	\item \pcind $\mathsf{P}_i \gets \mathsf{MultiExp}(\{(\hat{h}_j, \mathsf{G}_{\lfloor j/b \rfloor}) \, | \, \hat{h}_jX^j \in \mathsf{terms}(\mathsf{lift}(f_i(X^b)))\})$ \label{line:commit-coefficient}
	%\item $\mathsf{C} \gets \mathsf{P}_{b-1}$
	%\item \textbf{for} $i$ \textbf{from} $b-2$ \textbf{down to} $0$ \textbf{:}
	%\item \pcind $\mathsf{C} \gets \mathsf{P}_{i} + q \cdot \mathsf{C}$ \label{line:commit-shift}
	\item $\mathsf{C} \gets \mathsf{Fold}(q, (\mathsf{P}_{b-1-i})_{i=0}^{b-1})$ \label{line:commit-shift}
	\item \textbf{return} $(\mathsf{C}; \left(\mathsf{P}_i\right)_{i=0}^{b-1})$
\end{enumerate}
\end{mdframed}

We can now present the evaluation protocol in several functional parts.

First, the interactive protocol is split into two parts. The first part, $\mathsf{Eval}$, establishes that the evaluation of the committed polynomial in a vector of points $\mathbf{z} \in \mathbb{F}_p^t$ equals another vector $\mathbf{y} \in \mathbb{F}_p^t$. The second part, $\mathsf{BatchPoE}$, is establishes that the $\mathsf{PoE}$-relations arising from the first are valid.

Second, both protocols are presented in non-interactive form as the result of the Fiat-Shamir transform. Concretely, the random challenges from the verifier are now determined by the hash of all prior protocol messages up until that point. We omit the details in the pseudocode and write $\alpha \random \mathsf{H}(\cdots)$ or $\alpha, \beta \in \mathsf{H}(\cdots)$. Note that all $\alpha, \beta \in \mathbb{Z}(2^{\lambda-1}) = \{-2^{\lambda-1}, \ldots, 2^{\lambda-1}-1\}$. This transformation gives rise to a prover and a verifier for both parts.

\begin{mdframed}
$\mathsf{Eval.Prove}(\mathsf{C}, \mathbf{z}, \mathbf{y}; f(X), (f_i(X))_{i=0}^{b-1}), \left(\mathsf{P}_i\right)_{i=0}^{b-1})$ \textbf{:}
\begin{enumerate}[nolistsep]
	%\item $\pi_{\mathsf{Eval}} \gets \varnothing$
	\item \textbf{for} $i$ \textbf{from} $0$ \textbf{to} $\lfloor\log_2 d \rfloor$ \textbf{:}
	\item \pcind $\hat{f}_E \gets \frac{\hat{f}(X) + \hat{f}(-X)}{2}$ and $\hat{f}_O^{(i)} \gets \hat{f}(X) - \hat{f}_E(X)$
	\item \pcind $\mathbf{y}_O^{(i)} \gets \hat{f}_O^{(i)}(\mathbf{z})$
	\item \pcind \textbf{if} $i < \log_2 b$ \textbf{:}
	%\item \pcind \pcind $\mathsf{C}_O^{(i)} \gets \mathsf{P}_{b-1}$
	%\item \pcind \pcind \textbf{for} $j$ \textbf{from} $0$ \textbf{to} $b/2^i-1$ \textbf{:}
	%\item \pcind \pcind \pcind $\mathsf{C}_O^{(i)} \gets \mathsf{P}_{b-1-2j} + q^{2^i} \cdot \mathsf{C}_O^{(i)}$ \label{line:evalprove-firsthalf-bigstep}
	\item \pcind \pcind $\mathsf{C}_O^{(i)} \gets \mathsf{Fold}(q^{2^{i}}, (\mathsf{P}_{b/2^i-1-2j})_{j=0}^{b/2^{i+1}-1})$ \label{line:evalprove-firsthalf-bigstep}
	\item \pcind \pcind $\mathsf{C}_O^{\prime(i)} \gets q \cdot \mathsf{C}_O^{(i)}$ \label{line:evalprove-firsthalf-shift}
	\item \pcind \textbf{else:}
	%\item \pcind \pcind $\mathsf{C}_O^{(i)} \gets 0$ and $\mathsf{C}_O^{\prime(i)} \gets 0$
	%\item \pcind \pcind \textbf{for all} nonzero terms $\hat{h}_jX^j$ of $\hat{f}_O^{(i)}(X^{2^i})$ \textbf{:}
	%\item \pcind \pcind \pcind $\mathsf{C}_O^{(i)} \gets \mathsf{C}_O^{(i)} + \hat{h}_j \cdot \mathsf{G}_{\lfloor j/b \rfloor}$ \label{line:evalprove-secondhalf-regular}
	%\item \pcind \pcind \pcind $\mathsf{C}_O^{\prime(i)} \gets \mathsf{C}_O^{\prime(i)} + \hat{h}_j \cdot \mathsf{G}_{\lfloor (j+2^i)/b\rfloor}$ \label{line:evalprove-secondhalf-prime}
	\item \pcind \pcind $\mathsf{C}_O^{(i)} \gets \mathsf{MultiExp}(\{(\hat{h}_j, \mathsf{G}_{\lfloor j/b \rfloor}) \, | \, \hat{h}_j \cdot X^j \in \mathsf{terms}(\hat{f}_O^{(i)}(X^{2^i}))\})$ \label{line:evalprove-secondhalf-regular}
	\item \pcind \pcind $\mathsf{C}_O^{(i)} \gets \mathsf{MultiExp}(\{(\hat{h}_j, \mathsf{G}_{\lfloor (j+2^i)/b\rfloor}) \, | \, \hat{h}_j \cdot X^j \in \mathsf{terms}(\hat{f}_O^{(i)}(X^{2^i}))\})$ \label{line:evalprove-secondhalf-prime}
	%\item \pcind $\pi_{\mathsf{Eval}} \gets \pi_{\mathsf{Eval}} \Vert \mathbf{y}_O^{(i)} \Vert \mathsf{C}_O^{(i)} \Vert \mathsf{C}_O^{\prime(i)}$
	%\item \pcind $\alpha \gets \mathsf{H}(\mathsf{C} \Vert \mathbf{z} \Vert \mathbf{y} \Vert \pi_{\mathsf{Eval}})$  \pccomment{Fiat-Shamir}
	\item \pcind $\alpha \gets \mathsf{H}(\cdots)$
	\item \pcind $\hat{f} \gets \hat{f}_E(X) + \alpha \cdot \hat{f}_O^{(i)}(X)$
	\item \pcind \textbf{for} $j$ \textbf{from} $0$ \textbf{to} $b/2^{i+1}-1$ \textbf{:}
	\item \pcind \pcind $\mathsf{P}_j \gets \mathsf{P}_j + \alpha \cdot \mathsf{P}_{b/2^{i+1}+j}$ \label{line:evalprover-maintenance}
	%\item $\pi_{\mathsf{PoE}} \gets \mathsf{BatchPoE.Prove}((\mathsf{C}_O^{(0)}, \mathsf{C}_O^{\prime(0)}, \ldots, \mathsf{C}_O^{(\lfloor\log_2(d)\rfloor)}, \mathsf{C}_O^{\prime(\lfloor\log_2 d\rfloor)}); (\hat{f}_O^{(\lfloor \log_2 d\rfloor)}, \ldots, \hat{f}_O^{(\log_2 b)}))$
	\item $\pi_{\mathsf{PoE}} \gets \mathsf{BatchPoE.Prove}(((\mathsf{C}_O^{(i)}, \mathsf{C}_O^{\prime(i)}))_{i=0}^{\lfloor \log_2 d\rfloor};$ $(\hat{f}_O^{(i)})_{i = \log_2 b}^{(\lfloor \log_2 d\rfloor)})$ \label{line:evalprove-batchpoe}
	%\item $\pi_{\mathsf{Eval}} \gets \pi_{\mathsf{Eval}} \Vert \pi_{\mathsf{PoE}} \Vert \hat{f}$
	\item $\pi_{\mathsf{Eval}} = \Big\Vert_{i=0}^{\lfloor \log_2 d \rfloor} (\mathbf{y}_O^{(i)} \Vert \mathsf{C}_O^{(i)} \Vert \mathsf{C}_O^{\prime(i)})$
	\item \textbf{return} $\pi = \pi_{\mathsf{Eval}} \Vert \pi_{\mathsf{PoE}} \Vert f$
\end{enumerate}
$\mathsf{Eval.Verify}(\mathsf{C}, \mathbf{z}, \mathbf{y}, \pi)$ \textbf{:}
\begin{enumerate}[nolistsep]
	\item parse $\pi$
	%\item $\tau \gets \mathsf{C} \Vert \mathbf{z} \Vert \mathbf{y}$
	\item \textbf{for} $i$ \textbf{from} $0$ \textbf{to} $\log_2(d)-1$ \textbf{:}
	%\item \pcind $\tau \gets \tau \Vert \mathbf{y}_O^{(i)} \Vert \mathsf{C}_O^{(i)} \Vert \mathsf{C}_O^{\prime(i)}$
	\item \pcind $\alpha \gets \mathsf{H}(\cdots)$
	\item \pcind $\mathsf{C}_E^{(i)} \gets \mathsf{C} - \mathsf{C}_O^{\prime (i)}$
	\item \pcind $\mathsf{C} \gets \mathsf{C}_E^{(i)} + \alpha \cdot \mathsf{C}_O^{(i)}$ \label{line:evalverify-alpha}
	\item \pcind $\mathbf{y} \gets \mathbf{y} - \mathbf{z} \circ \mathbf{y}_O^{(i)} + \alpha \cdot \mathbf{y}_O^{(i)} \mod p$
	\item $b_{\mathsf{PoE}} \gets \mathsf{BatchPoE.Verify}(((\mathsf{C}_O^{(i)}, \mathsf{C}_O^{\prime(i)}))_{i=0}^{\lfloor \log_2 d \rfloor},$ $\pi_{\mathsf{PoE}})$ \label{line:evalverify-batchpoe}
	\item \textbf{if} $y_0 = \cdots = y_{s-1} = \hat{f} \mod p$ \textbf{and} $|\hat{f}| < B$ \textbf{and} $\hat{f} \cdot \mathsf{G} = \mathsf{C}$ \textbf{and} $b_{\mathsf{PoE}} = \mathsf{true}$ \textbf{:}
	\item \pcind \textbf{return} $\mathsf{true}$
	\item \textbf{else :}
	\item \pcind \textbf{return} $\mathsf{false}$
\end{enumerate}
\end{mdframed}


\begin{mdframed}
$\mathsf{BatchPoE.Prove}(((\mathsf{C}_O^{(i)}, \mathsf{C}_O^{\prime(i)}))_{i=0}^{\lfloor \log_2 d\rfloor};$ $(\hat{f}_O^{(i)})_{i = \log_2 b}^{(\lfloor \log_2 d\rfloor)})$ \textbf{:}
\begin{enumerate}[nolistsep]
	\item $\pi_{\mathsf{PoE}} \gets \varnothing$
	\item $\mathsf{X} \gets \mathsf{C}_O^{(\log_2(d)-1)}$ and $\mathsf{Z} \gets \mathsf{C}_O^{\prime(\log_2(d)-1)}$ and $\hat{f} \gets \hat{f}_O^{(\lfloor \log_2 d \rfloor)}$
	\item \textbf{for} $i$ \textbf{from} $\lfloor \log_2 d \rfloor$ \textbf{down to} $1$ \textbf{:}
	\item \pcind \textbf{if} $i \geq \log_2 b$ \textbf{:} 
	%\item \pcind \pcind $\mathsf{Y}^{(i)} \gets 0$
	%\item \pcind \pcind \textbf{for all} nonzero terms $\hat{h}_jX^j$ of $\hat{f}(X^{2^i})$ \textbf{:}
	%\item \pcind \pcind \pcind $\mathsf{Y}^{(i)} \gets \mathsf{Y}^{(i)} + \hat{h}_j \cdot \mathsf{G}_{(j+2^{i-1})/b}$ \label{line:batchpoeprove-big}
	\item \pcind \pcind $\mathsf{Y}^{(i)} \gets \mathsf{MultiExp}(\{(\hat{h}_j, \mathsf{G}_{(j+2^{i-1})/b}) \, | \, \hat{h}_j \cdot X^j \in \mathsf{terms}(\hat{f}(X^{2^i})) \})$ \label{line:batchpoeprove-big}
	\item \pcind \textbf{else :}
	\item \pcind \pcind $\mathsf{Y}^{(i)} \gets q^{2^{i-1}} \cdot \mathsf{X}$ \label{line:batchpoeprove-small}
	\item \pcind $\pi_{\mathsf{PoE}} \gets \pi_{\mathsf{PoE}} \Vert \mathsf{Y}^{(i)}$
	\item \pcind $\alpha, \beta \gets \mathsf{H}(\cdots)$ 
	\item \pcind $\mathsf{X} \gets \mathsf{X} + \alpha \cdot \mathsf{Y}^{(i)} + \beta \cdot \mathsf{C}_O^{(i)}$ \label{line:batchpoeprove-regular}
	\item \pcind $\mathsf{Z} \gets \mathsf{Y}^{(i)} + \alpha \cdot \mathsf{Z} + \beta \cdot \mathsf{C}_O^{\prime(i)}$\label{line:batchpoeprove-prime}
	\item \pcind $\hat{f} \gets \hat{f}(X) + \alpha \cdot X^{2^{i-1}} \cdot \hat{f}(X) + \beta \cdot \hat{f}^{(i)}_O(X)$
	\item \textbf{return} $\pi_{\mathsf{PoE}}$
\end{enumerate}
$\mathsf{BatchPoE.Verify}(((\mathsf{C}_O^{(i)}, \mathsf{C}_O^{\prime(i)}))_{i=0}^{\lfloor \log_2 d \rfloor}), \pi_{\mathsf{PoE}})$ \textbf{:}
\begin{enumerate}[nolistsep]
	\item parse $\pi_{\mathsf{PoE}}$
	\item $\mathsf{X} \gets \mathsf{C}_O^{(\log_2(d)-1)}$ and $\mathsf{Z} \gets \mathsf{C}_O^{\prime(\log_2(d)-1)}$
	\item \textbf{for} $i$ \textbf{from} $\log_2(d) - 1$ \textbf{down to} $1$ \textbf{:}
	\item \pcind $\pi \gets \pi \Vert \mathsf{Y}^{(i)}$
	\item \pcind $\alpha, \beta \gets \mathsf{H}(\cdots)$
	\item \pcind $\mathsf{X} \gets \mathsf{X} + \alpha \cdot \mathsf{Y}^{(i)} + \beta \cdot \mathsf{C}_O^{(i)}$
	\item \pcind $\mathsf{Z} \gets \mathsf{Y}^{(i)} + \alpha \cdot \mathsf{Z} + \beta \cdot \mathsf{C}_O^{\prime(i)}$
	\item \textbf{if} $q \cdot \mathsf{X} = \mathsf{Z}$ \textbf{:}
	\item \pcind \textbf{return} $\mathsf{true}$
	\item \textbf{else :}
	\item \pcind \textbf{return} $\mathsf{false}$
\end{enumerate}
\end{mdframed}

\subsection{Complexity}

The performance of all algorithms is dominated by the number of group operations. Therefore, we restrict our attention to exponentiations and count the total number of bits in all exponents. For the asymptotic expressions we simplify using the approximations $q \approx \lambda \cdot \log d$, $\lambda \approx p$, and $b \approx \sqrt{d}$.

\begin{itemize}
\item $\mathsf{Preprocess}$ involves $\frac{d+1}{b}$ exponentiations of $b \cdot (1 + \lfloor \log_2 q \rfloor)$ bits, or $(d+1) \cdot (1 + \lfloor \log_2 q \rfloor) \in O_\lambda(d \log d)$ exponent bits in total. The common reference string consists of $\frac{d+1}{b}$ group elements.
\item $\mathsf{Commit}$ performs $s$ exponentiations of $1+\lfloor \log_2 p \rfloor$ bits on line~\ref{line:commit-coefficient}, and $b-1$ exponentiations of $1+\lfloor \log_2 q \rfloor$ bits on line~\ref{line:commit-shift}. Asymptotically speaking, the total number of exponent bits amounts to $O_\lambda(\sqrt{d} \log d + s)$. The commitment itself consists of a single group element, whereas the cache contains $b$ group elements.
\item $\mathsf{BatchPoE.Prove}$ has $\lfloor \log_2 d \rfloor$ iterations with $i \in \{1, \ldots, \lfloor \log_2 d \rfloor\}$. When $i \in \{1, \ldots, \log_2(b)-1\}$ there is one exponent of $(1 + \lfloor \log_2 q \rfloor) \cdot {2^{i-1}}$ bits (line~\ref{line:batchpoeprove-small}), totalling $(1+\lfloor \log_2 q \rfloor) \cdot (b-1)$ exponent bits. \\
When $i \in \{\log_2 b, \ldots, \lfloor \log_2 d \rfloor\}$ there are at most $s$ exponentiations of $i \cdot \lambda + 1 + \lfloor \log_2 p \rfloor$ bits (line~\ref{line:batchpoeprove-big}). In fact, there are only at most $\min(s, \, 2^{\lfloor \log_2 d \rfloor - i})$ such exponentiations, and while it is tempting to select $s$ as a formulaically easy upper bound, the better complexity expression arises from focusing on the second argument. Note that $2^{\lfloor \log_2 d \rfloor - i}$ is maximal for $i = \log_2 b$ in which case the minimum is $d/b$. So there are at most $d/b \cdot (\lfloor \log_2 d \rfloor - \log_2(b) + 1) \cdot (1 + \lfloor \log_2 p \rfloor) + d/b \cdot \lambda \cdot (\lfloor \log_2 d \rfloor + \log_2 b) \cdot (\lfloor \log_2 d \rfloor - \log_2(b) + 1)/2$ exponent bits in total. \\
In each of these $\lfloor \log_2 d \rfloor$ iterations there are four more exponentiations of $\lambda$ bits (lines~\ref{line:batchpoeprove-regular} and~\ref{line:batchpoeprove-prime}). In total this amounts to $(1+\lfloor \log_2 q \rfloor) \cdot (b-1)  +  d/b \cdot (\lfloor \log_2 d \rfloor - \log_2(b) + 1) \cdot (1 + \lfloor \log_2 p \rfloor) + d/b \cdot \lambda \cdot (\lfloor \log_2 d \rfloor + \log_2 b) \cdot (\lfloor \log_2 d \rfloor - \log_2(b) + 1)/2  +  4 \cdot \lambda \cdot \lfloor \log_2 d \rfloor$ exponent bits, or $O_\lambda(\sqrt{d} \cdot (\log d)^2)$ asymptotically.
\item $\mathsf{BatchPoE.Verify}$ has $\lfloor \log_2 d \rfloor$ iterations and in every iteration there are four $\lambda$-bit exponentiations. Finally, there is a test involving $1+\lfloor \log_2 q \rfloor$ exponent bits. The asymptotic total is therefore $O_\lambda(\log d)$.
\item $\mathsf{Eval.Prove}$ has exponentiations in several places. The outer loop of line~\ref{line:evalprove-firsthalf-bigstep} has $\log_2 b$ iterations; the inner loop has $b/2^i$ exponentiations where $i \in \{0, \ldots, \log_2(b)-1\}$ is the index of the outer loop. In all of these exponentiations, the exponent is $q^{2^i}$. So in every iteration of the outer loop there are $b/2^i \cdot 2^i \cdot (1 + \lfloor \log_2 q\rfloor) = b \cdot ( 1 + \lfloor \log_2 q \rfloor)$ exponent bits. The total number of exponent bits of this line across all iterations is therefore $\log_2 b$ times this number. \\
Line~\ref{line:evalprove-firsthalf-shift} has $\log_2 b$ exponents of size $1 + \lfloor \log_2 q \rfloor$ each. \\
Lines~\ref{line:evalprove-secondhalf-regular} and \ref{line:evalprove-secondhalf-prime} each have at most $s$ exponents of length at most $i \cdot \lambda + 1 + \lfloor \log_2 p \rfloor$, for each iteration in a loop iterating over $i \in \{\log_2 b, \ldots, \lfloor\log_2(d)\rfloor\}$. In fact, there are only $\min(s, 2^{\log_2(d) - i})$ exponents and the better complexity expression arises from the second argument, which is never larger than $d/b$. This gives $(\lfloor \log_2 d \rfloor - \log_2(b) + 1) \cdot (1 + \lfloor \log_2 p \rfloor + (\lfloor \log_2 d \rfloor + \log_2 b) \cdot \frac{\lambda}{2}) \cdot \frac{d}{b}$ exponent bits in total for each line. \\
The loop of line~\ref{line:evalprover-maintenance} is run in its entirety $1 + \lfloor \log_2 d \rfloor$ times, for all $i \in \{0, \ldots, \lfloor \log_2 d \rfloor\}$. It runs for $b/2^{i+1}$ iterations and involves a single exponent of length $\lambda$ in each iteration. This gives $(b + \frac{b}{d}) \cdot \lambda$ total exponent bits. \\
Line~\ref{line:evalprove-batchpoe} invokes $\mathsf{BatchPoE.Prove}$, for which the number of exponent bits has already been counted. \\
By summing all terms, we have a total number of bits in exponents whose exact count is given below. Using the above approximations, this total number is asymptotically $O_\lambda(\sqrt{d} \cdot (\log d)^2)$ \\
\begin{center}
\begin{tabular}{rrl} \\
line~\ref{line:evalprove-firsthalf-bigstep}: & $b \cdot ( 1 + \lfloor \log_2 q \rfloor )$ \\
line~\ref{line:evalprove-firsthalf-shift}: & $\log_2(b) \cdot (1 + \lfloor \log_2 q \rfloor)$ \\
line~\ref{line:evalprove-secondhalf-regular}: & $(\lfloor \log_2 d \rfloor - \log_2(b) + 1) \cdot (1 + \lfloor \log_2 p \rfloor$ \\
 & $ + (\lfloor \log_2 d \rfloor + \log_2 b) \cdot \frac{\lambda}{2}) \cdot \frac{d}{b}$ \\
line~\ref{line:evalprove-secondhalf-prime}: & $(\lfloor \log_2 d \rfloor - \log_2(b) + 1) \cdot (1 + \lfloor \log_2 p \rfloor $ \\
 & $+ (\lfloor \log_2 d \rfloor + \log_2 b) \cdot \frac{\lambda}{2}) \cdot \frac{d}{b}$ \\
line~\ref{line:evalprover-maintenance}: & $(b + \frac{b}{d}) \cdot \lambda$ \\
line~\ref{line:evalprove-batchpoe}: & $(1+\lfloor \log_2 q \rfloor) \cdot (b-1)  +  \frac{d}{b} \cdot (\lfloor \log_2 d \rfloor $ \\
 & $- \log_2(b) + 1) \cdot (1 + \lfloor \log_2 p \rfloor) $ \\
 & $ + \frac{d}{b} \cdot \lambda \cdot (\lfloor \log_2 d \rfloor + \log_2 b)$ \\
 & $ \cdot (\lfloor \log_2 d \rfloor - \log_2(b) + 1)/2 $ \\
 & $ +  4 \cdot \lambda \cdot \lfloor \log_2 d \rfloor$ \\ \hline
total: & $(2b + \log_2(b) - 1) \cdot (1 + \lfloor \log_2 q \rfloor)$ \\
 & $+ 3\frac{d}{b} \cdot (\lfloor \log_2 d \rfloor - \log_2(b) + 1)$ \\
 & $ \cdot ( 1 + \lfloor \log_2 p \rfloor ) + \big(b + \frac{d}{b} + 4 \lfloor \log_2 d \rfloor$ \\
 & $ + \frac{d}{2b} \cdot ( \lfloor \log_2 d \rfloor - \log_2(b) + 1)$ \\
  & $ \cdot (\lfloor \log_2 d \rfloor + \log_2 b)\big) \cdot \lambda$ \\
 & $\in O_\lambda(\sqrt{d} \cdot (\log d)^2)$ 
\end{tabular}
\end{center}
\item $\mathsf{Eval.Verify}$ has $\lfloor \log_2 d \rfloor$ exponentiations in line~\ref{line:evalverify-alpha}, involving $\lambda$ exponent bits for each iteration. Additionally, line~\ref{line:evalverify-batchpoe} invokes $\mathsf{BatchPoE.Verify}$, which comes with another $4 \cdot \lfloor \log_2 d \rfloor \cdot \lambda + 1 + \lfloor \log_2 q \rfloor$ exponent bits. With the above approximations, this total is asymptotically $O_\lambda(\log d)$.
\end{itemize}


\section{Security}

The security of our scheme is provable under the Random Order Assumption. We first show that this assumption is implied by the RSA Assumption as captured by Couteau~\emph{et al.}~\cite{EC:CouPetPoi17}. In this formalism, the exponent $\ell$ is drawn from a distribution, which is itself a parameter of the assumption. In our case we take the uniform distribution over $[N] = \{1, \ldots, N\}$ for some large enough $N \in \mathbb{N}$ determined by the group generator $\ggen$

\begin{assumption}[RSA assumption, \cite{RivShaAdl78,EC:CouPetPoi17}]
	The RSA assumption states that an efficient adversary cannot compute a random root (co-prime with the order of the group) for a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\[
    \Pr\left[
    \begin{array}{l}
    \ell \cdot \gr{U} = \Generator \, \wedge \\
    \gcd(\ell,|\GG|)=1
    \end{array} :
    \begin{array}{l}
         \GG, N \leftarrow \ggen(\lambda)  \\
         \Generator \sample \GG, \ell \sample [N]  \\
         \gr{U} \in \mathbb{G} \leftarrow \adv(\mathbb{G}, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
\]

\end{assumption}

\begin{assumption}[Random Order Assumption]
	The random order assumption states that an efficient adversary cannot compute a multiple of the order of a given random group element. Specifically, it holds for $\ggen$ if for any probabilistic polynomial time adversary $\adv$:
	\[
    \Pr\left[a\cdot \Generator =0:
    \begin{array}{l}
         \GG, N \leftarrow \ggen(\lambda)  \\
         \Generator, \sample \GG\\
         a \in \NN \leftarrow \adv(\mathbb{G},N, \Generator) \\
    \end{array}\right] \leq \negl \enspace .
    \]
\end{assumption}
\begin{lemma}
\label{lem:roa-to-rsa}
	The RSA Assumption for $\ggen$ implies the Random Order Assumption
	\end{lemma}
\begin{proof}
	Given an efficient adversary $\adv_{\textsf{Order}}$ for the random order assumption we will construct an efficient adversary $\adv_{\textsf{RSA}}$ for the RSA assumption. On input $\GG,\Generator,\ell$ to $\adv_{\textsf{RSA}}$ we will forward $\GG,\Generator$ to $\adv_{\textsf{Order}}$. $\adv_{\textsf{Order}}$ outputs $a$ such that $a\cdot \Generator=0$ with non-negligible probability $\epsilon$. 
	$\adv_{\textsf{RSA}}$ computes computes $a'\gets \frac{a}{\gcd(a,\ell^k)}$ for $k=\lceil\log_\ell(a)\rceil$. Note that since $\ell$ is co-prime to the order of $\GG$ and thus also the order of $\Generator$ and $a$ is a multiple of the order of $\Generator$ we have that $a'$ is still a multiple of the order of $\Generator$. Now $\adv_{\textsf{RSA}}$ computes $w\gets \ell^{-1} \bmod a'$ and outputs $\gr{U} \gets w\cdot \Generator$. Now we have $\ell \cdot \gr{U}=\Generator$ so $\adv_{\textsf{RSA}}$ succeeds with probability $\epsilon$.
\end{proof}

%At the heart of our security analysis is the equality of expressions \emph{up to group elements of known order}. This perspective motivates modifying the commitment scheme into one where the opener does not need to reproduce the commitment exactly, but must know the order of the difference. Simultaneously, it pays to analyze the protocol with respect to integer commitments and only decode the Kronecker substitution in the last step. In summary, we consider the following integer commitment scheme.
%
%\begin{mdframed}
%$\mathsf{com}(\mathsf{pp}, f \in \mathbb{Z})$ \textbf{:}
%\begin{enumerate}[nolistsep]
%\item $\mathsf{C} \gets f \cdot \mathsf{G}$ and $\mathsf{W} \gets 0 \in \mathbb{G}$ and $a \gets 1 \in \mathbb{Z}$
%\item \textbf{return} $(\mathsf{C}; f, \mathsf{W}, a)$
%\end{enumerate}
%\vspace{0.125cm}
%$\mathsf{vfy}(\mathsf{pp}, \mathsf{C}, f, \mathsf{W}, a)$ \textbf{:}
%\begin{enumerate}[nolistsep]
%\item \textbf{test} $a \stackrel{?}{\neq} 0$ and $f \cdot \mathsf{G} + \mathsf{W} \stackrel{?}{=} \mathsf{C}$ and $a \cdot \mathsf{W} \stackrel{?}{=} 0$
%\item \textbf{if} all tests pass, \textbf{return} $\mathsf{true}$; \textbf{else return} $\mathsf{false}$
%\end{enumerate}
%\end{mdframed}
%
%\begin{lemma}[Binding commitment]
%\label{lem:aug-com-binding}
%The commitment scheme $(\mathsf{com}, \mathsf{vfy})$ is binding under the Random Order Assumption. 
%\end{lemma}
%\begin{proof}
%Suppose a polynomial time adversary is able to compute a commitment $\gr{C}$ and two openings $(f_1, \mathsf{W}_1, a_1)$ and $(f_2, \mathsf{W}_2, a_2)$ such that $f_1 \neq f_2$ but $\mathsf{vfy}(\mathsf{pp}, \mathsf{C}, f_1, \mathsf{W}_1, a_1) = \mathsf{vfy}(\mathsf{pp}, \mathsf{C}, f_2, \mathsf{W}_2, a_2) = \mathsf{true}$. Then we have $a_1 a_2 (f_1 \cdot \mathsf{G} + \mathsf{W}_1 - f_2 \cdot \mathsf{G} - \mathsf{W}_2) = a_1 a_2 (f_1 - f_2) \cdot \mathsf{G} = 0$ and hence $a_1 a_2 (f_1 - f_2)$ is a multiple of the order of $\mathsf{G}$.
%\end{proof}

The security proof relies on the following lemmata, which we prove first. In the following we use $\mathsf{denoms} : \mathbb{Q}[X] \rightarrow \mathbb{Z}^*$ to refer to the list denominators of a rational polynomial's nonzero coefficients, and $\mathsf{denom} : \mathbb{Q} \rightarrow \mathbb{Z}$ analogously for a single rational number.

\begin{lemma}
Let $f(X) \in \mathbb{Q}[X]$ and let $\mathsf{max} \circ \mathsf{denoms}(f) > B$, and let $f_O(X) = \frac{f(X) - f(-X)}{2}$ and $f_E(X) = \frac{f(X) + f(-X)}{2}$, then
$$ \mathrm{Pr}[\mathsf{max} \circ \mathsf{denoms} (f_E(X) + \alpha f_O(X)) < \frac{B}{2^\lambda}] \leq \mathsf{negl}(\lambda) $$
for $\alpha \sample \{-2^{\lambda-1}, \ldots, 2^{\lambda - 1} - 1 \}$.
\end{lemma}

\begin{proof}
Let $f_{E,i}$ and $f_{O,i}$ denote the $i$th coefficient of their respective polynomials. The probability in question is less than or equal to
\begin{equation}
\mathrm{Pr}\left[\mathsf{denom} (f_{E,i} + \alpha f_{O,i}) < \frac{B}{2^\lambda}\right] \label{equation:minimum_probability_shinking_denominator}
\end{equation}
for any coefficient index $i$.

Let $f_{E,i} = \frac{f_{E,i}^\star}{d_E}$ and $f_{O,i} = \frac{f_{O,i}^\star}{d_O}$ for integers $f_{E,i}^\star, f_{O,i}^\star, d_E, d_O$. Let moreover $d_E' = \frac{d_E}{\mathsf{gcd}(d_E, d_O)}$, $d_O' = \frac{d_O}{\mathsf{gcd}(d_E, d_O)}$ and $D = \mathsf{lcm}(d_E, d_O)$. Then 
\begin{flalign*}
\mathsf{denom} (f_{E,i} + \alpha f_{O,i}) &= \\
\mathsf{denom}\left(\frac{d_O' f^\star_{E,i} + \alpha d_E' f^\star_{O,i}}{D}\right) &= \\
\frac{D}{\mathsf{gcd}\left( D, d_O' f^\star_{E,i} + \alpha d_E' f^\star_{O,i} \right)} &< \frac{B}{2^\lambda} \enspace .
\end{flalign*}

Note that $d_O' f^\star_{E,i}$ and $d_E' f^\star_{O,i}$ are mutually co-prime, and that for some coefficient index $i$, $D \geq B$. Reshuffling gives
$$ \mathsf{gcd}(D, d_O' f^\star_{E,i} + \alpha d_E' f^\star_{O,i}) > {2^\lambda} \enspace ,$$
and the probability of this event is bounded by Lemma~\ref{lemma:gcd_distribution} to a negligible quantity in $\lambda$.
\end{proof}

\begin{lemma} \label{lemma:gcd_distribution}
Let $b, c, D \in \mathbb{Z}$ be three integers with $b$ and $c$ co-prime. Then
$$ \mathrm{Pr}[\mathsf{gcd}(D, b + \alpha c) > 2^\lambda] \leq \mathsf{negl}(\lambda) $$
for $\alpha \sample \{-2^{\lambda-1}, \ldots, 2^{\lambda - 1} - 1 \}$.
\end{lemma}

\begin{theorem}[knowledge-soundness of $\mathsf{Eval}$]
If $\mathsf{BatchPoE}$ is sound, and if the RSA Assumption is true, then the interactive protocol $\mathsf{Eval}$ is a proof of knowledge for the relation $\mathcal{R}_{\mathsf{PC}} =$
$$ \left\{ \langle (\mathsf{C}, \mathbf{z}, \mathbf{y}, d), (f(X), \hat{f})\rangle : \begin{array}{l}
\mathsf{deg}(f(X)) \leq d \\
f(\mathbf{z}) = \mathbf{y} \\
\hat{f} \cdot \mathsf{G} = \mathsf{C} \\
\mathsf{Dec}(\hat{f}) = f(X)
\end{array} \right\} \, .$$
\end{theorem}

\begin{proof}
We describe the operation of the PPT extractor machine \extractor, which has rewinding access to a possibly malicious prover $\prover^*$, which in turn succeeds with overwhelming probability in convincing the verifier.

Consider the binary tree of depth $\lfloor \log d \rfloor$ where every node is labelled with a message from the prover and every edge is labelled with a message from the verifier. Every path from root to leaf corresponds to a transcript. In addition, the label of every node also contains the group elements $\mathsf{C}^{(i)}$ and $\mathsf{C}_E^{(i)}$, which take the value of the corresponding variable in the $\mathsf{Eval.Verify}$ protocol at the given iteration. \extractor\, starts by generating this tree.

\extractor\, proceeds to compute opening information, corresponding to the discrete logarithm base $\mathsf{G}$, for every group element in this tree. For every leaf, \extractor\, reads the value $\hat{f}$. For every non-leaf node, \ext\, merges the opening information associated with $\mathsf{C}^{(i+1)}$ of the node's children. Let the subscript $1$ and $2$ distinguish the two children nodes. Then we have the following matrix equation:
$$ \left( \begin{array}{c}
\mathsf{C}_1^{(i+1)} \\
\mathsf{C}_2^{(i+1)}
\end{array} \right) = \left( \begin{matrix}
1 & \alpha_1 \\
1 & \alpha_2
\end{matrix} \right) \left( \begin{array}{c}
\mathsf{C}_E^{(i)} \\
\mathsf{C}_O^{(i)}
\end{array} \right) \enspace .$$
Re-arranging gives
$$ (\alpha_2 - \alpha_1) \left( \begin{array}{c}
\mathsf{C}_E^{(i)} \\
\mathsf{C}_O^{(i)}
\end{array} \right) = \left( \begin{matrix}
\alpha_2 & -\alpha_1 \\
-1 & 1
\end{matrix} \right) \left( \begin{array}{c}
\mathsf{C}_1^{(i+1)} \\
\mathsf{C}_2^{(i+1)}
\end{array} \right) \enspace .$$
Expanding the first equation gives
\begin{flalign*}
(\alpha_2 - \alpha_1) \cdot ( f_E^{(i)} \cdot \mathsf{G} ) = ( \alpha_2 f_1^{(i+1)} - \alpha_1 f_2^{(i+1)} ) \cdot \mathsf{G} \enspace .
\end{flalign*}
If $\alpha_2 - \alpha_1$ divides $\alpha_2 f_1^{(i+1)} - \alpha_1 f_2^{(i+1)}$, then $f_E^{(i)} \gets \frac{\alpha_2 f_1^{(i+1)} - \alpha_1 f_2^{(i+1)}}{\alpha_2 - \alpha_1}$. If not, they have a greatest common divisor $g \neq 0$ and Bezout coefficients $x, y$ such that $x(\alpha_2 - \alpha_1) + y(\alpha_2 f_1^{(i+1)} - \alpha_1 f_2^{(i+1)}) = g$. Then using Shamir's trick we have
\begin{flalign*}
& (\alpha_2 - \alpha_1) \cdot \left( x \cdot \mathsf{G} + y \cdot \mathsf{C}^{(i)} \right) \\
=& \left( x ( \alpha_2 - \alpha_1) + y ( \alpha_2 f_1^{(i+1)} - \alpha_1 f_2^{(i+1)} ) \right) \cdot \mathsf{G} \\
=& g \cdot \mathsf{G} \enspace .
\end{flalign*}
In other words, $x \cdot \mathsf{G} + y \cdot \mathsf{C}^{(i)}$ is an $\frac{\alpha_2 - \alpha_1}{g}$th root of $\mathsf{G}$, violating the Strong RSA Assumption.

With a similar argument, \extractor\, computes $f_O^{(i)} \gets \frac{f_1^{(i)} - f_2^{(i)}}{\alpha_2 - \alpha_1}$ or outputs a $\frac{\alpha_2 - \alpha_1}{g}$th root of $\mathsf{G}$ if the division is not clean. Furthermore, the soundness of $\mathsf{BatchPoE}$ shows that $f_O^{\prime (i)} \gets q^{2^i} \cdot f_O^{(i)}$ is a valid assignment. And since $\mathsf{C}^{(i)} = \mathsf{C}_E^{(i)} + \mathsf{C}_O^{\prime (i)}$, so too is $f^{(i)} \gets f_E^{(i)} + f_O^{\prime (i)}$.

To do: go from integers to polynomials, show that coefficients are bounded, show that evaluations are necessarily correct
\end{proof}

\section{Sketched Protocol}
Using additive notation. 

\subsection{Odd Even Protocol}
\ben{Either include $q$ as a public input or set $q$ based on $b$. I also prefer using capital $B$ for a bound rather than lower case $b$. } 

\label{sec:oddeven}
\begin{mdframed}
Public Input: $C\in \GG, d \in \NN, \Bound\in \NN$\\
Witness: $f(X) \in \ZZ(\Bound)[X]$ \\
Claim: $\Commitment =\commit(f(X))$ and $\deg(f(X))<d$	\\
$\textsf{FFTEval}(q,C,d;f(X))$
\begin{enumerate}[nolistsep]
		\item $\pcif d=0$
		\item $\pcind[1]$ $\prover$ sends $f=f(X) \in \ZZ$
		\item $\pcind[1]$ $\verifier$ checks that $|f|<2^{\log_2(d_{\max}) \cdot \lambda} \cdot \Bound$ and that $f \cdot \Generator=\Commitment$\pccomment{$d_{\max}$ is the original degree here}
		\item $\pcelse$
		\item $\prover$ computes $f_E(X)$ and $f_O(X)$ s.t. $f_E(X^2)+X \cdot f_O(X^2)=f(X)$\pccomment{Odd and Even coefficients} 
		\item \prover sends $\Commitment_E\gets \commit(f_E(q^2))$ and $\Commitment_O\gets \commit(f_O(q^2))$ to $\verifier$. 
		\item $\verifier$ checks that $\Commitment_E+ q\cdot \Commitment_O=\Commitment$ \pccomment{$q$ grows in each round. Outsourced with PoEs. See below}
		\item $\verifier$ samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to $\prover$
		\item \prover and \verifier compute $\Commitment'\gets \Commitment_E+\alpha \cdot \Commitment_O$
		\item $\prover$ computes $f'(X)\gets f_E(X)+\alpha f_O(X)$
		\item \prover and \verifier run $\textsf{FFTEval}(q^2,\Commitment',\frac{d}{2};f'(X))$
	\end{enumerate}
\end{mdframed}

\subsection{Computing all PoEs at once}
%Let the subscript $i$ denote proof elements from the $i$th round of the protocol. Let $\numrounds=\logd$ be the number of rounds in the protocol.
We present a \textsf{BatchPoE} protocol for proving that $\numrounds$ pairs of group elements $\{(\gr{C}_i, \gr{C}'_i)\}_{i=1}^k$ satisfy $q^{2^{i-1}} \cdot \gr{C}_i = \gr{C}'_i$ for all $i \in [\numrounds]$.
While this could be proved with $k$ independent PoE proofs, the protocol we present saves a factor $k$ in the communication cost over the naive solution.
%Let $\gr{D}_{i}\gets \gr{C}_{O,i}$ and $\gr{D}_{i}'\gets \gr{C}_{i}-\gr{C}_{i}$ for $i \in [1,\numrounds]$ such that $q^{2^{i-1}} \cdot \gr{D}_i=\gr{D}'_i$ for all $i\in [\numrounds]$. The prover and verifier run the following \textsf{BatchPoE} protocol that the claims hold.
\begin{mdframed}
\underline{\textsf{BatchPoE} \textbf{protocol}} \\
Prover and Verifier Input: $\{(\gr{C}_i,\gr{C}_i')\}_{i=1}^{\numrounds},q$\\
Claim: $q^{2^{i-1}}\cdot \gr{C}_i=\gr{C}'_i \quad \forall i \in \{1,...,\numrounds\}$
	\begin{enumerate}[nolistsep]
\item $\gr{X}_{\numrounds} \deq \gr{C}_{\numrounds}$, $\gr{Z}_{\numrounds} \deq \gr{C}'_{\numrounds}$
	\item $\pcwhile  i  > 1$
   \item \pcind[1]\prover computes $\gr{Y}_{i}\deq q^{2^{i-2}}\cdot \gr{X}_{i}$
\item\pcind[1]\prover sends $\gr{Y}_{i}$ to $\verifier$
	\item \pcind[1]$\verifier$ samples $\alpha \sample [-2^{\lambda-1} ,2^{\lambda-1}]$ and sends them to $\prover$
	\item \pcind[1]\prover and \verifier compute  $\gr{X}_{i-1} \deq  \gr{X}_{i}+ \alpha\cdot  \gr{Y}_{i}+\alpha^2 \cdot\gr{C}_{i-1}$
	\item $\pcind[1]$\verifier compute   $\gr{Z}_{i-1}\deq \gr{Y}_{i}+\alpha\cdot \gr{Z}_{i}+\alpha^2 \cdot \gr{C}_{i-1}^{'}$ 
	     \pccomment{Invariant: $q^{2^{i-2}} \cdot \gr{X}_{i-1} = \gr{Z}_{i-1}$ }
	\item $\pcind[1] i \deq i - 1$
\item \verifier outputs \textsf{accept} if and only if $q\cdot \gr{X}_1=\gr{Z}_1$
\end{enumerate}
\end{mdframed}
\paragraph{Challenge distribution}
Instead of using $\alpha$ and $\alpha^2$ as challenges it is also possible to use independently sampled $\alpha$ and $\beta$. The security argument is slightly more complicated as one needs to argue that the challenge matrix remains diagonalizable. The main benefit is that it decreases the verifier complexity slightly as $\alpha^2 \in \ZZ$ is about twice the size of $\alpha$ and $\beta$. 

\subsection{Computational complexity of batch PoE}
\ben{We analyze the complexity of Batch PoE both in general, and in the special case that...} The main prover work is in computing $\gr{Y}_i$. In the first few loops $\gr{Y}_i=g^{h(q)}$ for a sparse polynomial $h(X)$. For example in the first loop $h(X)$ has only a single non-zero coefficient.
After $\logd/2$ rounds the polynomial has roughly $\sqrt{d}$ coefficients. It then makes sense to switch to computing $\gr{Y}_i$ using a sequential computation, i.e. $\gr{Y}_i=\gr{X}_i^{q^{2^{i-2}}}$. This now also takes $O(\sqrt{d}\cdot \log{d})$ work. One could also switch earlier from one computation to the other. Additionally it is possible to use Wesolowski PoEs for the second part of the loop, i.e. the first half of the Odd/Even protocol. This leads to a smaller proof size. One possible split may be to only do $\log{\log{d}}$ BatchPoEs at the end. This should give you prover time that is still linear but better proof size. In practice doing BatchPoE for the last $6$ rounds should be good for almost all input sizes.
\section{$\tilde{O}(\sqrt{d})$ eval}
The PoEs are efficient and with some caching during the commitment phase we can also make the rest of the eval have $\tilde{O}(\sqrt{d})$ complexity (only group operations). The protocol is parameterized by a bound $b$ which determines the amount of preprocessing. We discuss the perfect choice for $b$ later but for intuition it helps to think of $b=d/b=\sqrt{d}$.
\subsection{Idea}
The core idea is that we can write a polynomial $f(X)$ of degree $d-1$ as the sum of $b$ polynomials $f_i(X)$ of degree less than $\frac{d}{b}$. That is $f(X)=\sum_{i=0}^b X^i f_i(X^b)$. This is a direct generalization of the odd/even split that the $\textsf{FFTEval}$ protocol uses. During the committing phase the prover computes and stores commitments to $f_i(X^b)$, i.e. $P_i\gets g^{f_i(q^b)}$. Using the $\frac{d}{b}$ precomputed group elements $g,g^{q^b},g^{q^{2b}}\dots$ all $b$ $P_i$'s can be computed using $d$ $\lambda$-bit exponentiations\footnote{Ignoring multi-exponentiation speedups for now}. Given the $P_i$'s one can compute $C=g^{f(q)}$. This is because $C=\prod_{i=0}^{b-1} P_i^{q^i}$. By computing this product left to right, i.e. $C=(((P_{b-1}^qP_{b-2})^qP_{b-3})^q \dots)P_0$ this can be done using only $b$ $\log_2(q)$-bit exponentiations.

Similarly the prover can use the $P_i$ to compute to $C_O$, i.e. the commitment to $f_O(X^2)$ where $f(X)=f_E(X^2)+Xf_O(X^2)$. Additionally computing $C_O'=g^{q f(q^2)}$ can be done efficiently given just $C_O$ as $C_O'=C_O^q$. 

After each round the protocol continues with $f'(X)=f_E(X)+\alpha f_O(X)$ as a witness and $q_{i+1}=q_{i}^2$. Similarly as in the first round we can write $f'(X)$ as the sum of $b/2$ polynomials of degree less than $\frac{d}{b}$.
$f'(X)=\sum_{i=0}^{\frac{b}{2}-1} X^i f'_i(X^{\frac{b}{2}})$. Given the commitments to the $f_i(X^b)$ we can efficiently compute commitments to $f_i'(X)=f_{2i}(X)+\alpha f_{2i+1}(X)$ as $P_i'\gets P_{2i}P_{2i+1}^{\alpha}$. This takes work at most $b$, $\lambda$-bit exponentiations. Repeating this for $\log_2(b)$ rounds we end up with a witness polynomial $f''(X)$ of degree less than $\frac{d}{b}$. Given the precomputed $g_i$ the prover can construct commitments to $f''(X)$ and finish the protocol using $\frac{d}{b}$ $\lambda$-bit exponentiations. In the first $\log_2(b)$ steps the most expensive operations is computing $C_O$ given the $P_i$'s. This takes roughly $b$ $\log_2(q)$-bit exponentiations in every round, i.e. $b\log_2(b) \log_2(q)$-bit exponentiations in total.
\subsection{Protocol}
\begin{mdframed}
$\textsf{Preprocess(b)}$:
\begin{enumerate}[nolistsep]
	\item $\Generator_i={q^{ib}} \cdot \Generator$ for $i \in [0,\frac{d}{b}-1]$
	\item Output $\Generator_0,\dots,\Generator_{\frac{d}{b}-1}$
\end{enumerate}
$\textsf{Commit}(f(X),b):$
\begin{enumerate}[nolistsep]
	\item $f(X)=\sum_{i=0}^{b-1} X^{i} f_i(X^{b})$ \pccomment{$\deg(f_i(X))<\frac{d}{b}$.}
	\item Let $\gr{P}_i\gets f_i(q^b) \cdot \Generator$ for all $i \in [0,b-1]$\pccomment{ computed using $\Generator_i$; Cost: $d$ $\lambda$-bit exp.}
	\item Compute $\gr{C}\gets \sum_{i=0}^{b-1} q^i \cdot \gr{P}_i=(( \gr{P}_{b-1}\cdot q+\gr{P}_{b-2})\cdot q + \gr{P}_{b-3}) \cdot q+...\gr{P}_0$ \pccomment{Cost: $b$ $\log_2(q)$-bit exp.}
	\item Output $\gr{C}$ and $\gr{P}_{0}\dots,\gr{P}_{b-1}$
\end{enumerate}
$\textsf{FFTEval}(q,\gr{C},\gr{P}_0,\dots,\gr{P}_{b-1},b,d;f_0(X),\dots,f_{b}(X))$
\begin{enumerate}[nolistsep]
		\item $\alpha_0=\hash(\gr{C},f_0,q,b)$ 
		\item $\pcfor i=1$ to $\log_2(b)$
		\item $\pcind[1]$ $\gr{C}_{O,i}\gets\sum_{j=0}^{\frac{b}{2^i}-1} q^{j\cdot 2^i}\cdot \gr{P}_{2j+1}^{}$ \pccomment{Computed using folding method, Total Cost: $b \log{b}$ $\log_2(q)$-bit exp}.
		\item \pcind[1] $\gr{C}_{O,i}'= q^{2^i} \cdot \gr{C}_{O,i}^{}$ \pccomment{Total cost (all iterations) $b$ $q$-bit exp, might as well do W PoE here}
		\item \pcind[1] $\alpha_i\gets \hash(\alpha_{i-1} \gr{C}_{O,i})$ \pccomment{Fiat-Shamir}
		\item $\pcind[1] \gr{P}_{j}=\gr{P}_{2j}+ \alpha \cdot \gr{P}_{2j+1}^{}$ for $j \in [0,\frac{b}{2^i}]$\pccomment{$b$ $\lambda$-bit exp in total}
		\item $f'(X)\gets \sum_{i=0}^{b-1} f_i(X) \prod_{j=1}^{\log_2(b)} \alpha_j^{j\text{th last bit of }i}$ \pccomment{$f_0(X)+\alpha_1 f_1(X) + \alpha_2 f_2(X)$, Cost: $d$ field ops}
		\item \pcfor $i=\log_2(b)+1$ to $\logd$
		\item \pcind[1] $f'(X)=f_E(X^2)+Xf_O(X^2)$
		\item \pcind[1] $\gr{C}_{O,i}\gets f_O(q^{2^i}) \cdot \Generator$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp}
		\item  \pcind[1] $\gr{C}_{O,i}'\gets q^{2^{i-1}} \cdot f_O(q^{2^i}) \cdot \Generator$ \pccomment{Cost: $\frac{d}{b}$ times $\log_2(b) \lambda$-bit multiexp using the preprocessed $\Generator_i$s}
		\item \pcind[1] $\alpha_i\gets\hash(\gr{C}_{O,i},\gr{C}_{O,i}')$
		\item \pcind[1] $f'(X)=f_E(X)+\alpha_i f_O(X)$
		\item Proof is $\gr{C}_{O,1},\dots,\gr{C}_{O,\logd}$ and $\gr{C}_O$'s
		\item Add $f'=f'(X)$ to proof.
	\end{enumerate}
	\end{mdframed}
	For $b=\sqrt{d}$ the runtime is $O(d \logd^2)$. A value like $b=\sqrt{d/\log(d)}$ gives roughly $O(d\logd^{1.5})$. Parallelism and multi-exp techniques need to be taken into account and the optimal value is likely best determined numerically. There are limited options anyway as $b$ needs to be a power of $2$.\\ 
Step 2 in FFTEval is likely a bottleneck. Smaller q value would still help in this protocol.
\section{Security Proof}

.

\subsection{Proof}

\begin{fact}[Known order elements]
	\label{fact:knownorder}
	Given a two elements in a group and multiples of the order of these elements there exists an efficient algorithm computing the order of any linear combination of the elements.
\end{fact}
Let $\gr{W}_1,\gr{W}_2 \in \GG$ be such that $\alpha_1 \cdot \gr{W}_1=0$ and $\alpha_2 \cdot \gr{W}_2=0$ then for $\gr{W}'=a\gr{W}_1 + b \gr{W}_2$ we have that for $\alpha'=\lcm(\alpha_1,\alpha_2)$, $\alpha' \cdot \gr{W}'=0$
\begin{fact}
\label{fact:encoding}
Let $q \in \ZZ$ be any positive integer. For any integer $E \in \ZZ$ such that $|E|<\frac{q^{d+1}}{2}$ there exists a unique integer polynomial $f \in \ZZ[X]$ with $||f||_\infty < q/2$ such that $f(q) = E$. 
\end{fact} 

\begin{lemma}
\label{lem:encoding}
Let $q \in \Z$ be any positive integer. For any integers $z_1, z_2 \in \ZZ$ and integer polynomials $f_1, f_2 \in \ZZ[X]$ of degree at most $d$ with bounded coefficients such that $||f_1||_\infty < q/2$ and $||f_2||_\infty < q/2$, if $gcd(f_i(q), z_i) = 1$ and $z_2 \cdot f_1(q) = z_1 \cdot f_2(q)$ then 
$f_1 = f_2$ and $z_1 = z_2$. 
\end{lemma}
\begin{proof}
The rational numbers $\frac{f_1(q)}{z_1} = \frac{f_2(q)}{z_2} \in \QQ$ are in reduced rational form, hence $f_1(q) = f_2(q)$ and $z_1 = z_2$. The integers $f_1(q)$ and $f_2(q)$ have absolute value bounded by $\frac{q^{d+1}}{2}$, and thus $f_1 = f_2$ by Fact~\ref{fact:encoding}.
\end{proof}


%\begin{fact}
%\label{fact:encoding}
%Let q be an integer. For any rational $z$ with numerator $n \in \ZZ$ such that $|z|<\frac{q^{d+1}}{2}$ there exists a unique degree (at most) d rational polynomial $\hat{h}(X)$ in $\QQ(q)[X]$ such that $\hat{h}(q) = z$. If $q>n$ then there exists a unique polynomial $h(X) \in \ZZ/p\ZZ$ such that $\hat{h}\equiv h \bmod p$ 
%\end{fact}

	
		
	\begin{lemma}[PoEs]
		Protocol \textsf{BatchPoE} is an interactive proof of knowledge for the following relation:
		\[ \mathcal{R_\textsf{BPoE}} = \left\{
\big\langle \{(\gr{C}_i,\gr{C}_i')\}_{i=1}^{\numrounds}, q ; \ \{(\gr{W}_i\in \GG, a_i \in \ZZ)\}_{i=1}^k  \big\rangle
: \forall i
\begin{array}{l} 
 \Commitment_i' = q^{2^{\numrounds-i}}  \cdot \Commitment_i + \gr{W}_i \\ 
a_i\cdot \gr{W}_i=0
\end{array}\right\}
\]


		%$$\mathcal{R}_{POE}=\{\langle \{(\gr{G}_i,\gr{G}_i')\}_{i=1}^{\numrounds},q ;\{(\gr{W}_i\in \GG,a_i\in \ZZ)\}_{i=1}^k \rangle: \forall i \ \gr{G}_i' = q^{2^{\numrounds-i}}  \cdot \gr{G}_i + \gr{W}_i \ \ \wedge \ \ a_i\cdot \gr{W}_i=0]_{i=1}^{\numrounds-1} \}$$
	\end{lemma}
	\begin{proof}
		We define a knowledge extractor that runs with an adversary $\adv$ who succeeds for public inputs $\{(\Commitment_i,\Commitment_i')\}_{i=1}^{\numrounds}$ and $q$ with probability $\epsilon = 1/\poly$. The extractor begins by using the tree-finding algorithm of Lemma~\ref{lem:forking} to generate a tree of accepting transcripts with the following characteristics: 
\benedikt{Update proof to use challenges alpha and beta}
\begin{itemize}
\item The tree has depth $\numrounds$ and branching factor $3$. We index nodes by $v \in [0,3^\numrounds)$.

\item The root is labeled with the publics inputs. 
\item Each node $v$ distinct from the root is labeled with a challenge $\alpha_{v}$ and a prover message $\gr{Y}_v$. \ben{Check how to label leaves} 
\item Each non-leaf node $v$ has three children each labeled with three distinct verifier challenges 
$\alpha_{v,1} \neq \alpha_{v,2} \neq \alpha_{v,3}$.

\end{itemize} 

Since the verifier challenges in the protocol are sampled from $\mathcal{X} = [-2^{\lambda -1}, 2^{\lambda -1}]$, the probability of a collision over challenges $\alpha_1, \alpha_2 \sample \mathcal{X}$ sampled uniformly and independently is $2^{-\lambda}$. Thus, by Lemma~\ref{lem:forking} the tree-finding algorithm runs for $O(\poly/\epsilon)$ steps and succeeds with probability $1 - \negl/\epsilon$ to return a tree with these characteristics.

For the root node $\textsf{rt}$, define $\gr{X}_\textsf{rt} \deq \Commitment_\numrounds$ and $\gr{Z}_\textsf{rt} \deq \Commitment'_\numrounds$. For any node $v$ on level $i$ with parent $w$ on level $i+1$, which has prover message $\gr{Y}_v$ and verifier challenge $\alpha_v$, define $\gr{X}_v \deq \gr{X}_w + \alpha_v \cdot \gr{Y}_w + \alpha^2 \cdot \Commitment_{i-1}$. Similarly, define $\gr{Z}_v \deq \gr{Y}_w + \alpha \cdot \gr{Z}_w + \alpha^2\cdot  \Commitment'_{i-1}$.

We will show that given this tree, the extractor can compute for all nodes $v \in [0, 3^\numrounds]$ group elements $\gr{W}_v$ and integers $a_v$ such that $a_v \cdot \gr{W}_v = 0$ and if $v$ is on the $i$th level then $\gr{Z}_v = q^{2^{i-1}} \cdot \gr{X}_v + \gr{W}_v$. It can also compute values $\gr{W}'_v$ and $a'_v$ such that $a'_v \cdot \gr{W}'_v = 0$ and $\Commitment'_{i-1} = \Commitment_{i-1} + \gr{W}'_v$. It will do this by starting at the leaves and working its way up the tree.
For any leaf node $v$, the fact that the transcript is accepting implies $q \cdot \gr{X}_v = \gr{Z}_v$. Now suppose that the appropriate values $\gr{W}_v$ have been computed for all children of a node $w$ on the $i$th level. Denoting the three children of nodes $w$ with indices $v_1, v_2, v_3$ and the three challenges on each by $\alpha_1, \alpha_2, \alpha_3$. This means that $\gr{X}_{v_j} = \gr{X}_w + \alpha_j \cdot \gr{Y}_w + \alpha_j^2 \cdot \Commitment_{i-1}$ and $\gr{Z}_{v_j} = \gr{Y}_w + \alpha_j \cdot \gr{Z}_w + \alpha^2_j \cdot \Commitment'_{i-1}$ for each $j \in [3]$.
Furthermore, $\gr{Z}_{v_j} = q^{2^{i-1}} \cdot \gr{X}_{v_j} + \gr{W}_{v_j}$ such that $a_{v_j} \cdot \gr{W}_{v_j} = 0$ for each $j \in [3]$. 

Let $\mathbf{W} = (\gr{W}_{v_1}, \gr{W}_{v_2}, \gr{W}_{v_3})$ and let $a \deq lcm(a_{v_1}, a_{v_2}, a_{v_3})$. We can summarize these relations in the following matrix equations, where $\mathbf{A} \in \mathbb{Z}^{3\times 3}$ is the integer matrix with rows $(1, \alpha_j, \alpha_j^2)$:

$$\mathbf{A}
\begin{bmatrix}
\gr{X}_w \\ 
\gr{Y}_w \\ 
\Commitment_{i-1}
\end{bmatrix} 
=  
\begin{bmatrix}
\gr{X}_{v_1} \\ 
\gr{X}_{v_2} \\ 
\gr{X}_{v_3}
\end{bmatrix}
\ \ \text{and} \ \ 
\mathbf{D} \cdot 
\mathbf{A} \cdot 
\begin{bmatrix}
\gr{Y}_w \\ 
\gr{Z}_w \\ 
\Commitment'_{i-1}
\end{bmatrix} 
= 
\begin{bmatrix}
\gr{Z}_{v_1} \\ 
\gr{Z}_{v_2} \\ 
\gr{Z}_{v_3}
\end{bmatrix} 
= 
q^{2^{i-1}} \cdot 
\begin{bmatrix}
\gr{X}_{v_1} \\ 
\gr{X}_{v_2} \\ 
\gr{X}_{v_3}
\end{bmatrix}
+ 
\mathbf{W}  
\ \text{and} \ \ a \cdot \mathbf{W} = 0
$$

Substituting for the column vector $(\gr{X}_{v_1}, \gr{X}_{v_2}, \gr{X}_{v_3})$ we get: 

$$  \mathbf{A} \cdot 
\begin{bmatrix}
\gr{Y}_w \\ 
\gr{Z}_w \\ 
\Commitment'_{i-1}
\end{bmatrix} 
= 
q^{2^{i-1}} \cdot \mathbf{A} \cdot  
\begin{bmatrix}
\gr{X}_{w} \\ 
\gr{Y}_{w} \\ 
\Commitment_{i-1}
\end{bmatrix}  \ \
+ 
\begin{bmatrix}
\gr{W}_{v_1} \\ 
\gr{W}_{v_2} \\ 
\gr{W}_{v_3}
\end{bmatrix}  \ \
$$

Since $\mathbf{A}$ is a Vandermonde matrix with distinct rows, $det(\mathbf{A} \cdot \mathbf{D}) \neq 0$. Therefore, by Lemma~\ref{lem:extraction}, there exists a matrix $\mathbf{P}$ such that $\mathbf{P}\cdot \mathbf{A} = \mathbf{D}$ where $\mathbf{D}$ is a diagonal matrix with non-zero entries $d_1, d_2, d_3$. This means that: 

$$  
\begin{bmatrix}
d_1 \cdot \gr{Y}_w \\ 
d_2 \cdot \gr{Z}_w \\ 
d_3 \cdot \Commitment'_{i-1}
\end{bmatrix} 
= 
q^{2^{i-1}} \cdot
\begin{bmatrix}
d_1 \cdot \gr{X}_{w} \\ 
d_2 \cdot \gr{Y}_{w} \\ 
d_3 \cdot \Commitment_{i-1}
\end{bmatrix}  \ \
+ 
\mathbf{P} \cdot 
\mathbf{W} \ \ \text{and} \ \ a \cdot \mathbf{P} \cdot \mathbf{W} = 0
$$

This implies that $d_1 d_2 \cdot \gr{Z}_w = q^{2^{i-1}} \cdot (d_2 d_1 \cdot q^{2^{i-1}} \cdot \gr{X}_w + \langle \mathbf{P}_1, \mathbf{W} \rangle) + d_1 \cdot \langle \mathbf{P}_2, \mathbf{W} \rangle$. Let $d \deq d_1 d_2$ and let $\gr{W}_w \deq \gr{Z}_w - q^{2^{i}} \cdot \gr{X}_w$. 
We have that $d \cdot \gr{W}_w = q^{2^{i-1}} \cdot \langle \mathbf{P}_1, \mathbf{W} \rangle  + d_1 \cdot \langle \mathbf{P}_2, \mathbf{W} \rangle$. Hence, $a \cdot d \cdot \gr{W}_w = 0$. Set $a_w \deq a \cdot a$. 
 
We also have the relation $d_3 \Commitment'_{i-1} = q^{2^{i-1}} \cdot \Commitment_{i-1} + \langle \mathbf{P}_3, \mathbf{W} \rangle$. Setting $\gr{W}'_w \deq \Commitment'_{i-1} - q^{2^{i-1}} \cdot \Commitment_{i-1}$ we have $d_3 \cdot \gr{W}'_w = \langle \mathbf{P}_3, \mathbf{W} \rangle$, hence $a \cdot d_3 \cdot \gr{W}'_w = 0$. Let $a'_w \deq a \cdot d_3$.  
	\end{proof}

	
\begin{lemma}[Security Odd Even Dark]
	The protocol presented in \cref{sec:oddeven} is an interactive proof of knowledge for the $\Relation_\PC$ relation.
\end{lemma}
\ben{$\Relation_\PC$ is not yet defined anywhere else...}
\begin{proof}

~\paragraph{Extractor construction}
		We define a knowledge extractor that runs with an adversary $\adv$ who succeeds for public inputs $\{\Commitment,d,\Bound \}$ and $q$ with probability $\epsilon = 1/\poly$. The extractor begins by using the tree-finding algorithm of Lemma~\ref{lem:forking} to generate a tree of accepting transcripts with the following characteristics: 
\begin{itemize}
\item The tree has depth $\logd$ and branching factor $2$. We index nodes by $v \in [0, d)$.
\item The root is labeled with the publics inputs. 
\item Each non-leaf node $v$ distinct from the root is labeled with a challenge $\alpha_{v}$ and a prover message $\gr{C}_{E,v},\gr{C}_{O,v}$.
\item Each non-leaf node $v$ has two children each labeled with two distinct verifier challenges 
$\alpha_{v} \neq \alpha_{v}'$.
\item Each leaf node $v$ is labelled with the message $\hat{f}_v$ sent in a final round of the protocol. 
\end{itemize} 

\benedikt{Currently assuming the PoE relations are checked directly}
Since the verifier challenges in the protocol are sampled from $\mathcal{X} = [-2^{\lambda -1}, 2^{\lambda -1}]$, the probability of a collision over challenges $\alpha_1, \alpha_2 \sample \mathcal{X}$ sampled uniformly and independently is $2^{-\lambda}$. Thus, by Lemma~\ref{lem:forking} the tree-finding algorithm runs for $O(\poly/\epsilon)$ steps and succeeds with probability $1 - \negl/\epsilon$ to return a tree with these characteristics.

For the root node $\textsf{rt}$, define $\gr{C}_\textsf{rt} \deq \Commitment$. For any node $v$ on level $i$ which has verifier challenge $\alpha_v$ and a parent $w$ on level $i+1$ with prover message $\gr{C}_{E,w},\Commitment_{O,w}$, define $\gr{C}_v \deq \gr{C}_{E,w} + \alpha_v \cdot \gr{C}_{O,w}$.
We will show that given this tree, the extractor can compute for all nodes $v \in [0, d)$ an opening hint $(\hat{f}_v \in \ZZ(b)[X],\denom_v \in \ZZ,\gr{W}_v \in \GG,a_v \in \ZZ^+)$ for $\gr{C}_v$. That is: $\denom_v \cdot \gr{C}_v=\hat{f}_v(q) \cdot \Generator +\gr{W}_v$ and $a_v \cdot \gr{C}_v=0$. Additionally, for $v$ at level $i$, $||\hat{f}_v||_\infty \leq b\cdot 2^{(\log_2(d)+2(\logd-i)) \cdot \lambda}$.

It will do this by starting at the leaves and working its way up the tree.
For any leaf node $v$, the fact that the transcript is accepting implies $\Commitment_v= \hat{f}_v \cdot \Generator$ for $\hat{f}_v \leq b \cdot 2^{\logd \lambda}$. Recall $\hat{f}_v$ is a constant bounded by $\Bound \cdot 2^{\logd \lambda}$. Therefore, $(f,1,0,1)$ is a valid opening for $\Commitment_v$.

 Next, suppose that the appropriate openings have been computed for all children of a node $w$ on the $i$th level. Denoting the two children of nodes $w$ with indices $v_1, v_2$ and the two challenges on each by $\alpha_1, \alpha_2$ \benedikt{use $\alpha$, $\alpha$'}. This means that $\gr{C}_{v_1} = \gr{C}_{E,w} + \alpha_1 \cdot \gr{C}_{O,w}$ and $\gr{C}_{v_2} = \gr{C}_{E,w} + \alpha_2 \cdot \gr{C}_{O,w}$.
Furthermore openings $(\hat{f}_{v_1},\denom_{v_1},\gr{W}_{v_1},a_{v_1})$ for $\gr{C}_{v_1}$ and  $(\hat{f}_{v_2},\denom_{v_2},\gr{W}_{v_2},a_{v_2})$ for $\gr{C}_{v_2}$ have been computed. 

This gives us the equality: 
$$\hat{f}_{v_i}(q) \cdot \Generator + \gr{W}_i = r_i \cdot C_{v_i} = \denom_i \cdot (\Commitment_{E,w} + \alpha_i \cdot \Commitment_{O,w}) \quad \text{for} \ i \in \{1,2\}$$

From which we can derive:
$$(\denom_2 \hat{f}_{v_1}(q)-\denom_1 \hat{f}_{v_2}(q)) \Generator + \gr{W}_{O,w}=\denom_1 \denom_2 (\alpha_1-\alpha_2) \Commitment_{O,w}$$
and additionally
$$(\alpha_2 \denom_2 \hat{f}_{v_1}(q)-\alpha_1  \denom_1 \hat{f}_{v_2}(q)) \Generator + \gr{W}_{E,w}=\denom_1 \denom_2 (\alpha_2-\alpha_1) \Commitment_{E,w}$$

for $\gr{W}_{E,w}$ and $\gr{W}_{O,w}$ being elements of known order.
Using the extractor of the Batch PoE protocol we get that 
$$\gr{C}_w= \gr{C}_{E,w}+q^{2^i} \gr{C}_{O,w}+\gr{W}'$$
Let $\denom_w=\denom_1 \denom_2 (\alpha_22 − \alpha_1 )$. 
Further $\frac{\hat{f}_w}{\denom_w}=\frac{\denom_2 \hat{f}_{v_1}(q)-\denom_1 \hat{f}_{v_2}(q)}{\denom_1 \denom_2 (\alpha_1-\alpha_2)} \in \QQ$ is the reduced rational that encodes a polynomial in $\ZZ[X]$ with bounded coefficients. We will later argue about the size of the coefficients under different assumptions. 

\begin{itemize}
	\item Compute opening of $\Commitment_{E,w}$. 
	\item Use PoE to argue that we can compute an opening to $\Commitment_w$
	\item Argue bounded size
\end{itemize}
\paragraph{Coefficient size}
We will argue about the size of the extracted coefficients. Under the strong RSA assumption $\denom_w=1$ as otherwise by \benedikt{Fill in Lemma} we can compute a non trivial root of $\gr{G}$. This means in the extraction step the coefficient of $f_w(X)$ is less than the coefficients of $f_{v_1}$ and $f_{v_2}$ \benedikt{Exclude the case that $\alpha_1-\alpha_2=1$}. 
	\end{proof}


\section{Other ideas (WIP)}
\subsection{No field elements eval}


\begin{mdframed}
Public Input: $C\in \GG,z\in \ZZ_p,y\in \ZZ_p$\\
Witness: $f(X) \in \ZZ_p[X]$ \\
Claim: $C=\commit(f(X))$, $\deg(f(X))<d$ and $f(z)=y \bmod p$
	\begin{enumerate}[nolistsep]
		\item $\prover$ computes $q(X) \in \ZZ_p[X]=f(X)//(X-z) \bmod p$ and $Q\gets\commit(q(X))$
		\item \prover sends $Q$ to $\verifier$.
		\item $\prover$ and $\verifier$ compute $D\gets C/(Q^{(q-z)}g^y)$ \pccomment{$D$ commits to $h(X)=f(X)-q(X)(X-z)-y\equiv 0\bmod p$.}

		\item \prover and \verifier run $\textsf{DegreeProof}(D,Q^q,d;h(X),q(X)\cdot X)$
	\end{enumerate}
\end{mdframed}

Assume $d+1$ is a power of $2$
\begin{mdframed}
\begin{minipage}{\textwidth}
			$\pro{DegreeProof}(\crs, \gr{C},\gr{Q}\in \GG, d \in \NN; h(X),q(X)\in \ZZ_p[X]) :$ \pccomment{$\tilde{f}(X) = \sum_{i=0}^d \tilde{f}_i X^i$}
			\begin{enumerate}[nolistsep]
					\item \verifier samples challenge $\alpha$ 
			\item $\gr{C}'\gets \gr{C}^{\alpha}Q$
			\item \prover and \verifier run $\pro{DegreeProofBounded}(\params,q,\gr{C}',d,p\cdot 2^\lambda;\alpha \cdot h(X)+f(X))$
        \item \ \verifier checks that $b\cdot \boldsymbol{\varsigma}_{p,d} < q$\pccomment{$\boldsymbol{\varsigma}_{p,d}=O(p^{2\log(d)})$ (see Theorem~\ref{thm:polycommitsecurity} and \ref{thm:dyadicpolysecurity})}
        %q/(2^{\lceil \log_2(d+1) \rceil+1} p^{2 \lceil \log_2(d+1) \rceil+1})$
        \item \pcind[1] \verifier checks that $|h|\leq b$ and 
          \item \pcind[1] \verifier checks that $f\equiv 0 \bmod p$
                \item \label{line:baseend}\pcind[1] \verifier checks that $\Generator^{\alpha h}=\gr{C}$
\item \pcind[1] \verifier outputs $1$ \pcif all checks pass, $0$ otherwise.
		    \end{enumerate}
		    		\vspace{1em}
		$\pro{EvalBounded}(\crs,q,\gr{C}'\in \GG,d\in \NN,b\in \ZZ;\alpha h(X),f(X)\in \ZZ(b)[X])$		
	    \begin{enumerate}[nolistsep]
        \item \pcif $d=0$:
        \item \label{line:basestart}\pcind[1] \pcreturn $\gr{C}$ to $\prover$ and $\verifier$ and $\alpha h(X), f(X)$ \pccomment{$\alpha h(X)$ and $f(X)$ are constants}

        
        \item \pcelse: \pccomment{$d \geq 1$ and $d+1$ is even}
       
        \item \pcind[1] \prover and \verifier compute $d' \gets \lfloor\frac{d}{2}\rfloor$
        \item \pcind[1] \prover computes $f_E(X) \gets \sum\limits_{i=0}^{d'} f_{2\cdot i} \cdot X^i$ and $f_O(X)\gets\sum\limits_{i=0}^{d'} f_{2\cdot i 1}\cdot X^{i}$
        \item \pcind[1] \prover computes $\gr{C}_E \gets \Generator^{f_L(q^2)}$ and $\gr{C}_O \gets \Generator^{f_R(q^2)}$
        \item \pcind[1] \prover sends $\gr{C}_E, \gr{C}_O$ to \verifier. \pccomment{See Section \ref{subsec:optimization} for an optimization}
        \item \pcind[1] \label{line:PoE} \prover and \verifier run $\pro{PoE}(\gr{C}_E, \gr{C}/\gr{C}_O, q)$\pccomment{Showing that $\gr{C}_E\gr{C}_O^{q}=\gr{C}$}
        \item \pcind[1] \verifier samples $\alpha \sample [-2^{\lambda-1},2^{\lambda-1}]$ and sends it to \prover
        \item \pcind[1] \prover and \verifier compute $\gr{C}' \gets \gr{C}_E^\alpha  \gr{C}_O$, $b'\gets b \cdot 2^{\lambda}$. 
        \item \pcind[1] \prover computes $f'(X) \gets \alpha \cdot f_E(X) + f_O(X) \in \ZZ[X]$  and\\
        \pcind[1] $h'(X)=\alpha h_E(X) + h_O(X)$\pccomment{$\deg(f'(X))=\deg(h'(X))=d'$}
        \item \pcind[1] \prover and \verifier run $\pro{EvalBounded}(\params, \gr{C}',q^2, d',b' ; \alpha f'(X))$
               \end{enumerate}
      \end{minipage}
\end{mdframed}


\section{Ben's lemmas}

Let $\G$ denote the abelian group (i.e., $\G$ is a $\Z$-module) that contains the space of commitments for the PCS. We first prove an elementary linear algebraic fact. 

\begin{lemma}\label{lem:triangularization}
Let $\G$ be a $\Z$-module. Let $p$ be a prime and $\F = \Z_p$. Given two vectors $\x, \y \in \G^n$ and a system of equations $\mathbf{A} \x = \y$ for a matrix $\A \in \Z^{n \times n}$ that is invertible over $\F$, 
there is an efficient algorithm to derive a diagonal matrix $\mathbf{D}$ with diagonal entries  $(d_1,...,d_n) \in \Z^n$, where $d_i \neq 0 \bmod p$ for all $i$, and a matrix $\mathbf{L}$ such that $\mathbf{D} \cdot \x = \mathbf{L} \cdot \y$. In particular, $\mathbf{L} \mathbf{A} = \mathbf{D}$.    
\end{lemma} 
\begin{proof} 
Since $det(\mathbf{A}) \neq 0 \bmod p$, by Gaussian elimination there is a triangularization matrix $\mathbf{P}$ such that $\mathbf{P} \mathbf{A} = \mathbf{T}$ is lower triangular with a diagonal of integer values that are non-zero over $\F$ (i.e., it is in reduced row-echelon form). 
Since $\mathbf{P} \mathbf{A} \cdot \x = \mathbf{T} \cdot \y= \mathbf{P}\cdot \y$, there exists an integer $d_1$ (i.e., upper left entry of $\mathbf{T}$) such that $d_1 \cdot x_1 =\langle \mathbf{P}_1, \y \rangle$, where $\mathbf{P}_1$ is the first row of $\mathbf{P}$. Denote by $\x^{(i)}$ the vector that swaps the 1st and $i$th coordinates of $\x$. Denote by $\A^{(i)}$ the matrix that results from swapping the first and $i$th columns of $\A$. We have $\A^{(i)} \x^{(i)} = \y$. 
 For each $i \in [n]$, repeat the triangularization process on $\A^{(i)}$ to get $\mathbf{P}^{(i)}$ such that $\mathbf{P}^{(i)} \cdot \A^{(i)} = \mathbf{T}^{(i)}$ is lower triangular. The upper left entry of $\mathbf{T}^{(i)}$ is an integer $d_i \neq 0 \bmod p$, and $d_i \cdot x_i = \langle \mathbf{P}^{(i)}_1, \y \rangle$.
  Return the matrix $D$ with diagonal entries $d_1,...,d_n$ and the matrix $L$ with row vectors $\mathbf{P}^{(i)}_1$ for $i \in [n]$. 
\end{proof} 

The next lemma is a direct result of this fact. 

\begin{lemma}\label{lem:extraction}
Given two vectors of commitments $\mathbf{C}, \mathbf{C^*} \in \G^n$, a system of equations $\mathbf{A} \mathbf{C} = \mathbf{C^*}$ for an integer matrix $\mathbf{A} \in \Z^{n \times n}$ that is invertible over $\F_p$, and a vector of openings of $\mathbf{C^*}$ to a vector of polynomials $\mathbf{f^*} = (f_1^*,...,f_n^*) \in (\FF)^n$, there is an efficient algorithm to derive polynomials $\mathbf{f} = (f_1,...,f_n) \in (\FF)^n$, integer vector $\mathbf{t} \in \Z^n$ such that $t_i \neq 0 \bmod p$, and openings for each $t_i \cdot \mathbf{C}_i$ to the polynomial $t_i \cdot f_i \bmod p$ such that $\mathbf{A} \cdot \mathbf{f} = \mathbf{f^*} \bmod p$. 
\end{lemma} 
\begin{proof} 
By Lemma~\ref{lem:triangularization}, there exists a diagonal matrix $\mathbf{T}$ with integer entries $t_1,...,t_n \neq 0 \bmod p$ and a matrix $\mathbf{L}$ such that $\mathbf{T} \cdot \mathbf{C} = \mathbf{L} \cdot \mathbf{C}^*$ and $\mathbf{L} \cdot \mathbf{A} = \mathbf{T}$. 
  From each linear combination of $\mathbf{C^*}$, we use $\add^*$ to derive an opening of $t_i \cdot \mathbf{C}_i$ to a polynomial $g_i = \langle \mathbf{L}_i, \mathbf{f^*} \rangle \in \FX$.
   Let $\mathbf{g} = (g_1,...,g_n)$. Finally, solve for the vector of polynomials $\mathbf{f}$ such that $\mathbf{A} \cdot \mathbf{f} = \mathbf{f^*}$ by computing $\mathbf{A}^{-1} \bmod p$. Note that $\mathbf{L} \cdot \mathbf{A} \cdot \mathbf{f} = \mathbf{T} \cdot \mathbf{f} = \mathbf{L} \cdot \mathbf{f}^*$ where $\mathbf{T}$ is a diagonal matrix with entries $t_i \neq 0 \bmod p$. Thus, $t_i f_i = g_i$, for which we have a valid opening of $t_i \cdot \mathbf{C}_i$.   
\end{proof}

\begin{lemma}[Forking Lemma]\label{lem:forking}
Let $(\prover, \verifier)$ be an $r$-round public-coin interactive proof system and $\mathcal{A}$ an adversary such that $\langle \mathcal{A}(\pp, x), \verifier(\pp, x) \rangle = 1$ with probability $\epsilon > \negl(\lambda)$ on public input $x$ and public parameters $\pp$.  Let $\{\pi_i\}_{i =1}^r$ be a set of properties $\pi_i: \mathcal{X}^2 \rightarrow \{0,1\}$ such that $\forall_{i} \ Pr[ \pi(x_1, x_2) = 1: x_1, x_2 \sample \mathcal{X}] > 1 - \negl(\lambda)$. There exists an algorithm $\mathcal{T}$ that runs in time $O(\lambda/\epsilon)$ and outputs an $(n_1,...,n_r)$-tree of accepting transcripts such that with probability $\Omega(1 - \frac{r \cdot\negl(\lambda)}{\epsilon})$ in each $i$th level of the tree every pair of sibling-node challenges $x_1, x_2$ satisfy $\pi_i(x_1, x_2) = 1$. 
\end{lemma} 

\section{Evaluation}

We evaluate 
 \bibliographystyle{IEEEtran}
 \bibliography{../cryptobib/abbrev3,../cryptobib/crypto,cryptobib/additional}
\end{document}