
Since the landmark discoveries of \emph{interactive proofs} (IPs)~\cite{STOC:GolMicRac85} and the ``PCP theorem" on \emph{probabilistically checkable proofs} (PCPs)~\cite{STOC:BFLS91, FOCS:ALMSS92} in the 90s, there has been tremendous development in the area of proof systems whereby a prover establishes the correct performance of an arbitrary computation in a way that can be verified much more efficiently than performing the computation itself. Such proof systems are \emph{succinct} if they also involve low communication between the prover and verifier, i.e. much smaller than a transcript of the whole computation. There are also \emph{zero knowledge} variants of these efficient proof systems, beginning with ZK-PCPs~\cite{STOC:Kilian92} and ZK-IPs~\cite{C:BGGHKMR88}, in which the expensive computation may involve secret information and the prover demonstrates correct performance without leaking the secrets. 

In recent years, there has been a surge of industry interest in applying proof systems to outsourced verifiable computation~\cite{Sources}. These proof systems are particularly relevant to blockchains, which use efficient zero-knowledge proofs as a solution for balancing privacy and publicly-verifiable integrity: examples include anonymous transaction in ZCash~\cite{SP:BCGGMT14, Zcash}, and verifying Ethereum smart contracts over private inputs~\cite{}. Verifiable computation is also used as a way to synchronize more efficiently with the current state of a blockchain~\cite{Rollup}, or even entirely eliminate the need for maintaining historical blockchain data~\cite{Coda}. 

Following this pragmatic interest, there has also been a surge of research focussed on obtaining proof systems with better concrete efficiency characteristics. Relevant characteristics include: non-interaction (the proof is a single message), succinctness (the proof size is sublinear in the original computation length $T$), proof generation time that scales linearly or quasi-linearly in $T$, and verification time that is sublinear in $T$. Proof systems that achieve all of these properties for general NP statements\footnote{NP statements can be verified deterministically in polynomial time given a suitable \emph{witness}. More formally, a language $L \subseteq \{0,1\}^*$ is in $NP$ if there is a non-determinstic polynomial time decision algorithm $V_L$ for $L$: for every $x \in \{0,1\}^*$ there exists a witness $w$ such that $V_L(x, w) = 1$ iff $x \in L$. If $C$ is a circuit, the statement that $C(x) = y$ can be expressed as an NP statement $(C, x, y)$ with a witness $w$ that assigns correct values to all the internal wires of $C$ producing the output $y$ on input $x$.} are called SNARGs (``short non-interactive arguments"). 
The proof is called an \emph{argument} because it is only sound assuming the prover is computationally bounded, i.e. \emph{computationally sound} as opposed to statistically sound. Succinct statistically sound proofs are unlikely to exist~\cite{CC:GolVadWig02, ICALP:Wee05}. 
A SNARG for NP statements is called a SNARK (``short non-interactive argument of knowledge") if the proof also demonstrates knowledge of the NP witness for the statment. A zk-SNARK does not leak any information about the witness. 


Currently, there are numerous constructions that achieve different tradeoffs between proof size, proof time, and verification time, but also under different \emph{trust} models as well as cryptographic assumptions. %There is a distinction between \emph{proofs} and \emph{arguments}, the latter offering soundness only against a computationally bounded prover. 
Some constructions also achieve better efficiency by relying on a \emph{preprocessing model} in which a one-time expensive setup procedure is performed in order to generate a compact verification key \pro{VK}, which is later used to verify proof instances efficiently. More precisely, a fresh \pro{VK} must be generated for each computation that will be proven, e.g. represented as an arithmetic circuit $C$ that takes inputs $x \in \FF^n$ over a prime field $\FF$. Therefafter, succinct proofs may be generated for the evaluation of $C$ on arbitary inputs $x$ and verified efficiently with \pro{VK}. 

Somewhat unfortunately, the best performing proof systems to date (considering proof size and verification time) require a \emph{trusted} preprocessing. These are the pairing-based SNARKs extending from GGPR~\cite{EC:GGPR13, ES:SBVBPW13, SP:PHGR13, TCC:BCIOP13, C:BCGTV13, USENIX:BCTV14, EC:Groth16}, which have been implemented in numerous libraries~\cite{C:BCGTV13,bellman}, and even deployed in live systems including the ZCash\footnote{ZCash. \url{https://z.cash}} cryptocurrency. The preprocessing involves secret information that must be discarded, else it provides the prover with a trapdoor that breaks the integrity of the proof system. To avoid trust in a central point of failure, the setup can be performed via \emph{multi-party computation} (MPC) by a committee of parties, such that trust in only one of the parties is sufficient. This has been done on two occassions for the ZCash blockchain, involving elaborate ``ceremonies" to engender public trust in the process.\footnote{The Zcash Ceremony. \url{https://electriccoin.co/blog/the-design-of-the-ceremony/}. 2016.}

A proof system is called \emph{transparent} if it does not involve any trusted setup. Recent progress has yielded transparent proof systems for special types of computations: zk-STARKs~\cite{ICALP:BBHR18} generate zero-knowledge proofs $O(\log^2 T)$ for \emph{uniform computations}\footnote{A uniform computation is expressed as a RAM program $P$ and a time bound $T$ on the running time of the program. Letting $|P|$ denote the size of $P$'s description, STARKs produce proofs of size $O(|P| + \log^2 T)$.}, and public-coin interactive proofs with communication $O(d \log T)$ for computations expressed as low-depth circuits of total size $T$ and depth $d$ based on the GKR protocol~\cite{STOC:GolKalRot08}. The interactive proofs can be made non-interactive using random oracles (i.e. in practice, hash functions that heuristically behave like random functions)~\cite{C:FiaSha86, STOC:CCHLRRW19}. The original GKR protocol was not zero-knowledge, but there are more recent zero-knowledge variants that have communication $O( \sqrt{n} + d \log T)$ where $n$ is the size of the (secret) input~\cite{SP:WTSTW18, EPRINT:ZGKPP17b}. 

Another thread of research has produced proof systems that remove trust from the circuit preprocessing step, and instead have a \emph{universal} (trusted) setup (i.e. a one-time trusted setup that can be reused for any computation)~\cite{Sonic, Libra, Spartan, Plonk}. All of these systems build SNARKs by combining an underlying reduction of circuit satisfiability to probabilistic testing of polynomials (with degree at most linear in the circuit size) together with \emph{polynomial commitment schemes}. In a polynomial commitment scheme, a prover commits to a polynomial $f: \FF^\mu \rightarrow \FF$ of degree at most $d$ with a message $c_f$ that is much smaller than sending all the coefficients of $f$ (i.e. sublinear in $\mu^d$). The prover can later produce a non-interactive argument that $f(x) = y$ for arbitrary $x \in \FF^\mu$ and $y \in \FF$. It should be infeasible for the prover to claim $f(x) = y'$ and $f(x) = y$ for $y \neq y'$. Universal SNARK constructions also require this evaluation protocol to itself be a knowledge argument, i.e. a succesful prover must know the coefficients of the committed polynomial. The trusted portion of the universal SNARK is entirely confined to the polynomial commitment scheme's parameter generation protocol. These constructions use variants of the Kate et. al. bilinear-group based commitment scheme for univariate polynomials~\cite{AC:KatZavGol10}, which requires a trusted party to generate a length $d$ vector of group elements of the form $g^{s^i}$ for a secret point $s \in \FF$. 

According to a concrete comparison~\cite{Libra} of proof systems' performance (prior to the present work) on a computation that derives the root of a SHA-256 Merkle tree with 256 leaves\footnote{This computation involves 511 calls to SHA-256.}, STARKs are the only transparent non-interactive proof system capable of producing a proof (in a practical\footnote{The STARK computation cited here takes about 30 minutes to generate.}  amount of time) that can be verified in under 9 seconds, and yet the proof size is nearly 400 KB. The main practical outcome of our present work is an alternative transparent proof system (\pro{Supersonic}) for computations represented as arbitrary arithmetic circuits that improves the proof size by an order of magnitude over STARKs without compromising on verification time. As a caveat, while the prover time in \pro{Supersonic} is asymptotically on par with STARKs (i.e. quasilinear in $T$), the concrete efficiency is much worse due to the use of heavy-weight ``crypto operations" over 1200 bit elements in class groups of a quadratic number field in contrast to the light-weight FFTs and hash functions in STARKs. 

\subsection{Summary of contributions} 
\alan{The first part of this sentence is wrong (I think). The universality of recent SNARKs has nothing to do with how they become transparent if you replace the polynomial commitment scheme by a transparent one.}Following the observations of the recent universal SNARK constructions~\cite{Plonk, Sonic, Libra}, transparent SNARKs can be built from polynomial commitment schemes that do not require a trusted setup (i.e. transparent polynomial commitments). This observation was also implicit in the recent works (including STARKs) that build transparent SNARKs from multi-round classical PCPs, and specifically interactive oracle proofs of proximity (IOPPs)~\cite{ICALP:BBHR18}. The main technical contribution of our work is thus a new polynomial commitment scheme.

\paragraph{New polynomial commitment scheme} The construct a new polynomial commitment scheme for $\mu$-multivariate polynomials of degree $d$ with evaluation arguments of knowledge that have $O(\mu \log d)$ size proofs verifiable in $O(\mu \log d)$ time. The commitment scheme requires a group of unknown order: two candidate instantiations are RSA groups and class groups of a quadratic number field. Using RSA groups, we can apply the scheme to obtain universal preprocessing SNARKs with \emph{constant-size} setup parameters, as opposed to the linear-size parameters from previous attempts. Using class groups, we obtain the first transparent preprocessing SNARKs with $O(\log d)$ proof size and $O(\log d)$ verification time. %The security of either instantiation relies on concrete falsifiable assumptions that must hold in the group. Well...not quite, as the zk version needs PoKE. 

\paragraph{Polynomial IOP compiler} As a secondary contribution, we present a framework that unifies all existing approaches to constructing SNARKs from polynomial commitments. This framework is based on interactive oracle proofs (IOPs)~\cite{STOC:ReiRotRot16, TCC:BenChiSpo16} (a multi-round generalization of PCPs) and the popular analytical paradigm that separates SNARK constructions into at least two distinct components: an underlying information-theoretic statistically-sound protocol (e.g. PCP or IOP) and a ``cryptographic compiler". The cryptographic compiler transforms the underlying information theoretic protocol into a succinct non-interactive argument at the cost of computational-soundness. 

We define a \emph{polynomial IOP} as a refinement of linear IOPs~\cite{IKO07, C:BBGGI19}, where in each round of interaction the prover provides the verifier with oracle access to a polynomial function of bounded degree. The verifier may then query this oracle to evaluate the polynomial on arbitrary points of its choice. All existing universal and transparent SNARK constructions are based on an underlying statistically-sound polynomial IOP for circuit satisfiability (or bounded RAM programs in the case of STARKs). Even the linear PCPs underlying GGPR and its successors (i.e. based on QAPs and R1CS) can be expressed as a polynomial IOP.\footnote{This observation was already made in the paper by Ben-Sasson et. al. introducing the system \pro{Aurora}~\cite{EC:BCRSVW19}.} We present a generic compilation of any public-coin polynomial IOP into a doubly-efficient public-coin interactive argument of knowledge using an abstract polynomial commitment scheme. We prove that if the commitment scheme's evaluation protocol has the knowledge property called witness-extended emulation, then the compiled interactive argument has this knowledge property as well. If the commitment scheme is hiding and the evaluation is honest-verifier zero knowledge (HVZK), then the compiled interactive argument is HVZK as well. Finally, public-coin interactive arguments may be cryptographically compiled into SNARKs using the Fiat-Shamir transform.\footnote{Security for Fiat-Shamir has been proven secure in the random oracle model for constant-round protocols, for multi-round protocols satisfying \emph{soundness against restoration attacks}, and in some cases using correlation-intractable hash functions~\cite{C:FiaSha86,CCS:BelRog93,EC:PoiSte96,CSproofs,TCC:HalMyeRac08,TCC:BenChiSpo16,EC:AABN02,C:KalRotRot17,EC:CCRR18,FOCS:HolLom18,STOC:CCHLRRW19}.}

\subsection{Related Work}

\paragraph{Arguments based on hidden order groups} 
Homomorphic integer commitment schemes based on the RSA group were first proposed by Fujisaki and Okamoto~\cite{C:FujOka97}, who also provide a protocol to prove that a list of committed integers satisfy a polynomial equation modulo an arbitrary positive integer as well as one for opening a commitment bit by bit. Damgård and Fujisaki~\cite{AC:DamFuj02} fix an issue with the soundness proof of that protocol and are the first to suggest using class groups of an imaginary quadratic order as a candidate group of unknown order. Around the same time, Lipmaa draws the link between zero-knowledge proofs constructed from integer commitment schemes and Diophantine complexity~\cite{AC:Lipmaa03b}. Much later, Couteau~\emph{et al.} study protocols derived from integer commitments specifically in the RSA group in order to lift their security proofs so as to require weaker assumptions; in the process they develop proofs for polynomial evaluation modulo a prime $\pi$ that is not initially known to the verifier, in addition to a proof showing that an integer $X$ lies in the range $[a,b]$ by showing that $1+4(X-a)(b-X)$ decomposes as the sum of 3 squares~\cite{EC:CouPetPoi17}.

Pietrzak~\cite{ITCS:Pietrzak18} developed an efficient proof of repeated squaring, i.e. proving that $x^{2^T} = y$ with $O(\log T)$ proof size and verification time in order to build a conceptually simple verifiable delay function~\cite{C:BBBF18} based on the RSW time-lock puzzle~\cite{RivShaWag96}. Wesolowski~\cite{EC:Wesolowski19} improves on this result by proposing a single-round protocol to prove correct repeated squaring in groups of unknown order with a constant size proof. Boneh~\emph{et al.} observe that this protocol generalizes to arbitrary exponents (PoE) and developed a proof of knowledge of an integer exponent (PoKE), as well as a zero-knowledge variant. They apply both PoE and PoKE to constructing efficient accumulators and vector commitment schemes~\cite{C:BonBunFis19}.

\paragraph{Transparent polynomial commitments} 
Whaby et. al. constructed a transparent polynomial commitment scheme combining a matrix commitment of Bootle et al.~\cite{EC:BCCGP16} with the inner-product argument of B\"{u}nz et. al. ~\cite{SP:BBBPWM18}. This commitment works for multilinear polynomials, and for polynomials of degree $d$ it has $O(\sqrt{d})$ size commitments and evaluation arguments with $O(\sqrt{d})$ communication. The DEEP-FRI protocol~\cite{ECCC:BGKS19}, an improvement of FRI (Fast Reed Solomon IOPP)~\cite{ICALP:BBHR18}, is also implicitly a transparent polynomial commitment scheme that has $O(\lambda)$ size commitments and evaluation arguments with $O(\log ^2 d)$ communication. This connection is explicitly described in a recent manuscript~\cite{MatterLabs}. 

%\subsection{Background on SNARGs and SNARKs} 
%A SNARG is a system for generating ``short non-interactive arguments". Given any statement $x$ that can be verified in polynomial time $T$, a SNARG prover can generate a \emph{succinct} proof $\pi$ that can be publicly verified in time much less than $T$ (i.e. sublinear in $T$). The proof $\pi$ is called succinct because it is much smaller than printing a transcript of the $T$ computation steps that verify $x$ (i.e. also sublinear in $T$). The proof is called an \emph{argument} because it is only sound assuming the prover is computationally bounded.
%Comment on applications. 

%Placed in the contexts of NP language, a SNARG prover for an NP language with relation $\mathcal{R}$ generates an argument for any instance $x$ in the language, proving the existence of a witness $w$ such that $(x, w) \in \mathcal{R}$. existence of a  circuits,   original sublinear in the    It is a proof system that can be used to 

\if 0  
\section{Introduction}

A polynomial commitment scheme enables a prover to bind himself to a polynomial in much less bandwidth than transmitting all coefficients would require. A skeptical verifier can subsequently test the commitment for certain algebraic relations as though he were in possession of the polynomial's full description, except at a much smaller work cost. Indeed, polynomial commitments lie at the heart of a host of efficiently verifiable interactive proof systems.

Of particular interest to this paper are proof systems whereby the prover establishes the correct performance of an arbitrary computation (that may or may not involve secret information) in such a way that the communication or verification complexity scales asymptotically better than performing the computation naïvely. Without exception, these proof systems rely on a technique called \emph{arithmetization}: characterizing the computation in question as a collection of arithmetic operations over a finite field. The utility of polynomial commitments stems from their capacity to succinctly capture a canonical representation of such collections while retaining the algebraic properties that make arithmetization work in the first place.

The literature on proof systems for arbitrary computations focuses on two techniques to achieve polynomial commitments. First: Merkle trees --- here every leaf represents the polynomial's evaluation in a given point, and the Merkle root represents the commitment to the polynomial. The verifier needs to verify the authentication paths of selected points, which can be done in logarithmic space and time (as a function of the number of points). Second: groups equipped with bilinear maps --- in this case a structured reference string (SRS)\footnote{Previously known as \emph{common reference string}, CRS.} provides the values of all monomials up to a given degree when evaluated in an unknown point. By computing a weighted sum of these monomial values, the prover obtains the evaluation of his polynomial in the unknown point. The verifier performs the pairing operation to verify that multiplicative relations hold between committed polynomials.

This paper provides a third option for generating polynomial commitment schemes, namely by relying on groups of unknown order --- such as the group of integers with multiplication modulo an RSA modulus of unknown factorization, or the ideal class group of an order of an imaginary quadratic number field. These groups have seen relatively little adoption or even attention from the cryptographic community because the only known constructions thereof have subexponential attack algorithms. As a result, for a practical security level, elements of groups of unknown order typically require several hundreds of bytes to represent, in contrast to the tens of bytes needed for elements of elliptic curves for which no subexponential algorithms exist. 

Nevertheless, groups of unknown order provide a property that groups of known order, such as elliptic curve groups, cannot match: they enable homomorphic  commitments to an \emph{infinite} domain, namely the integers. Indeed, if the prover were capable of reducing a large integer to a smaller one without sacrificing the homomorphic properties, then he must know the group's order. The power of integer commitments was already noted by Lipmaa~\cite{AC:Lipmaa03b} who characterizes proof systems arising therefrom as \emph{Diophantine} --- a reference to the family of languages for which such proof systems establish. Specifically, a set $S \subset \mathbb{Z}^n$ is called \emph{Diophantine} if it is the projection onto the first $n \leq m$ coordinates of the set of roots to a polynomial $P(X_1, \ldots, X_m) \in \mathbb{Z}[X_1, \ldots, X_m]$.% Much more recently, Wesolowski produced a conceptually simple verifiable delay function (VDF) which builds on a proof of correct exponentiation in groups of unknown order. Building on this result, Boneh \emph{et al.} developed accumulators and vector commitments (with batch openings) from groups of unknown order~\cite{}. 

\alaninline{Todo: \\
 - applications (trustless snarks etc) \\
 - implications (no unfalsifiable assumptions) \\
 - overview of techniques \\
 - related work}

\vspace{0.25cm}
\textsc{Contributions.} The contributions of this paper are divisible into three rubrics:
\begin{itemize}
    \item[] \textbf{Tools.} We start with an encoding scheme that represents polynomials over a prime field $\mathbb{F}_p$ as integers, by encoding the polynomial's coefficients into the integer's base-$q$ expansion. Adjoined with a group of unknown order and a designated base element $g \in \mathbb{G}$, this encoding scheme naturally gives rise to a polynomial commitment scheme that inherits its somewhat homomorphic properties. Next, we provide protocols for proving the correct evaluation of a committed polynomial, and showing that two polynomials have the same coefficients but flipped or rotated. We also present a protocol for extracting the $i$th coefficient, thereby promoting the commitment scheme to one that also provides vector commitment functionality. Building on this observation, we provide another protocol for showing that a commitment represents the inner product between two vectors of which at least one is represented by its vector commitment. Another protocol establishes that two vector commitments represent the same vector up to an arbitrary but known permutation of the coefficients.
    \item[] All the proof systems mentioned so far have logarithmic communication complexity and logarithmic verification time. Moreover, with the exception of the inner product proof and the permutation proof, the prover's complexity is quasi-linear. If one is willing to sacrifice this scalability for the prover, we also provide counterparts to all the above proofs with constant communication and verification complexity.
    \item[] \textbf{Applications.} To illustrate the usefulness and the versatility of the enumerated tools, we join them straightforwardly to construct a simple succinct non-interactive argument of knowledge (SNARK) based on quadratic arithmetic programs (QAPs). To the best of our knowledge, this is the first SNARK for circuits without trusted setup (when instantiated with the class group) or with an SRS whose size is independent of the circuit (when instantiated with the RSA group).\footnote{This classification takes note of the STARK proof system of Ben Sasson \emph{et al.}~\cite{C:BBHR19} whose verification time is polylogarithmic but as a function of the \emph{running time} of some program and not of any circuit; as well as of Hyrax~\cite{SP:WTTW17} and Spartan~\cite{eprint:Setty19}, which do apply to circuits but whose verification times are not polylogarithmic and thus fail to satisfy the definition of SNARKs as set forth in the paper that coined the term~\cite{JC:BCCGLRT17}.}
    \item[] \alan{deprecated} We follow up this conceptually simple QAP-based proof system with a survey of popular communication-efficient proof systems for arbitrary computations, in which we replace their constituent components with tools developed earlier in this paper. In this light we analyze Sonic, Spartan, Hyrax, Bulletproofs, and STARK. In all cases we find that using our techniques leads to different trade-offs; improving on some metrics while degrading others.
\end{itemize}
\fi 
